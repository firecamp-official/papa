<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
  <title>Anniversaire Papa ‚öîÔ∏è ULTIMATE</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323:wght@400&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      image-rendering: pixelated;
      -webkit-tap-highlight-color: transparent;
    }

    html,
    body {
      background: #000;
      overflow: hidden;
      font-family: 'Press Start 2P', monospace;
      touch-action: none;
      width: 100%;
      height: 100%;
    }

    /* ====== TITLE ====== */
    #title {
      position: fixed;
      inset: 0;
      z-index: 300;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: radial-gradient(ellipse at 50% 60%, #0d1a0a 0%, #050a03 100%);
    }

    #title-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
    }

    .title-content {
      position: relative;
      z-index: 2;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding: 0 20px;
      width: 100%;
    }

    .title-logo {
      font-size: clamp(13px, 3.5vw, 26px);
      color: #ffd700;
      text-align: center;
      line-height: 2.2;
      text-shadow: 0 0 20px #ffd700aa, 4px 4px 0 #8b5e00, 8px 8px 0 #3a2500;
      animation: logoPulse 3s ease-in-out infinite;
      letter-spacing: 2px;
    }

    .title-tagline {
      font-family: 'VT323', monospace;
      font-size: clamp(18px, 4vw, 32px);
      color: #e8d890;
      text-shadow: 2px 2px 0 #553300;
      letter-spacing: 3px;
    }

    .title-sword {
      font-size: clamp(50px, 10vw, 80px);
      animation: swordFloat 2.5s ease-in-out infinite;
      filter: drop-shadow(0 0 20px #ffd700);
    }

    .start-btn {
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(9px, 2vw, 13px);
      background: linear-gradient(180deg, #c8a020 0%, #8b5e00 100%);
      color: #000;
      border: none;
      padding: 14px 32px;
      cursor: pointer;
      box-shadow: 0 0 0 3px #ffd700, 0 0 0 5px #000, 4px 4px 0 #000;
      margin-top: 6px;
      letter-spacing: 1px;
    }

    .start-btn:active {
      transform: translate(3px, 3px);
      box-shadow: 0 0 0 3px #ffd700, 0 0 0 5px #000, 1px 1px 0 #000;
    }

    .title-features {
      font-family: 'VT323', monospace;
      font-size: clamp(13px, 3vw, 19px);
      color: #9a8a60;
      text-align: center;
      line-height: 1.9;
      margin-top: 4px;
    }

    @keyframes logoPulse {

      0%,
      100% {
        text-shadow: 0 0 20px #ffd700aa, 4px 4px 0 #8b5e00, 8px 8px 0 #3a2500;
      }

      50% {
        text-shadow: 0 0 40px #ffd700, 4px 4px 0 #ffd700, 8px 8px 0 #8b5e00, 0 0 80px #ffd70066;
      }
    }

    @keyframes swordFloat {

      0%,
      100% {
        transform: translateY(0) rotate(-30deg);
      }

      50% {
        transform: translateY(-12px) rotate(-38deg);
      }
    }

    @keyframes blinkAnim {
      50% {
        opacity: 0;
      }
    }

    /* ====== GAME ====== */
    #game {
      position: fixed;
      inset: 0;
      display: none;
    }

    #gc {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* ====== HUD ====== */
    #hud {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 64px;
      z-index: 100;
      pointer-events: none;
      background: linear-gradient(180deg, rgba(2, 2, 10, 0.99) 0%, rgba(3, 3, 14, 0.92) 100%);
      border-bottom: 2px solid rgba(255, 215, 0, 0.35);
      box-shadow: 0 3px 0 rgba(255, 215, 0, 0.08), 0 6px 20px rgba(0, 0, 0, 0.9);
    }

    .hud-inner {
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: 100%;
      padding: 0 14px;
      gap: 8px;
    }

    .hud-block {
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .hud-label {
      font-size: clamp(5px, 1.5vw, 7px);
      color: rgba(255, 215, 0, 0.7);
      letter-spacing: 2px;
      text-transform: uppercase;
    }

    .hud-val {
      font-size: clamp(7px, 2vw, 11px);
      color: #ffd700;
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
    }

    .hearts-row {
      display: flex;
      gap: 3px;
      align-items: center;
      flex-wrap: wrap;
      max-width: 180px;
    }

    .heart-full {
      width: 16px;
      height: 16px;
      background: linear-gradient(135deg, #ff4444, #cc1111);
      border: 1.5px solid #ff6666;
      clip-path: polygon(50% 90%, 0% 35%, 15% 10%, 50% 25%, 85% 10%, 100% 35%);
      box-shadow: 0 0 8px rgba(255, 50, 50, 0.7), inset 0 1px 0 rgba(255, 180, 180, 0.3);
    }

    .heart-empty {
      width: 16px;
      height: 16px;
      background: #1c0808;
      border: 1.5px solid #441818;
      clip-path: polygon(50% 90%, 0% 35%, 15% 10%, 50% 25%, 85% 10%, 100% 35%);
    }

    .xp-bar-wrap {
      width: 90px;
      height: 6px;
      background: #080818;
      border: 1px solid rgba(40, 80, 200, 0.4);
      border-radius: 3px;
      overflow: hidden;
    }

    .xp-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #1166ff, #00eeff);
      transition: width .3s;
      border-radius: 3px;
      box-shadow: inset 0 0 6px rgba(0, 200, 255, 0.4);
    }

    .weapon-badge {
      font-size: clamp(5px, 1.5vw, 8px);
      color: #ffdd55;
      background: rgba(255, 200, 0, 0.07);
      border: 1px solid rgba(255, 215, 0, 0.25);
      padding: 3px 7px;
      text-shadow: 0 0 8px rgba(255, 200, 0, 0.4);
    }

    .hud-quest-text {
      font-size: clamp(5px, 1.4vw, 7.5px);
      color: #ccbbaa;
      max-width: 140px;
      line-height: 1.7;
      text-align: right;
    }

    .lvl-badge {
      font-size: clamp(6px, 1.6vw, 9px);
      color: #44ddff;
      text-shadow: 0 0 8px rgba(0, 200, 255, 0.6);
    }

    /* ====== BOSS HP BAR ====== */
    #boss-hud {
      position: fixed;
      top: 64px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
      width: min(400px, 88vw);
      display: none;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      padding: 7px 14px 8px;
      background: rgba(2, 2, 10, 0.97);
      border: 1.5px solid rgba(255, 60, 60, 0.4);
      border-top: none;
      box-shadow: 0 8px 28px rgba(255, 0, 0, 0.2), inset 0 -1px 0 rgba(255, 50, 50, 0.1);
    }

    #boss-hud-name {
      font-size: clamp(7px, 2vw, 11px);
      color: #ff9999;
      letter-spacing: 3px;
      text-align: center;
      text-shadow: 0 0 12px rgba(255, 60, 60, 0.5);
    }

    #boss-hp-wrap {
      width: 100%;
      height: 14px;
      background: #100000;
      border: 1px solid rgba(255, 50, 50, 0.2);
      border-radius: 2px;
      overflow: hidden;
      position: relative;
    }

    #boss-hp-fill {
      height: 100%;
      background: linear-gradient(90deg, #bb0000, #ff4400, #ff8800);
      transition: width .15s;
      border-radius: 2px;
      box-shadow: inset 0 2px 0 rgba(255, 200, 200, 0.2), 0 0 8px rgba(255, 60, 0, 0.4);
    }

    #boss-hp-wrap::after {
      content: '';
      position: absolute;
      inset: 0;
      background: repeating-linear-gradient(90deg, transparent, transparent 24px, rgba(0, 0, 0, 0.25) 24px, rgba(0, 0, 0, 0.25) 25px);
    }

    #boss-phase-wrap {
      width: 100%;
      display: flex;
      justify-content: center;
      gap: 8px;
      margin-top: 2px;
    }

    .boss-phase-pip {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #160000;
      border: 1.5px solid rgba(255, 50, 50, 0.3);
    }

    .boss-phase-pip.active {
      background: #ff2222;
      box-shadow: 0 0 10px #ff2222, 0 0 20px rgba(255, 0, 0, 0.4);
    }

    /* ====== MINIMAP ====== */
    #minimap-wrap {
      position: fixed;
      top: 80px;
      right: 10px;
      z-index: 90;
      background: rgba(2, 2, 10, 0.96);
      border: 2px solid rgba(255, 215, 0, 0.55);
      box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.9), 0 6px 20px rgba(0, 0, 0, 0.8),
        0 0 16px rgba(255, 215, 0, 0.1), inset 0 0 10px rgba(0, 0, 0, 0.5);
    }

    #minimap-wrap::before {
      content: 'CARTE';
      position: absolute;
      top: -16px;
      left: 0;
      right: 0;
      text-align: center;
      font-size: 7px;
      color: rgba(255, 215, 0, 0.8);
      letter-spacing: 3px;
      text-shadow: 0 0 8px rgba(255, 215, 0, 0.4);
    }

    #mmc {
      display: block;
      width: 110px;
      height: 74px;
    }

    /* ====== DIALOG ====== */
    #dialog {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      z-index: 200;
      display: none;
      background: linear-gradient(0deg, rgba(5, 5, 15, 0.99) 0%, rgba(8, 8, 25, 0.96) 100%);
      border-top: 2px solid #ffd70066;
      box-shadow: 0 -10px 40px rgba(0, 0, 0, 0.9);
    }

    .dlg-inner {
      display: grid;
      grid-template-columns: 64px 1fr;
      min-height: 80px;
      padding: 10px 14px 10px 0;
    }

    .dlg-portrait-wrap {
      display: flex;
      align-items: flex-start;
      justify-content: center;
    }

    .dlg-portrait-box {
      width: 50px;
      height: 50px;
      background: linear-gradient(135deg, #0d0d1a, #1a1a35);
      border: 2px solid #ffd70066;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      flex-shrink: 0;
    }

    .dlg-body {
      padding-left: 10px;
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .dlg-name {
      font-size: clamp(5px, 1.5vw, 7px);
      color: #ffd700;
      letter-spacing: 2px;
      border-bottom: 1px solid #ffd70022;
      padding-bottom: 3px;
      margin-bottom: 2px;
    }

    #dlg-text {
      font-family: 'VT323', monospace;
      font-size: clamp(16px, 4vw, 21px);
      color: #e8e0c0;
      line-height: 1.5;
      min-height: 40px;
    }

    .dlg-actions {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-top: 4px;
    }

    .dlg-continue {
      font-size: 7px;
      color: #ffd70088;
      animation: blinkAnim 0.8s step-end infinite;
    }

    .dlg-btn {
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(5px, 1.4vw, 7px);
      background: linear-gradient(180deg, #8b5e00, #4a3000);
      color: #ffd700;
      border: none;
      padding: 7px 14px;
      cursor: pointer;
      box-shadow: 0 0 0 1px #ffd70055, 2px 2px 0 #000;
      pointer-events: all;
    }

    .dlg-btn:active {
      transform: translate(1px, 1px);
    }

    /* ====== DEATH SCREEN ====== */
    #deathscreen {
      position: fixed;
      inset: 0;
      z-index: 270;
      display: none;
      background: rgba(80, 0, 0, 0.97);
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 16px;
    }

    .death-icon {
      font-size: 70px;
      animation: deathPulse 1.5s ease-in-out infinite;
    }

    .death-title {
      font-size: clamp(14px, 3.5vw, 28px);
      color: #ff4444;
      text-align: center;
      text-shadow: 3px 3px 0 #600, 0 0 40px #ff0000;
      line-height: 1.8;
    }

    .death-msg {
      font-family: 'VT323', monospace;
      font-size: clamp(16px, 4vw, 26px);
      color: #ff9988;
      text-align: center;
      max-width: 420px;
      padding: 0 20px;
      line-height: 1.7;
    }

    .death-btn {
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(9px, 2vw, 12px);
      background: linear-gradient(180deg, #cc2020, #8b0000);
      color: #fff;
      border: none;
      padding: 13px 26px;
      cursor: pointer;
      box-shadow: 0 0 0 2px #ff4444, 0 0 0 4px #000, 4px 4px 0 #000;
    }

    .death-btn:active {
      transform: translate(3px, 3px);
    }

    @keyframes deathPulse {

      0%,
      100% {
        transform: scale(1);
      }

      50% {
        transform: scale(1.12);
      }
    }

    /* ====== LEVEL TRANSITION ====== */
    #leveltrans {
      position: fixed;
      inset: 0;
      z-index: 250;
      display: none;
      background: rgba(0, 0, 0, 0.97);
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 14px;
    }

    .lt-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      text-align: center;
      padding: 0 20px;
    }

    .lt-icon {
      font-size: 56px;
      filter: drop-shadow(0 0 30px #ffd700);
    }

    .lt-title {
      font-size: clamp(11px, 3vw, 20px);
      color: #ffd700;
      text-shadow: 3px 3px 0 #8b5e00;
      line-height: 1.8;
    }

    .lt-zone {
      font-family: 'VT323', monospace;
      font-size: clamp(16px, 4vw, 26px);
      color: #e8d890;
    }

    .lt-reward {
      font-size: clamp(7px, 1.8vw, 10px);
      color: #88ccff;
      line-height: 2;
      background: rgba(0, 100, 200, 0.1);
      border: 1px solid #88ccff33;
      padding: 8px 16px;
    }

    .lt-next-btn {
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(8px, 2vw, 11px);
      background: linear-gradient(180deg, #c8a020, #8b5e00);
      color: #000;
      border: none;
      padding: 12px 24px;
      cursor: pointer;
      box-shadow: 0 0 0 2px #ffd700, 0 0 0 4px #000, 4px 4px 0 #000;
    }

    .lt-next-btn:active {
      transform: translate(3px, 3px);
    }

    /* ====== VICTORY ====== */
    #victory {
      position: fixed;
      inset: 0;
      z-index: 260;
      display: none;
      background: rgba(0, 0, 0, 0.97);
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
    }

    .vic-title {
      font-size: clamp(12px, 3.5vw, 24px);
      color: #ffd700;
      text-align: center;
      text-shadow: 3px 3px 0 #8b5e00;
      animation: logoPulse 2s infinite;
      line-height: 1.8;
    }

    .vic-msg {
      font-family: 'VT323', monospace;
      font-size: clamp(15px, 4vw, 26px);
      color: #e8d890;
      text-align: center;
      max-width: 500px;
      padding: 0 20px;
      line-height: 1.7;
    }

    .vic-btn {
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(8px, 2vw, 11px);
      background: linear-gradient(180deg, #c8a020, #8b5e00);
      color: #000;
      border: none;
      padding: 12px 22px;
      cursor: pointer;
      box-shadow: 0 0 0 2px #ffd700, 0 0 0 4px #000, 4px 4px 0 #000;
    }

    /* ====== PARTICLES ====== */
    .particle {
      position: fixed;
      pointer-events: none;
      z-index: 280;
      font-size: 20px;
      animation: particleFly var(--dur) ease-out forwards;
    }

    @keyframes particleFly {
      0% {
        opacity: 1;
        transform: translate(0, 0) scale(1) rotate(0deg);
      }

      100% {
        opacity: 0;
        transform: translate(var(--dx), var(--dy)) scale(0) rotate(var(--rot));
      }
    }

    /* ====== DAMAGE NUMBERS ====== */
    .dmg {
      position: fixed;
      pointer-events: none;
      z-index: 180;
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(8px, 2vw, 12px);
      animation: dmgAnim 0.85s ease-out forwards;
    }

    .dmg.heal {
      color: #44ff88;
      text-shadow: 0 0 8px #44ff88;
    }

    .dmg.crit {
      color: #ffff00;
      font-size: clamp(11px, 2.8vw, 17px);
      text-shadow: 0 0 12px #ffff00;
    }

    .dmg.normal {
      color: #ff4444;
      text-shadow: 0 0 8px #ff4444;
    }

    .dmg.ice {
      color: #88ccff;
      text-shadow: 0 0 8px #88ccff;
    }

    .dmg.fire {
      color: #ff8822;
      text-shadow: 0 0 8px #ff8822;
    }

    .dmg.spin {
      color: #cc44ff;
      text-shadow: 0 0 8px #cc44ff;
    }

    .dmg.boss {
      color: #ff0000;
      font-size: clamp(13px, 3.5vw, 20px);
      text-shadow: 0 0 15px #ff0000, 0 0 30px #ff000088;
    }

    @keyframes dmgAnim {
      0% {
        opacity: 1;
        transform: translateY(0) scale(1);
      }

      30% {
        opacity: 1;
        transform: translateY(-20px) scale(1.2);
      }

      100% {
        opacity: 0;
        transform: translateY(-65px) scale(0.6);
      }
    }

    /* ====== SCANLINES ====== */
    #scanlines {
      position: fixed;
      inset: 0;
      z-index: 500;
      pointer-events: none;
      background: repeating-linear-gradient(0deg, transparent, transparent 3px, rgba(0, 0, 0, 0.04) 3px, rgba(0, 0, 0, 0.04) 4px);
    }

    #atkflash {
      position: fixed;
      inset: 0;
      z-index: 170;
      pointer-events: none;
      opacity: 0;
      background: radial-gradient(ellipse at center, rgba(255, 255, 255, 0.25) 0%, transparent 70%);
      transition: opacity 0.1s;
    }

    /* ====== WARNING OVERLAY ====== */
    #warn-overlay {
      position: fixed;
      inset: 0;
      z-index: 165;
      pointer-events: none;
      opacity: 0;
      background: rgba(255, 0, 0, 0.08);
      border: 4px solid rgba(255, 0, 0, 0);
      transition: opacity 0.08s, border-color 0.08s;
    }

    /* ====== MOBILE CONTROLS ====== */
    /* Zone enti√®re ‚Äî fixe en bas, jamais superpos√©e au jeu */
    #mobilecontrols {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 180px;
      z-index: 96;
      pointer-events: none;
      display: none;
      background: linear-gradient(0deg, rgba(2, 2, 10, 0.26) 0%, rgba(2, 2, 10, 0.144) 65%, transparent 100%);
    }

    /* ‚îÄ‚îÄ JOYSTICK (moiti√© gauche) ‚îÄ‚îÄ */
    #joystick-col {
      position: absolute;
      left: 0;
      bottom: 0;
      width: 48%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: all;
    }

    #joystick-zone {
      width: 144px;
      height: 144px;
      position: relative;
      pointer-events: all;
    }

    #joystick-base {
      position: absolute;
      inset: 0;
      border-radius: 50%;
      background: rgba(255, 215, 0, 0.05);
      border: 2px solid rgba(255, 215, 0, 0.22);
      /* cercles concentriques d√©coratifs via box-shadow */
      box-shadow: inset 0 0 0 42px rgba(255, 215, 0, 0.03),
        inset 0 0 0 70px rgba(0, 0, 0, 0.1);
    }

    /* croix directionnelle subtile */
    #joystick-base::before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 50%;
      background:
        linear-gradient(rgba(255, 215, 0, 0.07) 0, rgba(255, 215, 0, 0.07) 100%) center/2px 70% no-repeat,
        linear-gradient(rgba(255, 215, 0, 0.07) 0, rgba(255, 215, 0, 0.07) 100%) center/70% 2px no-repeat;
    }

    #joystick-knob {
      position: absolute;
      width: 56px;
      height: 56px;
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: radial-gradient(circle at 38% 32%, rgba(255, 245, 150, 0.96), rgba(210, 140, 0, 0.88));
      border: 2.5px solid rgba(255, 215, 0, 1);
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.55), 0 4px 10px rgba(0, 0, 0, 0.7),
        inset 0 2px 5px rgba(255, 255, 200, 0.3);
    }

    /* ‚îÄ‚îÄ BARRE DE COMP√âTENCES (moiti√© droite) ‚îÄ‚îÄ */
    #skills-col {
      position: absolute;
      right: 0;
      bottom: 0;
      width: 52%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: all;
    }

    /* Disposition : 1 grand bouton ATK central + 3 skills en arc */
    #skills-layout {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding-bottom: 8px;
    }

    /* ‚îÄ Rang√©e haute : 3 skills ‚îÄ */
    #skills-top {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    /* ‚îÄ Rang√©e basse : ESQUIVE + (espace) + CHARGE ‚îÄ */
    #skills-bot {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    /* Bouton de skill g√©n√©rique */
    .sk {
      position: relative;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      background: rgba(10, 10, 26, 0.96);
      pointer-events: all;
      transition: transform 0.06s, filter 0.05s;
      -webkit-user-select: none;
      user-select: none;
      /* pas de font-size ici ‚Äî g√©r√© par .sk-ico */
    }

    .sk:active {
      transform: scale(0.82);
      filter: brightness(1.4);
    }

    .sk.cd {
      opacity: 0.45;
    }

    .sk-ico {
      font-size: 22px;
      line-height: 1;
      display: block;
      pointer-events: none;
      margin-bottom: 1px;
    }

    .sk-lbl {
      font-family: 'VT323', monospace;
      font-size: 10px;
      line-height: 1;
      pointer-events: none;
      letter-spacing: 0.3px;
    }

    /* Tailles */
    .sk.sm {
      width: 58px;
      height: 58px;
      border: 2px solid rgba(255, 215, 0, 0.3);
    }

    .sk.md {
      width: 64px;
      height: 64px;
      border: 2px solid rgba(255, 215, 0, 0.3);
    }

    /* Couleurs */
    #bsk-spin {
      border-color: rgba(180, 70, 255, 0.6);
    }

    #bsk-spin .sk-lbl {
      color: rgba(210, 130, 255, 0.9);
    }

    #bsk-proj {
      border-color: rgba(60, 170, 255, 0.6);
    }

    #bsk-proj .sk-lbl {
      color: rgba(120, 200, 255, 0.9);
    }

    #bsk-charge {
      border-color: rgba(255, 110, 30, 0.6);
    }

    #bsk-charge .sk-lbl {
      color: rgba(255, 160, 80, 0.9);
    }

    #bsk-dash {
      border-color: rgba(0, 225, 175, 0.65);
    }

    #bsk-dash .sk-lbl {
      color: rgba(0, 225, 175, 0.95);
    }

    #bsk-dash .sk-ico {
      font-size: 20px;
    }

    /* Anneau de cooldown conic */
    .sk-ring {
      position: absolute;
      inset: -3px;
      border-radius: 50%;
      pointer-events: none;
      background: conic-gradient(rgba(0, 0, 0, 0) var(--p, 0%), rgba(0, 0, 0, 0.78) var(--p, 0%));
      display: none;
    }

    .sk-ring.on {
      display: block;
    }

    /* Dash invincible */
    #bsk-dash.inv {
      border-color: rgba(0, 255, 200, 1);
      background: rgba(0, 170, 130, 0.22);
      animation: invGlow 0.36s ease-in-out infinite alternate;
    }

    @keyframes invGlow {
      from {
        box-shadow: 0 0 12px rgba(0, 255, 200, 0.5);
      }

      to {
        box-shadow: 0 0 28px rgba(0, 255, 200, 1), 0 0 55px rgba(0, 255, 200, 0.3);
      }
    }

    /* Overlay invincible plein √©cran */
    #invincible-overlay {
      position: fixed;
      inset: 0;
      z-index: 164;
      pointer-events: none;
      opacity: 0;
      background: radial-gradient(ellipse at center, rgba(0, 255, 200, 0.09) 0%, transparent 65%);
      border: 3px solid transparent;
      transition: opacity 0.08s;
    }

    #invincible-overlay.active {
      opacity: 1;
      border-color: rgba(0, 255, 200, 0.4);
      animation: invBorder 0.25s step-end infinite;
    }

    @keyframes invBorder {
      50% {
        border-color: transparent;
      }
    }
  </style>
</head>

<body>
  <div id="scanlines"></div>
  <div id="atkflash"></div>
  <div id="warn-overlay"></div>

  <!-- TITLE -->
  <!-- ‚îÄ‚îÄ LOADING SCREEN ‚îÄ‚îÄ -->
  <div id="loadscreen" style="display:none;position:fixed;inset:0;z-index:400;background:radial-gradient(ellipse at 50% 60%,#0d1a0a 0%,#050a03 100%);flex-direction:column;align-items:center;justify-content:center;gap:24px;font-family:'Press Start 2P',monospace;">
    <div style="font-size:clamp(11px,3vw,20px);color:#ffd700;text-align:center;text-shadow:0 0 20px #ffd700aa,4px 4px 0 #8b5e00;animation:logoPulse 2s infinite;line-height:2">‚öîÔ∏è ANNIVERSAIRE PAPA ‚öîÔ∏è</div>
    <div style="font-size:clamp(14px,4vw,28px);color:#fff;opacity:0.6">üéµ</div>
    <div id="load-msg" style="font-family:'VT323',monospace;font-size:clamp(16px,4vw,22px);color:#e8d890;letter-spacing:2px;">Composition de la musique...</div>
    <div style="width:min(320px,80vw);height:12px;background:#050a03;border:2px solid #ffd70066;border-radius:2px;overflow:hidden;">
      <div id="load-bar-fill" style="height:100%;width:0%;background:linear-gradient(90deg,#8b5e00,#ffd700);transition:width 0.3s;border-radius:2px;box-shadow:0 0 8px #ffd70066;"></div>
    </div>
    <div style="font-size:clamp(5px,1.4vw,7px);color:#9a8a60;text-align:center;line-height:2">Synth√®se audio proc√©durale en cours...</div>
  </div>

  <div id="title">
    <canvas id="title-canvas"></canvas>
    <div class="title-content">
      <div class="title-sword">‚öîÔ∏è</div>
      <div class="title-logo">ANNIVERSAIRE<br>PAPA</div>
      <div class="title-tagline">‚Äî L√©gende du Royaume ‚Äî</div>
      <div class="title-features">
        5 niveaux √©piques ¬∑ 5 boss l√©gendaires ¬∑ Des patterns redoutables mais faisables !<br>
        De la For√™t des Souvenirs aux Cryptes Maudites, du Gouffre de l'Oubli au Sommet ultime...<br>
        Affrontez Thyrax, le Dragon Supr√™me, boss final aux attaques d√©vastateurs !<br>
        Bonne chance, H√©ros !
      </div>
      <button class="start-btn" onclick="startGame()">‚ñ∫ COMMENCER L'AVENTURE</button>
    </div>
  </div>

  <!-- GAME -->
  <div id="game"><canvas id="gc"></canvas></div>

  <!-- HUD -->
  <div id="hud" style="display:none">
    <div class="hud-inner">
      <div class="hud-block">
        <div class="hud-label">H√©ros</div>
        <div class="hud-val">üßô Papa</div>
        <div class="lvl-badge" id="hud-lvl">Niv. 1</div>
      </div>
      <div class="hud-block" style="align-items:center">
        <div class="hud-label">Vie</div>
        <div class="hearts-row" id="hearts"></div>
        <div class="xp-bar-wrap">
          <div class="xp-bar-fill" id="xpbar" style="width:0%"></div>
        </div>
      </div>
      <div class="hud-block" style="align-items:center">
        <div class="hud-label">Arme</div>
        <div class="weapon-badge" id="hud-weapon">‚öîÔ∏è √âp√©e</div>
      </div>
      <div class="hud-block" style="align-items:flex-end">
        <div class="hud-label" style="text-align:right">Qu√™te</div>
        <div class="hud-quest-text" id="hud-quest">Explore...</div>

      </div>

    </div>
  </div>

  <!-- BOSS HP BAR -->
  <div id="boss-hud">
    <div id="boss-hud-name">BOSS</div>
    <div id="boss-hp-wrap">
      <div id="boss-hp-fill" style="width:100%"></div>
    </div>
    <div id="boss-phase-wrap"></div>
  </div>

  <!-- MINIMAP -->
  <div id="minimap-wrap" style="display:none"><canvas id="mmc"></canvas></div>

  <div id="invincible-overlay"></div>

  <!-- MOBILE CONTROLS ‚Äî barre fixe en bas -->
  <div id="mobilecontrols">
    <!-- GAUCHE : Joystick directionnel -->
    <div id="joystick-col">
      <div id="joystick-zone">
        <div id="joystick-base"></div>
        <div id="joystick-knob"></div>
      </div>
    </div>

    <!-- DROITE : Barre de comp√©tences
       TOP :   üåÄ SPIN  |  üîÆ TIR  |  üõ°Ô∏è DASH
       BOT :   (vide)   |  üí• CHARG
  -->
    <div id="skills-col">
      <div id="skills-layout">
        <div id="skills-top">
          <button class="sk sm" id="bsk-spin">
            <span class="sk-ico">üåÄ</span><span class="sk-lbl">SPIN</span>
            <div class="sk-ring" id="ring-spin"></div>
          </button>
          <button class="sk sm" id="bsk-proj">
            <span class="sk-ico">üîÆ</span><span class="sk-lbl">TIR</span>
            <div class="sk-ring" id="ring-proj"></div>
          </button>
          <button class="sk sm" id="bsk-dash">
            <span class="sk-ico">üõ°Ô∏è</span><span class="sk-lbl">ESQUIVE</span>
            <div class="sk-ring" id="ring-dash"></div>
          </button>
        </div>
        <div id="skills-bot">
          <button class="sk md" id="bsk-charge">
            <span class="sk-ico">üí•</span><span class="sk-lbl">CHARGE</span>
            <div class="sk-ring" id="ring-charge"></div>
          </button>
        </div>

      </div>
    </div>
  </div>

  <!-- DIALOG -->
  <div id="dialog">
    <div class="dlg-inner">
      <div class="dlg-portrait-wrap">
        <div class="dlg-portrait-box" id="dlg-portrait">üßô</div>
      </div>
      <div class="dlg-body">
        <div class="dlg-name" id="dlg-name">???</div>
        <div id="dlg-text">...</div>
        <div class="dlg-actions">
          <div class="dlg-continue" id="dlg-cont">‚ñº Continuer</div>
          <button class="dlg-btn" id="dlg-btn" onclick="nextLine()" style="display:none">SUITE ‚ñ∂</button>
        </div>
      </div>
    </div>
  </div>

  <!-- DEATH SCREEN -->
  <div id="deathscreen">
    <div class="death-icon">üíÄ</div>
    <div class="death-title">GAME OVER</div>
    <div class="death-msg" id="death-msg">Le h√©ros est tomb√©...<br>Courage, on recommence !</div>
    <button class="death-btn" onclick="restartLevel()">‚Ü∫ RECOMMENCER</button>
  </div>

  <!-- LEVEL TRANSITION -->
  <div id="leveltrans">
    <div class="lt-content">
      <div class="lt-icon" id="lt-icon">üèÜ</div>
      <div class="lt-title" id="lt-title">NIVEAU ACCOMPLI !</div>
      <div class="lt-zone" id="lt-zone">‚Äî</div>
      <div class="lt-reward" id="lt-reward">R√©compense !</div>
      <button class="lt-next-btn" id="lt-btn" onclick="goNextLevel()">NIVEAU SUIVANT ‚ñ∫</button>
    </div>
  </div>

  <!-- VICTORY -->
  <div id="victory">
    <div style="font-size:clamp(50px,12vw,75px);filter:drop-shadow(0 0 30px #ffd700);animation:swordFloat 2s infinite">
      üåü</div>
    <div class="vic-title">QU√äTE ACCOMPLIE !<br>üéâ JOYEUX ANNIVERSAIRE ! üéâ</div>
    <div class="vic-msg">Papa,<br><br>
      Tu as travers√© la For√™t des Souvenirs,<br>
      Le Ch√¢teau des √âpreuves,<br>
      Les Cryptes Maudites,<br>
      Le Gouffre de l'Oubli,<br>
      Et le Sommet de la Sagesse.<br><br>
      Comme dans la vie ‚Äî jamais tu n'as l√¢ch√©. ‚ù§Ô∏è<br><br>
      On t'aime. Merci d'√™tre notre h√©ros. üèÜ</div>
    <button class="vic-btn" onclick="fireworks()">üéÜ C√âL√âBRER !</button>
  </div>

  <script>
    'use strict';
    // ============================================================
    // AUDIO
    // ============================================================
    let actx;
    function ac() { if (!actx) actx = new (window.AudioContext || window.webkitAudioContext)(); if (actx.state === 'suspended') actx.resume(); return actx; }
    function note(f, d, tp = 'square', v = 0.07, dl = 0) {
      try {
        const c = ac(), o = c.createOscillator(), g = c.createGain();
        o.connect(g); g.connect(c.destination); o.type = tp; o.frequency.value = f;
        g.gain.setValueAtTime(0, c.currentTime + dl);
        g.gain.linearRampToValueAtTime(v, c.currentTime + dl + 0.01);
        g.gain.linearRampToValueAtTime(0, c.currentTime + dl + d);
        o.start(c.currentTime + dl); o.stop(c.currentTime + dl + d + 0.1);
      } catch (e) { }
    }
    function seq(ns) { let t = 0; ns.forEach(([f, d]) => { if (f > 0) note(f, d * .85, 'square', 0.065, t); t += d; }); }
    function sHit() { note(180, 0.07, 'sawtooth', 0.09); }
    function sSwing() { note(440, 0.05, 'square', 0.07); note(330, 0.05, 'square', 0.04, 0.06); }
    function sDie() { seq([[220, 0.1], [165, 0.1], [110, 0.2]]); }
    function sPick() { seq([[784, 0.07], [1047, 0.10], [1319, 0.16]]); }
    function sLvlUp() { seq([[523, 0.09], [659, 0.09], [784, 0.09], [1047, 0.20], [1319, 0.32]]); }
    function sBeep() { if (Math.random() < 0.35) note(880, 0.022, 'square', 0.018); }
    function sWalk() { if (Math.random() < 0.15) note(165 + Math.random() * 20, 0.03, 'square', 0.014); }
    function sDmg() { note(85, 0.14, 'sawtooth', 0.14); }
    function sSpin() { note(600, 0.04, 'sawtooth', 0.07); note(500, 0.04, 'sawtooth', 0.055, 0.055); note(400, 0.09, 'sawtooth', 0.045, 0.11); }
    function sProj() { note(800, 0.04, 'square', 0.07); note(1000, 0.09, 'square', 0.055, 0.04); }
    function sCharge() { note(200, 0.04, 'sawtooth', 0.09); note(300, 0.04, 'sawtooth', 0.09, 0.04); note(500, 0.18, 'sawtooth', 0.11, 0.09); }
    function sDeath() { seq([[200, 0.15], [160, 0.15], [120, 0.2], [80, 0.4]]); }
    function sVic() { seq([[523, 0.14], [523, 0.14], [523, 0.14], [415, 0.09], [523, 0.38], [784, 0.14], [784, 0.14], [784, 0.14], [698, 0.09], [784, 0.38], [1047, 0.09], [988, 0.09], [932, 0.09], [880, 0.09], [1047, 0.48]]); }
    function sBossDash() { note(1200, 0.06, 'sawtooth', 0.18); note(200, 0.12, 'sawtooth', 0.2, 0.04); }
    function sBossBeam() { note(300, 0.05, 'sawtooth', 0.15); note(400, 0.05, 'sawtooth', 0.12, 0.05); note(1800, 0.4, 'sine', 0.07, 0.08); }
    function sBossWave() { note(100, 0.2, 'sawtooth', 0.18); note(150, 0.2, 'sawtooth', 0.15, 0.1); }
    function sBossSpawn() { seq([[440, 0.08], [350, 0.08], [280, 0.08], [200, 0.15]]); }
    function sBossRage() { note(80, 0.3, 'sawtooth', 0.25); note(120, 0.3, 'sawtooth', 0.2, 0.15); note(60, 0.5, 'sawtooth', 0.28, 0.3); }

    // ============================================================
    // CANVAS
    // ============================================================
    const canvas = document.getElementById('gc');
    const C = canvas.getContext('2d');
    const mm = document.getElementById('mmc');
    const MC = mm.getContext('2d');
    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; mm.width = 110; mm.height = 74; }
    window.addEventListener('resize', resize); resize();
    const tc = document.getElementById('title-canvas');
    const TC = tc.getContext('2d');
    function resizeTitle() { tc.width = window.innerWidth; tc.height = window.innerHeight; }
    window.addEventListener('resize', resizeTitle); resizeTitle();

    // ============================================================
    // NOISE
    // ============================================================
    function smoothNoise(x, y) {
      const ix = Math.floor(x), iy = Math.floor(y);
      const fx = x - ix, fy = y - iy;
      const u = fx * fx * (3 - 2 * fx), v = fy * fy * (3 - 2 * fy);
      const h = (a, b) => Math.abs(Math.sin(a * 127.1 + b * 311.7) * 43758.5453) % 1;
      return h(ix, iy) * (1 - u) * (1 - v) + h(ix + 1, iy) * u * (1 - v) + h(ix, iy + 1) * (1 - u) * v + h(ix + 1, iy + 1) * u * v;
    }
    function fbm(x, y, oct = 4) {
      let v = 0, amp = 1, freq = 1, max = 0;
      for (let i = 0; i < oct; i++) { v += smoothNoise(x * freq, y * freq) * amp; max += amp; amp *= 0.5; freq *= 2; }
      return v / max;
    }

    // ============================================================
    // TILES
    // ============================================================
    const TSIZ = 32;
    const tileCache = new Map();
    const TB = {
      GRASS: 0, PATH: 1, WATER: 2, ROCK: 3, TREE: 4, FLOWER: 5, MUSHROOM: 6,
      FLOOR: 7, WALL: 8, SNOW: 9, ICE: 10, LAVA: 11, DARK: 12, BRIDGE: 13, TALL_GRASS: 14,
      HILL: 15, SAND: 16, MOSS: 17
    };
    const BLOCK = { 2: true, 3: true, 4: true, 8: true, 11: true, 12: true };
    const PASSABLE = t => !BLOCK[t];
    function buildTile(id, frame = 0) {
      const key = `${id}_${frame % 4}`;
      if (tileCache.has(key)) return tileCache.get(key);
      const off = new OffscreenCanvas(TSIZ, TSIZ);
      drawTileTexture(off.getContext('2d'), id, frame);
      tileCache.set(key, off); return off;
    }
    function rand(a, b, c) { return Math.abs(Math.sin(a + b * 127.1 + c * 311.7) * 43758.5453) % 1; }
    function drawTileTexture(cx, id, f) {
      cx.clearRect(0, 0, TSIZ, TSIZ); const T = TSIZ;
      switch (id) {
        case TB.GRASS: { cx.fillStyle = '#2a7a2a'; cx.fillRect(0, 0, T, T);['#2e8834', '#267326', '#1e7025', '#338a33', '#3a9a3a'].forEach((c, i) => { cx.fillStyle = c; cx.fillRect(rand(i * 7, f, i) * T | 0, rand(i * 11, f, i) * T | 0, 3 + (i % 2), 2 + (i % 2)); }); cx.strokeStyle = '#4ab04a'; cx.lineWidth = 1; for (let i = 0; i < 7; i++) { const x = rand(i * 17, f, i) * T, y = rand(i * 23, f, i) * T; cx.beginPath(); cx.moveTo(x, y + 3); cx.lineTo(x + Math.sin(f * 0.08) * 1.5, y - 3); cx.stroke(); } break; }
        case TB.PATH: { cx.fillStyle = '#a07830'; cx.fillRect(0, 0, T, T);['#b08040', '#906820', '#c09040', '#8a6018'].forEach((c, i) => { cx.fillStyle = c; cx.fillRect(rand(i * 3, f, 1) * T | 0, rand(i * 7, 2, i) * T | 0, 2 + (i % 3), 2 + (i % 2)); }); break; }
        case TB.WATER: { cx.fillStyle = '#0d3a6e'; cx.fillRect(0, 0, T, T); for (let w = 0; w < 4; w++) { const y = 4 + w * 7 + Math.sin(f * 0.05 + w * 1.2) * 2; cx.fillStyle = `rgba(80,160,255,${0.12 + w * 0.06})`; cx.beginPath(); cx.moveTo(0, y); for (let x = 0; x <= T; x += 3)cx.lineTo(x, y + Math.sin((x + f * 2) * 0.3 + w) * 2.5); cx.lineTo(T, y + 8); cx.lineTo(0, y + 8); cx.closePath(); cx.fill(); } break; }
        case TB.ROCK: { cx.fillStyle = '#4a4a55'; cx.fillRect(0, 0, T, T); cx.fillStyle = '#6a6a78'; cx.fillRect(3, 3, 26, 23); cx.fillStyle = '#7a7a88'; cx.fillRect(5, 5, 14, 12); cx.fillStyle = 'rgba(255,255,255,0.14)'; cx.fillRect(5, 5, 8, 3); break; }
        case TB.TREE: { cx.fillStyle = '#12280e'; cx.fillRect(0, 0, T, T); cx.fillStyle = '#1a4015'; cx.fillRect(4, 3, 24, 22); cx.fillStyle = '#257830'; cx.fillRect(7, 5, 18, 16); cx.fillStyle = '#4a2e10'; cx.fillRect(13, 21, 6, 11); break; }
        case TB.FLOWER: { cx.fillStyle = '#2a7a2a'; cx.fillRect(0, 0, T, T); const fp = [[7, 22], [19, 17], [14, 27], [25, 21]]; fp.forEach(([x, y], i) => { cx.fillStyle = ['#ff6688', '#ffcc44', '#ff88aa', '#cc66ff'][i]; for (let p2 = 0; p2 < 5; p2++) { const a = p2 / 5 * 6.28; cx.beginPath(); cx.arc(x + Math.cos(a) * 2.5, y - 8 + Math.sin(a) * 2.5, 2, 0, 6.28); cx.fill(); } }); break; }
        case TB.MUSHROOM: { cx.fillStyle = '#1e5a2a'; cx.fillRect(0, 0, T, T);[[8, 25], [20, 21], [26, 27]].forEach(([x, y]) => { cx.fillStyle = '#bb3333'; cx.beginPath(); cx.arc(x, y - 5, 5, Math.PI, 0); cx.fill(); cx.fillStyle = '#e8d0b0'; cx.fillRect(x - 2, y - 5, 4, 6); }); break; }
        case TB.FLOOR: { cx.fillStyle = '#252440'; cx.fillRect(0, 0, T, T); const g2 = T / 2; cx.fillStyle = '#2e2d50'; cx.fillRect(0, 0, g2 - 1, g2 - 1); cx.fillRect(g2 + 1, g2 + 1, g2 - 1, g2 - 1); cx.fillStyle = '#1e1d3a'; cx.fillRect(g2 + 1, 0, g2 - 1, g2 - 1); cx.fillRect(0, g2 + 1, g2 - 1, g2 - 1); cx.fillStyle = '#14132a'; cx.fillRect(0, g2, T, 2); cx.fillRect(g2, 0, 2, T); break; }
        case TB.WALL: { cx.fillStyle = '#16163a'; cx.fillRect(0, 0, T, T); cx.fillStyle = '#22224a'; cx.fillRect(2, 2, 12, 9); cx.fillRect(18, 2, 12, 9); cx.fillStyle = '#2a2a58'; cx.fillRect(10, 13, 16, 9); cx.fillRect(2, 22, 8, 8); cx.fillRect(22, 22, 8, 8); cx.fillStyle = '#0a0a20'; cx.fillRect(0, 0, T, 2); cx.fillRect(0, 11, T, 2); cx.fillRect(0, 22, T, 2); break; }
        case TB.SNOW: { cx.fillStyle = '#d0e8f8'; cx.fillRect(0, 0, T, T); for (let i = 0; i < 8; i++) { cx.fillStyle = i % 2 ? 'rgba(255,255,255,0.45)' : 'rgba(180,200,220,0.3)'; cx.fillRect(rand(i * 5, 1, f) * T | 0, rand(i * 11, f, 2) * T | 0, 4 + i % 3, 2 + i % 3); } break; }
        case TB.ICE: { cx.fillStyle = '#7aaac8'; cx.fillRect(0, 0, T, T); cx.fillStyle = 'rgba(220,240,255,0.42)'; cx.fillRect(2, 2, 22, 5); cx.fillRect(5, 11, 12, 3); cx.fillStyle = 'rgba(255,255,255,0.55)'; cx.fillRect(3, 3, 10, 2); break; }
        case TB.LAVA: { cx.fillStyle = '#380e00'; cx.fillRect(0, 0, T, T); for (let i = 0; i < 3; i++) { const y = 5 + i * 9 + Math.sin(f * 0.06 + i * 1.8) * 2.5; cx.fillStyle = `rgba(${175 - i * 28},${55 - i * 10},0,0.75)`; cx.beginPath(); cx.moveTo(0, y); for (let x = 0; x <= T; x += 3)cx.lineTo(x, y + Math.sin((x + f * 3) * 0.4 + i) * 3.5); cx.lineTo(T, y + 9); cx.lineTo(0, y + 9); cx.closePath(); cx.fill(); } break; }
        case TB.DARK: { cx.fillStyle = '#12121e'; cx.fillRect(0, 0, T, T); cx.fillStyle = 'rgba(35,30,65,0.55)'; cx.fillRect(3, 3, T - 6, T - 6); cx.fillStyle = 'rgba(50,40,80,0.15)'; cx.fillRect(1,1,T-2,2); cx.fillRect(1,1,2,T-2); break; }
        case TB.BRIDGE: { cx.fillStyle = '#0c3a6a'; cx.fillRect(0, 0, T, T);['#8b5e2a', '#a06830', '#7a5020', '#9a6828'].forEach((c, i) => { const y = 4 + i * 7; cx.fillStyle = c; cx.fillRect(1, y, T - 2, 6); }); break; }
        case TB.TALL_GRASS: { cx.fillStyle = '#2a7a2a'; cx.fillRect(0, 0, T, T); cx.strokeStyle = '#44b044'; cx.lineWidth = 1.5; for (let i = 0; i < 10; i++) { const x = 3 + i * 2.8, h = 9 + Math.sin(i * 2.3) * 3, sw = Math.sin(f * 0.04 + i * 0.7) * 2; cx.beginPath(); cx.moveTo(x, T - 2); cx.quadraticCurveTo(x + sw, T - h * 0.5, x + sw * 1.5, T - h); cx.stroke(); } break; }
        case TB.HILL: { cx.fillStyle = '#3a8c30'; cx.fillRect(0, 0, T, T); const hg = cx.createLinearGradient(0, 0, 0, T); hg.addColorStop(0, 'rgba(120,200,80,0.28)'); hg.addColorStop(1, 'rgba(0,0,0,0.22)'); cx.fillStyle = hg; cx.fillRect(0, 0, T, T); break; }
        case TB.SAND: { cx.fillStyle = '#c8a060'; cx.fillRect(0, 0, T, T);['#d4aa70', '#b89050', '#dcb878', '#c8a458'].forEach((c, i) => { cx.fillStyle = c; cx.fillRect(rand(i * 3, f, 1) * T | 0, rand(i * 7, 2, i) * T | 0, 2 + i % 3, 1 + i % 2); }); break; }
        case TB.MOSS: { cx.fillStyle = '#1e5a2a'; cx.fillRect(0, 0, T, T); for (let i = 0; i < 14; i++) { cx.fillStyle = i % 3 === 0 ? '#2a7a30' : i % 3 === 1 ? '#163820' : '#3a8a3a'; cx.beginPath(); cx.arc(rand(i * 5, f, i) * T, rand(i * 9, i, f) * T, 2 + rand(i, f, i) * 3, 0, 6.28); cx.fill(); } break; }
      }
    }
    const ANIM_TILES = [TB.WATER, TB.LAVA, TB.TALL_GRASS];
    let tileFrame = 0;
    setInterval(() => { tileFrame++; ANIM_TILES.forEach(id => { for (let f = 0; f < 4; f++)tileCache.delete(`${id}_${f}`); }); }, 120);

    // ============================================================
    // WORLD CONSTANTS
    // ============================================================
    const COLS = 80, ROWS = 60, WW = COLS * TSIZ, WH = ROWS * TSIZ;

    // ============================================================
    // LEVELS DATA
    // ============================================================
    const LEVELS = [{
      name: ["La For√™t des Souvenirs", "brrr...", "Un frisson vous traverse", "une pr√©sence sinistre du nord semble vous en vouloir..."], biome: "forest",
      quest: "Retrouve 3 M√©daillons", questCount: 3, questType: "collect", questItem: "ü•á",
      questMsgs: [
        ["ü•á", "M√âDAILLON", "Un m√©daillon en or... vous rappelant des moments pass√©s √† tes c√¥t√©s.", "Ces moments du quotidien ‚Äî les repas, les rires, les balades...", "Ce sont les tr√©sors les plus pr√©cieux.", "Vous r√©cup√©rez le m√©daillon"],
        ["ü•á", "M√âDAILLON", "Un... m√©daillon ?", " Il semble repr√©senter la patience.", "Elle est d√©sormais votre, une patience √† toutes √©preuves", "Peut √™tre au final, que vous l'avez toujours √©t√©", "Vous r√©cup√©rez le m√©daillon de sagesse"],
        ["ü•á", "M√âDAILLON", "Un m√©daillon brille d'or pur.", "Une vision vous assaillit.", "Une famille... aimante... est-ce la votre", "M√©daillon de Famille r√©cup√©r√© !"]
      ],
      bossName: "Vorgath le Br√ªl√©", bossIcon: "üëπ", bossHP: 40, bossPhases: 2,
      bossPatterns: ['slash', 'poison_ring', 'enrage'],
      bossDialog: ["Je suis le Vorgath le Br√ªl√© ! D√©voreur de souvenir !", "Je ne peux pas perdre la vie de cette fa√ßon !!!", "(Un cri strident retenti)", "BOSS VAINCU ! ‚öîÔ∏è √âp√©e de Vorgath d√©bloqu√©e !"],
      weapon: "‚öîÔ∏è √âp√©e de Vorgath le Br√ªl√©", wPow: 3,
      reward: "‚öîÔ∏è √âp√©e de Vorgath le Br√ªl√© ! +50 XP", rewardIcon: "‚öîÔ∏è", bgA: '#0d1f0d'
    }, {
      name: "Le Ch√¢teau des √âpreuves", biome: "castle",
      quest: "Vaincs 5 Gardiens", questCount: 5, questType: "kill", questItem: "üíÄ",
      questMsgs: [
        ["üíÄ", "GARDIEN VAINCU", "Un gardien vaincu. üìú 1/5"],
        ["üíÄ", "GARDIEN VAINCU", "Deux de moins ! üìú 2/5", "Est-ce la preuve d'une force infini ?"],
        ["üíÄ", "GARDIEN VAINCU", "La moiti√© du chemin. üìú 3/5", "ou peut-√™tre une pers√©v√©rance sans nom."],
        ["üíÄ", "GARDIEN VAINCU", "Presque l√† ! üìú 4/5", "..."],
        ["üíÄ", "TOUS VAINCUS !", "D√©sormais votre force n'a plus de doute.", "Un grincement se fait entendre... Vos sens sont en alerte", "Un nom apparait dans votre esprit", "Nytherion, le Revenant..."]
      ],
      bossName: "Nytherion, le Revenant", bossIcon: "üëë", bossHP: 60, bossPhases: 3,
      bossSpeed: 0.42, bossAggroR: 280, bossWarnR: 380,
      bossPatterns: ['teleport_strike', 'shadow_wave', 'death_beam', 'enrage'],
      bossDialog: ["Je suis Nytherion, le Revenant !", "Moi ? Vaincu par un simple voyageur...", "Toi... Qui ne doutes plus... D'OU SORT TU CETTE ASSURANCE ?!", "La lumi√®re fantomatique se tarit dans un sifflement l√©ger, et vous vous sentez plus l√©ger", "BOSS VAINCU ! üîÆ B√¢ton de Nytherion d√©bloqu√© !"],
      weapon: "üîÆ B√¢ton de Nytherion", wPow: 6,
      reward: "üîÆ B√¢ton de Nytherion ! +100 XP", rewardIcon: "üîÆ", bgA: '#0d0d22'
    }, {
      name: ["La Toile de l'Abomination", "Une puanteur de sang froid vous saisit...", "Des fils translucides scintillent dans l'obscurit√©."], biome: "webs",
      quest: "D√©truis 4 Cocons de Peur", questCount: 4, questType: "collect", questItem: "üï∏Ô∏è",
      questMsgs: [
        ["üï∏Ô∏è", "COCON BRIS√â", "Un cocon palpitant... quelque chose dedans n'est plus vivant.", "Vous le lac√©rez. Un fluide visqueux se r√©pand.", "1/4 cocons d√©truits. La toile frissonne."],
        ["üï∏Ô∏è", "COCON BRIS√â", "Le second cocon exhale une odeur de venin.", "Des yeux innombrables vous observent depuis les ombres.", "2/4 cocons d√©truits."],
        ["üï∏Ô∏è", "COCON BRIS√â", "Le troisi√®me cocon se d√©fait dans un crissement d'os.", "Un chuchotis : 'Plus personne ne sort de mes filets...'", "3/4 cocons d√©truits."],
        ["üï∏Ô∏è", "TOUS LES COCONS", "Le dernier cocon explose dans une gerbe de soie noire.", "Le sol vibre... les murs de la toile se contractent...", "Un nom s'inscrit en sang sur les fils :", "Arakhne, la Tisseuse Maudite..."]
      ],
      bossName: "Arakhne, la Tisseuse", bossIcon: "üï∑Ô∏è", bossHP: 80, bossPhases: 3,
      bossSpeed: 0.50, bossAggroR: 310, bossWarnR: 440,
      bossPatterns: ['web_snare', 'venom_burst', 'silk_storm', 'death_beam', 'brood_summon', 'enrage'],
      bossDialog: ["Je suis Arakhne, la Tisseuse ! Chaque √¢me finit dans mes filets !", "Comment... tu brises mes toiles comme si elles n'√©taient rien ?!", "Mon venin... s'√©puise... impossible pour un mortel...", "Toile d√©truite ! üï∑Ô∏è Crochets d'Arakhne d√©bloqu√©s !"],
      weapon: "üï∑Ô∏è Crochets d'Arakhne", wPow: 8,
      reward: "üï∑Ô∏è Crochets d'Arakhne ! +150 XP", rewardIcon: "üï∑Ô∏è", bgA: '#0d0512'
    }, {
      name: ["Le D√©sert de Cristal Fractur√©", "Le sol vibre sous vos pieds...", "Des cristaux g√©ants percent le ciel comme des lances."], biome: "crystal",
      quest: "Brise 5 Piliers de Cristal", questCount: 5, questType: "collect", questItem: "üíé",
      questMsgs: [
        ["üíé", "PILIER BRIS√â", "Le cristal explose en mille √©clats de lumi√®re aveuglante.", "Un son cristallin r√©sonne dans toute la plaine.", "1/5 piliers bris√©s."],
        ["üíé", "PILIER BRIS√â", "Le second cristal s'effondre dans un rugissement sourd.", "Des fissures apparaissent dans le sol alentour.", "2/5 piliers bris√©s."],
        ["üíé", "PILIER BRIS√â", "Le troisi√®me cristal lib√®re une √©nergie prismatique aveuglante.", "Vous sentez quelque chose de gigantesque s'√©veiller.", "3/5 piliers bris√©s."],
        ["üíé", "PILIER BRIS√â", "Le quatri√®me cristal se d√©sint√®gre en poussi√®re d'√©toiles.", "Le ciel au-dessus se fissure comme du verre.", "4/5 piliers bris√©s."],
        ["üíé", "TOUS LES PILIERS", "Le dernier pilier explose. La terre tremble violemment.", "Des millions d'√©clats de cristal volent en tous sens.", "Une forme titanesque √©merge des d√©combres :", "Zarveth, le Colosse Prismatique !"]
      ],
      bossName: "Zarveth, le Colosse Prismatique", bossIcon: "üíé", bossHP: 95, bossPhases: 3,
      bossSpeed: 0.40, bossAggroR: 330, bossWarnR: 480,
      bossPatterns: ['crystal_shard', 'prism_beam', 'quake_stomp', 'mirror_barrage', 'refraction_nova', 'enrage'],
      bossDialog: ["Je suis ZARVETH ! Ce d√©sert est mon tr√¥ne, ces cristaux ma chair !", "Tu casses ma carapace... mais ma lumi√®re est √©ternelle !", "Les... prismes... s'√©teignent... comment ?!", "D√©sert lib√©r√© ! üíé √âclat de Zarveth d√©bloqu√© !"],
      weapon: "üíé √âclat de Zarveth", wPow: 9,
      reward: "üíé √âclat de Zarveth ! +175 XP", rewardIcon: "üíé", bgA: '#030408'
    }, {
      name: "Le Sommet de la Sagesse", biome: "mountain",
      quest: ["Atteins l'√âtoile Finale, au sommet de la montagne", "Une pr√©sence pesante vous glace le sang..."], questCount: 1, questType: "collect", questItem: "‚≠ê",
      questMsgs: [["‚≠ê", "L'√âTOILE FINALE", "Vous l'avez donc trouv√©e... l'\"√âtoile\"", "Elle brille pour vous depuis les t√©n√®bres de l'univers.", "Vous sentez une √©nergie puissante vous envahir", "et une voix r√©sonne dans votre esprit :", "\"Tu as fait du chemin pour venir jusqu'ici... mais tu n'es pas encore arriv√©.\"", "Vous faites un voeu...", "Une ann√©e de combat, de pers√©v√©rance, de courage...", "L'√©toile vous octroie le fruit de votre d√©sir."]],
      bossName: "Thyrax SUPR√äME", bossIcon: "üêâ", bossHP: 160, bossPhases: 4,
      bossSpeed: 0.62, bossAggroR: 380, bossWarnR: 500,
      bossPatterns: ['fireball_burst', 'aerial_slam', 'time_stop', 'meteor', 'dash_slam', 'death_beam', 'void_spiral', 'chain_lightning', 'dark_nova', 'enrage'],
      bossDialog: ["Je suis THYRAX LE SUPR√äME ! Le temps lui-m√™me se plie √† ma volont√© !", "Impossible... aucun mortel n'a jamais...", "Ma flamme √©ternelle... elle vacille... QUI ES-TU ?!", "\"vous avez mis fin au r√®gne √©ternel de Thyrax le Supr√™me.\"", "üêâ DRAGON SUPR√äME VAINCU ! ‚≠ê √âtoile de Sagesse ! VICTOIRE ULTIME !"],
      weapon: "‚≠ê √âtoile de Sagesse", wPow: 12,
      reward: "‚≠ê √âtoile de Sagesse ! +300 XP", rewardIcon: "‚≠ê", bgA: '#050310'
    }];

    // ============================================================
    // MONSTERS
    // ============================================================
    const MONS = {
      forest: [{ icon: 'üê∫', name: 'Loup', hp: 4, maxHp: 4, spd: 1.1, dmg: 1, xp: 10, r: 13 },
      { icon: 'üï∑Ô∏è', name: 'Araign√©e', hp: 2, maxHp: 2, spd: 1.6, dmg: 1, xp: 8, r: 11 },
      { icon: 'ü¶á', name: 'Chauve-souris', hp: 2, maxHp: 2, spd: 2.0, dmg: 1, xp: 12, r: 11 },
      { icon: 'üåø', name: 'Entit√©', hp: 6, maxHp: 6, spd: 0.7, dmg: 2, xp: 15, r: 13 }],
      castle: [{ icon: 'üíÄ', name: 'Squelette', hp: 7, maxHp: 7, spd: 0.8, dmg: 2, xp: 20, r: 13 },
      { icon: 'üßü', name: 'Zombie', hp: 12, maxHp: 12, spd: 0.45, dmg: 2, xp: 28, r: 15 },
      { icon: 'üëª', name: 'Fant√¥me', hp: 4, maxHp: 4, spd: 2.2, dmg: 2, xp: 18, r: 11 },
      { icon: 'ü™ñ', name: 'Chevalier', hp: 10, maxHp: 10, spd: 1.0, dmg: 3, xp: 30, r: 14 }],
      mountain: [{ icon: 'üßä', name: 'G√©ant de Glace', hp: 16, maxHp: 16, spd: 0.38, dmg: 4, xp: 40, r: 17 },
      { icon: 'ü¶Ö', name: 'Griffon', hp: 8, maxHp: 8, spd: 1.6, dmg: 3, xp: 32, r: 13 },
      { icon: 'ü™®', name: 'Golem', hp: 20, maxHp: 20, spd: 0.28, dmg: 5, xp: 50, r: 18 },
      { icon: 'üå®Ô∏è', name: '√âl√©mental', hp: 11, maxHp: 11, spd: 1.3, dmg: 3, xp: 38, r: 13 }],
      webs: [{ icon: 'üï∑Ô∏è', name: 'Araign√©e V√©n√©neuse', hp: 10, maxHp: 10, spd: 1.8, dmg: 2, xp: 26, r: 12 },
      { icon: 'ü¶Ç', name: 'Scorpion G√©ant', hp: 14, maxHp: 14, spd: 1.2, dmg: 3, xp: 34, r: 14 },
      { icon: 'ü™≤', name: 'Col√©opt√®re Sombre', hp: 18, maxHp: 18, spd: 0.7, dmg: 4, xp: 38, r: 15 },
      { icon: 'ü¶ó', name: 'Chasseur Silencieux', hp: 8, maxHp: 8, spd: 2.8, dmg: 2, xp: 30, r: 11 }],
      crystal: [{ icon: 'üí†', name: '√âclat Vivant', hp: 12, maxHp: 12, spd: 1.4, dmg: 3, xp: 30, r: 12 },
      { icon: 'üî∑', name: 'Golem de Cristal', hp: 24, maxHp: 24, spd: 0.5, dmg: 5, xp: 58, r: 16 },
      { icon: '‚ú®', name: 'Lueur Prismatique', hp: 9, maxHp: 9, spd: 2.2, dmg: 2, xp: 32, r: 11 },
      { icon: 'üåÄ', name: 'Vortex de Verre', hp: 16, maxHp: 16, spd: 1.0, dmg: 4, xp: 46, r: 14 }]
    };

    // ============================================================
    // MAP GENERATION HELPERS
    // ============================================================
    function fillR(map, r0, c0, r1, c1, t) { for (let r = r0; r < r1; r++)for (let c = c0; c < c1; c++)if (r >= 0 && r < ROWS && c >= 0 && c < COLS) map[r][c] = t; }
    function fillE(map, cr, cc, rr, rc, t) { for (let r = Math.max(0, cr - rr); r <= Math.min(ROWS - 1, cr + rr); r++)for (let c = Math.max(0, cc - rc); c <= Math.min(COLS - 1, cc + rc); c++) { const dr = (r - cr) / rr, dc = (c - cc) / rc; if (dr * dr + dc * dc <= 1) map[r][c] = t; } }
    function carveLine(map, r0, c0, r1, c1, t) { const dr = Math.abs(r1 - r0), dc = Math.abs(c1 - c0); const sr = r0 < r1 ? 1 : -1, sc = c0 < c1 ? 1 : -1; let err = dr - dc, r = r0, c = c0; for (; ;) { if (r >= 0 && r < ROWS && c >= 0 && c < COLS) map[r][c] = t; if (r === r1 && c === c1) break; const e2 = 2 * err; if (e2 > -dc) { err -= dc; r += sr; } if (e2 < dr) { err += dr; c += sc; } } }
    function carveT(map, r0, c0, r1, c1, t, w = 1) { for (let dr = -w; dr <= w; dr++)for (let dc = -w; dc <= w; dc++)carveLine(map, r0 + dr, c0 + dc, r1 + dr, c1 + dc, t); }
    function ri(lo, hi) { return lo + Math.floor(Math.random() * (hi - lo + 1)); }
    function bfsPassable(map, startR, startC, limit = 2000) {
      const visited = new Set(); const queue = [[startR, startC]];
      const key = (r, c) => r * COLS + c; visited.add(key(startR, startC)); const cells = [];
      while (queue.length && cells.length < limit) {
        const [r, c] = queue.shift(); if (PASSABLE(map[r][c])) cells.push([r, c]);
        for (const [dr, dc] of [[-1, 0], [1, 0], [0, -1], [0, 1]]) {
          const nr = r + dr, nc = c + dc;
          if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) continue; const k = key(nr, nc);
          if (!visited.has(k) && PASSABLE(map[nr][nc])) { visited.add(k); queue.push([nr, nc]); }
        }
      }
      return cells;
    }
    function safeSpawnCell(cells, avoidX, avoidY, minDist = 80) {
      const far = cells.filter(([r, c]) => { const wx = c * TSIZ + TSIZ / 2, wy = r * TSIZ + TSIZ / 2; return Math.hypot(wx - avoidX, wy - avoidY) > minDist; });
      const pool = far.length > 0 ? far : cells; if (!pool.length) return null;
      const [r, c] = pool[Math.floor(Math.random() * pool.length)]; return { x: c * TSIZ + TSIZ / 2, y: r * TSIZ + TSIZ / 2 };
    }
    function ensurePassable(map, wx, wy) {
      const c0 = Math.floor(wx / TSIZ), r0 = Math.floor(wy / TSIZ);
      if (r0 >= 0 && r0 < ROWS && c0 >= 0 && c0 < COLS && PASSABLE(map[r0][c0])) return { x: wx, y: wy };
      for (let d = 1; d < 10; d++)for (let dr = -d; dr <= d; dr++)for (let dc = -d; dc <= d; dc++) {
        const r = r0 + dr, c = c0 + dc; if (r >= 0 && r < ROWS && c >= 0 && c < COLS && PASSABLE(map[r][c])) return { x: c * TSIZ + TSIZ / 2, y: r * TSIZ + TSIZ / 2 };
      }
      return { x: wx, y: wy };
    }
    function genMap(biome) {
      const seed = Math.random() * 1000;
      const base = biome === 'castle' ? TB.FLOOR : biome === 'mountain' ? TB.SNOW : biome === 'webs' ? TB.DARK : biome === 'crystal' ? TB.DARK : TB.GRASS;
      const wall = biome === 'castle' ? TB.WALL : biome === 'mountain' ? TB.ROCK : biome === 'webs' ? TB.WALL : biome === 'crystal' ? TB.ROCK : TB.TREE;
      const map = [];
      for (let r = 0; r < ROWS; r++) { map[r] = []; for (let c = 0; c < COLS; c++)map[r][c] = base; }
      fillR(map, 0, 0, 3, COLS, wall); fillR(map, ROWS - 3, 0, ROWS, COLS, wall);
      fillR(map, 0, 0, ROWS, 3, wall); fillR(map, 0, COLS - 3, ROWS, COLS, wall);
      let startPos, bossPos, questPos;
      if (biome === 'webs') {
        // Labyrinthe de toile : tout est DARK (mur), on creuse des chambres et tunnels larges
        fillR(map, 3, 3, ROWS - 3, COLS - 3, TB.DARK);

        // Chambres principales ‚Äî plus grandes, garantit de l'espace
        const chambers = [
          {r:50, c:40, rr:6, rc:8},   // entr√©e (bas centre)
          {r:38, c:20, rr:5, rc:7},   // gauche
          {r:38, c:58, rr:5, rc:7},   // droite
          {r:24, c:36, rr:6, rc:9},   // centre
          {r:10, c:20, rr:4, rc:6},   // boss G
          {r:10, c:55, rr:4, rc:6},   // boss D
          {r:14, c:37, rr:3, rc:5},   // salle boss centrale
        ];
        for (const ch of chambers) {
          fillE(map, ch.r, ch.c, ch.rr, ch.rc, TB.FLOOR);
          // Flaques venimeuses (d√©co, passable car non dans BLOCK)
          // On met juste du FLOOR partout dans les chambres
        }

        // Tunnels larges (w=2) reliant toutes les chambres
        carveT(map, 50, 40, 38, 20, TB.FLOOR, 2); // entr√©e -> G
        carveT(map, 50, 40, 38, 58, TB.FLOOR, 2); // entr√©e -> D
        carveT(map, 38, 20, 24, 36, TB.FLOOR, 2); // G -> centre
        carveT(map, 38, 58, 24, 36, TB.FLOOR, 2); // D -> centre
        carveT(map, 24, 36, 14, 37, TB.FLOOR, 2); // centre -> boss
        carveT(map, 14, 37, 10, 20, TB.FLOOR, 2); // boss -> salle boss G
        carveT(map, 14, 37, 10, 55, TB.FLOOR, 2); // boss -> salle boss D

        // Tunnels secondaires pour enrichir l'exploration
        carveT(map, 50, 40, 50, 62, TB.FLOOR, 2); // bras droit bas
        carveT(map, 50, 62, 36, 68, TB.FLOOR, 2);
        carveT(map, 36, 68, 24, 60, TB.FLOOR, 2);
        carveT(map, 24, 60, 14, 55, TB.FLOOR, 2);
        carveT(map, 50, 18, 36, 10, TB.FLOOR, 2); // bras gauche bas
        carveT(map, 36, 10, 24, 14, TB.FLOOR, 2);
        carveT(map, 24, 14, 10, 20, TB.FLOOR, 2);

        // Quelques alc√¥ves lat√©rales (salles secondaires)
        const alcoves = [{r:44,c:58,rr:3,rc:4},{r:44,c:20,rr:3,rc:4},{r:30,c:10,rr:3,rc:4},{r:30,c:68,rr:3,rc:4}];
        for (const a of alcoves) fillE(map, a.r, a.c, a.rr, a.rc, TB.FLOOR);

        // Quelques flaques de venin d√©co (TB.WATER = passable visuellement non bloquant)
        fillE(map, 50, 40, 2, 3, TB.WATER);
        fillE(map, 38, 20, 1, 2, TB.WATER);
        fillE(map, 38, 58, 1, 2, TB.WATER);
        fillE(map, 24, 36, 2, 3, TB.WATER);

        startPos = ensurePassable(map, 40 * TSIZ + TSIZ/2, 51 * TSIZ + TSIZ/2);
        bossPos  = ensurePassable(map, 37 * TSIZ + TSIZ/2, 14 * TSIZ + TSIZ/2);

        // BFS depuis la position de d√©part pour n'avoir que des cellules accessibles
        const cells = bfsPassable(map, 50, 40);
        questPos = [
          safeSpawnCell(cells, startPos.x, startPos.y, 220) || {x:20*TSIZ, y:38*TSIZ, collected:false},
          safeSpawnCell(cells, startPos.x, startPos.y, 180) || {x:58*TSIZ, y:38*TSIZ, collected:false},
          safeSpawnCell(cells, bossPos.x,  bossPos.y,  200) || {x:36*TSIZ, y:24*TSIZ, collected:false},
          safeSpawnCell(cells, bossPos.x,  bossPos.y,  160) || {x:55*TSIZ, y:10*TSIZ, collected:false},
        ].map(p => ({ ...p, collected: false }));
      } else if (biome === 'crystal') {
        // D√©sert de cristal : grande plaine ouverte avec structures g√©om√©triques r√©guli√®res
        fillR(map, 3, 3, ROWS - 3, COLS - 3, TB.FLOOR);
        // Piliers de cristal (roches) en grille d√©cal√©e
        const pillarPositions = [];
        for (let pr = 8; pr < ROWS - 8; pr += 10) {
          for (let pc = 8; pc < COLS - 8; pc += 12) {
            const jr = ri(-2, 2), jc = ri(-3, 3);
            const pr2 = pr + jr, pc2 = pc + jc;
            fillE(map, pr2, pc2, 2, 3, TB.ROCK);
            pillarPositions.push([pr2, pc2]);
          }
        }
        // Formations cristallines (patterns hexagonaux)
        const hexCenters = [[25, 20], [25, 58], [12, 38], [38, 15], [38, 60], [50, 35]];
        for (const [hr, hc] of hexCenters) {
          for (let angle = 0; angle < 6; angle++) {
            const a = angle * Math.PI / 3;
            const er = Math.round(hr + Math.sin(a) * 5), ec = Math.round(hc + Math.cos(a) * 6);
            fillE(map, Math.max(4, Math.min(ROWS-4, er)), Math.max(4, Math.min(COLS-4, ec)), 1, 2, TB.ICE);
          }
          fillE(map, hr, hc, 3, 4, TB.FLOOR); // centre accessible
        }
        // Foss√©s de fissures (lava/eau)
        for (let i = 0; i < 4; i++) {
          const fr = ri(15, 45), fc1 = ri(5, 20), fc2 = ri(55, 72);
          carveLine(map, fr, fc1, fr, fc2, TB.LAVA);
          carveLine(map, fr+1, fc1, fr+1, fc2, TB.LAVA);
        }
        // Chemins entre les formations
        carveT(map, ROWS - 5, 38, 50, 35, TB.FLOOR, 1);
        carveT(map, 50, 35, 38, 15, TB.FLOOR, 1);
        carveT(map, 50, 35, 38, 60, TB.FLOOR, 1);
        carveT(map, 38, 15, 25, 20, TB.FLOOR, 1);
        carveT(map, 38, 60, 25, 58, TB.FLOOR, 1);
        carveT(map, 25, 20, 12, 38, TB.FLOOR, 1);
        carveT(map, 25, 58, 12, 38, TB.FLOOR, 1);
        startPos = ensurePassable(map, 38 * TSIZ + TSIZ/2, (ROWS - 5) * TSIZ + TSIZ/2);
        bossPos = ensurePassable(map, 38 * TSIZ + TSIZ/2, 10 * TSIZ + TSIZ/2);
        const cells = bfsPassable(map, ROWS - 5, 38);
        questPos = [
          safeSpawnCell(cells, startPos.x, startPos.y, 200) || {x:20*TSIZ, y:38*TSIZ},
          safeSpawnCell(cells, startPos.x, startPos.y, 180) || {x:60*TSIZ, y:38*TSIZ},
          safeSpawnCell(cells, bossPos.x, bossPos.y, 200) || {x:25*TSIZ, y:25*TSIZ},
          safeSpawnCell(cells, bossPos.x, bossPos.y, 180) || {x:58*TSIZ, y:25*TSIZ},
          safeSpawnCell(cells, startPos.x, startPos.y, 250) || {x:38*TSIZ, y:20*TSIZ}
        ].map(p => ({ ...p, collected: false }));
      } else if (biome === 'forest') {
        for (let r = 3; r < ROWS - 3; r++)for (let c = 3; c < COLS - 3; c++) {
          const n = fbm(c * 0.08 + seed * 0.1, r * 0.08 + seed * 0.1), n2 = fbm(c * 0.15 + 50 + seed * 0.05, r * 0.15 + 50 + seed * 0.05), n3 = fbm(c * 0.05 + 100, r * 0.05 + 100);
          if (n > 0.63) map[r][c] = TB.TREE; else if (n > 0.56 && n2 > 0.55) map[r][c] = TB.MUSHROOM;
          else if (n < 0.35 && n2 < 0.4) map[r][c] = TB.MOSS; else if (n3 > 0.66 && n < 0.5) map[r][c] = TB.HILL;
          else if (n2 > 0.68 && n < 0.52) map[r][c] = TB.FLOWER; else if (n < 0.43 && n2 > 0.5 && n3 < 0.5) map[r][c] = TB.TALL_GRASS;
        }
        const lakeR = ri(28, 36), lakeC = ri(28, 50), lakeRR = ri(5, 8), lakeRC = ri(8, 14);
        fillE(map, lakeR, lakeC, lakeRR + 2, lakeRC + 2, TB.SAND); fillE(map, lakeR, lakeC, lakeRR, lakeRC, TB.WATER);
        const startC = ri(35, 45), startR = ROWS - 5;
        const mid1R = lakeR + lakeRR + 3, mid1C = lakeC, mid2R = lakeR - lakeRR - 3;
        const topR = 5, topC = ri(30, 50), bridgeC = lakeC + ri(-3, 3);
        carveT(map, startR, startC, mid1R, startC, TB.PATH, 1); carveT(map, mid1R, startC, mid1R, mid1C, TB.PATH, 1);
        for (let r = lakeR - lakeRR - 1; r <= lakeR + lakeRR + 1; r++)for (let dc = -1; dc <= 1; dc++) { const cc = bridgeC + dc; if (r >= 0 && r < ROWS && cc >= 0 && cc < COLS) map[r][cc] = map[r][cc] === TB.WATER ? TB.BRIDGE : TB.PATH; }
        carveT(map, mid1R, mid1C, lakeR + lakeRR + 1, bridgeC, TB.PATH, 1); carveT(map, lakeR - lakeRR - 1, bridgeC, mid2R, bridgeC, TB.PATH, 1);
        carveT(map, mid2R, bridgeC, topR, bridgeC, TB.PATH, 1); carveT(map, topR, bridgeC, topR, topC, TB.PATH, 1);
        startPos = ensurePassable(map, startC * TSIZ + TSIZ / 2, (startR - 1) * TSIZ + TSIZ / 2);
        bossPos = ensurePassable(map, topC * TSIZ + TSIZ / 2, (topR + 1) * TSIZ + TSIZ / 2);
        const cells = bfsPassable(map, startR - 1, startC);
        questPos = [safeSpawnCell(cells, startPos.x, startPos.y, 200) || { x: 18 * TSIZ, y: 40 * TSIZ },
        safeSpawnCell(cells, startPos.x, startPos.y, 150) || { x: 60 * TSIZ, y: 35 * TSIZ },
        safeSpawnCell(cells, bossPos.x, bossPos.y, 200) || { x: mid1C * TSIZ, y: mid2R * TSIZ }].map(p => ({ ...p, collected: false }));
      } else if (biome === 'castle') {
        fillR(map, 3, 3, ROWS - 3, COLS - 3, TB.FLOOR);
        fillR(map, 3, 3, 8, COLS - 3, TB.WALL); fillR(map, ROWS - 8, 3, ROWS - 3, COLS - 3, TB.WALL);
        fillR(map, 3, 3, ROWS - 3, 8, TB.WALL); fillR(map, 3, COLS - 8, ROWS - 3, COLS - 3, TB.WALL);
        const rms = [{ r0: 8, c0: 8, r1: 22, c1: 28 }, { r0: 8, c0: 32, r1: 22, c1: 52 }, { r0: 8, c0: 56, r1: 22, c1: 72 },
        { r0: 24, c0: 8, r1: 38, c1: 28 }, { r0: 24, c0: 32, r1: 38, c1: 52 }, { r0: 24, c0: 56, r1: 38, c1: 72 },
        { r0: 40, c0: 8, r1: 55, c1: 28 }, { r0: 40, c0: 32, r1: 55, c1: 52 }, { r0: 40, c0: 56, r1: 55, c1: 72 }];
        for (const rm of rms) { fillR(map, rm.r0, rm.c0, rm.r1, rm.c1, TB.WALL); fillR(map, rm.r0 + 2, rm.c0 + 2, rm.r1 - 2, rm.c1 - 2, TB.FLOOR); fillR(map, rm.r0 + 2, rm.c0 + 2, rm.r0 + 4, rm.c0 + 4, TB.DARK); }
        const cors = [{ r: 15, c0: 28, c1: 32 }, { r: 15, c0: 52, c1: 56 }, { r: 31, c0: 28, c1: 32 }, { r: 31, c0: 52, c1: 56 }, { r: 47, c0: 28, c1: 32 }, { r: 47, c0: 52, c1: 56 }];
        for (const co of cors) fillR(map, co.r - 1, co.c0, co.r + 2, co.c1, TB.FLOOR);
        const eC = 42;
        carveT(map, ROWS - 9, eC, 40, eC, TB.PATH, 1); carveT(map, 40, eC, 31, 42, TB.PATH, 1); carveT(map, 31, 42, 15, 42, TB.PATH, 1); carveT(map, 15, 42, 8, 42, TB.PATH, 1);
        carveT(map, 31, 28, 31, 18, TB.PATH, 0); carveT(map, 31, 52, 31, 64, TB.PATH, 0);
        startPos = ensurePassable(map, eC * TSIZ + TSIZ / 2, (ROWS - 5) * TSIZ + TSIZ / 2);
        bossPos = ensurePassable(map, eC * TSIZ + TSIZ / 2, 9 * TSIZ + TSIZ / 2);
        const cells = bfsPassable(map, ROWS - 5, eC);
        questPos = [safeSpawnCell(cells, startPos.x, startPos.y, 200) || { x: 18 * TSIZ, y: 47 * TSIZ },
        safeSpawnCell(cells, startPos.x, startPos.y, 150) || { x: 64 * TSIZ, y: 47 * TSIZ },
        safeSpawnCell(cells, bossPos.x, bossPos.y, 200) || { x: 18 * TSIZ, y: 15 * TSIZ }].map(p => ({ ...p, collected: false }));
      } else {
        fillR(map, 3, 3, ROWS - 3, COLS - 3, TB.SNOW);
        for (let r = 3; r < ROWS - 3; r++)for (let c = 3; c < COLS - 3; c++) {
          const n = fbm(c * 0.1 + seed * 0.08, r * 0.1 + seed * 0.08), n2 = fbm(c * 0.07 + 30 + seed * 0.05, r * 0.07 + 30 + seed * 0.05);
          if (n > 0.69) map[r][c] = TB.ROCK; else if (n > 0.61 && n2 < 0.45) map[r][c] = TB.HILL;
          else if (n < 0.32) map[r][c] = TB.ICE; else if (n2 > 0.71 && n < 0.55) map[r][c] = TB.LAVA;
        }
        const ridgeR = ri(24, 30), ridge2R = ri(10, 16), lw = ri(12, 16), rw = ri(62, 66);
        for (let c = 3; c < COLS - 3; c++) { const j = Math.round(Math.sin(c * 0.3 + seed) * 2), h = 3 + Math.round(Math.sin(c * 0.15) * 1); for (let r = ridgeR + j; r < ridgeR + j + h && r < ROWS - 3; r++)if (r > 3) map[r][c] = TB.ROCK; }
        for (let c = 3; c < COLS - 3; c++) { const j = Math.round(Math.cos(c * 0.25 + seed) * 2), h = 2 + Math.round(Math.sin(c * 0.2) * 1); for (let r = ridge2R + j; r < ridge2R + j + h && r < ROWS - 3; r++)if (r > 3) map[r][c] = TB.ROCK; }
        for (let r = 3; r < ROWS - 3; r++) { const j = Math.round(Math.sin(r * 0.2 + seed) * 2); for (let c = 3; c < lw + j && c < COLS - 3; c++)if (c > 3) map[r][c] = TB.ROCK; }
        for (let r = 3; r < ROWS - 3; r++) { const j = Math.round(Math.sin(r * 0.2 + seed + 5) * 2); for (let c = rw + j; c < COLS - 3; c++)if (c > 3) map[r][c] = TB.ROCK; }
        const glacR = ri(36, 44), glacC = ri(26, 52);
        fillE(map, glacR, glacC, ri(5, 8), ri(9, 14), TB.ICE); fillE(map, glacR, glacC, ri(2, 4), ri(4, 7), TB.WATER);
        for (let i = 0; i < 4; i++)fillE(map, ri(4, ridge2R - 2), ri(15, 65), ri(1, 3), ri(2, 5), TB.LAVA);
        const pass1C = ri(30, 50), pass2C = ri(28, 52);
        fillR(map, ridgeR - 1, pass1C - 2, ridgeR + 5, pass1C + 3, TB.SNOW); fillR(map, ridge2R - 1, pass2C - 2, ridge2R + 4, pass2C + 3, TB.SNOW);
        const startC = ri(35, 45), startR = ROWS - 5, bossR = 5, bossC = ri(30, 50);
        carveT(map, startR, startC, ridgeR, startC, TB.PATH, 1); carveT(map, ridgeR, startC, ridgeR, pass1C, TB.PATH, 1);
        carveT(map, ridgeR, pass1C, ridge2R, pass1C, TB.PATH, 1); carveT(map, ridge2R, pass1C, ridge2R, pass2C, TB.PATH, 1);
        carveT(map, ridge2R, pass2C, bossR, pass2C, TB.PATH, 1); carveT(map, bossR, pass2C, bossR, bossC, TB.PATH, 1);
        startPos = ensurePassable(map, startC * TSIZ + TSIZ / 2, (startR - 1) * TSIZ + TSIZ / 2);
        bossPos = ensurePassable(map, bossC * TSIZ + TSIZ / 2, (bossR + 1) * TSIZ + TSIZ / 2);
        const cells = bfsPassable(map, startR - 1, startC);
        questPos = [safeSpawnCell(cells, startPos.x, startPos.y, 200) || { x: (lw + 5) * TSIZ, y: ridgeR * TSIZ },
        safeSpawnCell(cells, startPos.x, startPos.y, 150) || { x: glacC * TSIZ, y: glacR * TSIZ },
        safeSpawnCell(cells, bossPos.x, bossPos.y, 200) || { x: pass2C * TSIZ, y: (ridge2R - 4) * TSIZ }].map(p => ({ ...p, collected: false }));
      }
      return { map, questPos, bossPos, startPos };
    }

    function genDecos(mapD, biome) {
      const d = [];
      const icons = {
        forest: ['üå≤', 'üåø', 'üçÑ', 'üå∏', 'üå∫', 'üíé', 'ü™®', 'üå≥', 'ü¶ã', 'üåæ', 'üçÉ'],
        castle: ['üíé', 'ü™¶', 'üï∏Ô∏è', '‚öîÔ∏è', 'üõ°Ô∏è', 'üß±'],
        mountain: ['üèîÔ∏è', '‚ùÑÔ∏è', 'ü¶Ö', 'ü™®', 'üíé', 'üåü', '‚õ∞Ô∏è', 'üßä', 'üå¨Ô∏è'],
        webs: ['üï∏Ô∏è', 'ü¶¥', 'üíÄ', 'ü©∏', 'üï∑Ô∏è', 'üåë'],
        crystal: ['üí†', 'üî∑', '‚ú®', 'üåü', 'üíé', 'üîµ', 'üåÄ']
      };
      const arr = icons[biome] || icons.forest;
      const { map } = mapD;
      for (let i = 0; i < 100; i++) {
        const c = Math.floor(Math.random() * COLS), r = Math.floor(Math.random() * ROWS);
        if (!map[r] || map[r][c] === undefined) continue;
        const t = map[r][c]; if (t === TB.PATH || BLOCK[t]) continue;
        if (Math.random() < 0.25) d.push({ x: c * TSIZ + TSIZ / 2, y: r * TSIZ + TSIZ / 2, icon: arr[Math.floor(Math.random() * arr.length)], off: Math.random() * Math.PI * 2, scale: 0.65 + Math.random() * 0.5 });
      }
      return d;
    }
    function genAmbient(biome) {
      const p = []; const count = biome === 'forest' ? 40 : biome === 'castle' ? 25 : biome === 'webs' ? 35 : biome === 'crystal' ? 45 : 30;
      const icons = biome === 'forest' ? ['firefly', 'leaf_fall'] : biome === 'castle' ? ['candle', 'spark'] : biome === 'webs' ? ['web_strand', 'web_spore'] : biome === 'crystal' ? ['ice_crystal', 'snowflake'] : ['snowflake', 'ice_crystal'];
      for (let i = 0; i < count; i++)p.push({ x: Math.random() * WW, y: Math.random() * WH, icon: icons[i % icons.length], spd: 0.3 + Math.random() * 0.5, off: Math.random() * Math.PI * 2, alpha: 0.2 + Math.random() * 0.35, sz: 8 + Math.random() * 8 });
      return p;
    }

    // ============================================================
    // GAME STATE
    // ============================================================
    let gRun = false, curLvl = 0, isDead = false;
    const SKILL_CD = [18, 75, 42, 110];
    const DASH_CD = 180; // 3 secondes √† 60fps
    const GS = {
      p: {
        x: 400, y: 300, vx: 0, vy: 0, hp: 5, maxHp: 5, xp: 0, lvl: 1, wPow: 1,
        weapon: '‚öîÔ∏è √âp√©e Rouill√©e', spd: 3.4, r: 12,
        atkCDs: [0, 0, 0, 0], atkAnim: 0, inv: 0, fx: 1, fy: 0,
        qItems: 0, qKills: 0, charging: false, chargeTime: 0,
        dashCD: 0, invincible: false, invincibleTimer: 0
      },
      cam: { x: 0, y: 0 }, map: null, mons: [], boss: null,
      decos: [], ambient: [], qItems: [],
      bossSpawned: false, bossDefeated: false,
      dlgActive: false, frame: 0, atks: [], shake: 0,
      lightPulse: 0, projectiles: [], spinAnim: null,
      bossProjectiles: [], bossWarnings: [],
      timeStop: false, timeStopTimer: 0,
      screenFlash: { r: 0, g: 0, b: 0, a: 0 }
    };

    // ============================================================
    // INPUT
    // ============================================================
    const K = {};
    document.addEventListener('keydown', e => {
      K[e.code] = true;
      if (['Space', 'KeyX'].includes(e.code)) { doAtk(0); e.preventDefault(); }
      if (e.code === 'KeyE') { doAtk(1); e.preventDefault(); }
      if (e.code === 'KeyR') { doAtk(2); e.preventDefault(); }
      if (e.code === 'KeyG' || e.code === 'ShiftLeft' || e.code === 'ShiftRight') { doDash(); e.preventDefault(); }
      if (e.code === 'KeyF') { if (!GS.p.charging) startCharge(); e.preventDefault(); }
      if (['Enter', 'Space'].includes(e.code) && GS.dlgActive) { nextLine(); e.preventDefault(); }
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) e.preventDefault();
    });
    document.addEventListener('keyup', e => { K[e.code] = false; if (e.code === 'KeyF' && GS.p.charging) releaseCharge(); });

    // ============================================================
    // MOBILE JOYSTICK
    // ============================================================
    const jZone = document.getElementById('joystick-zone');
    const jKnob = document.getElementById('joystick-knob');
    let joystickActive = false, jTouchId = null, jOriginX = 0, jOriginY = 0;
    const J_MAX = 48;
    function jStart(e) {
      e.preventDefault(); const t = e.changedTouches[0]; const rect = jZone.getBoundingClientRect();
      jTouchId = t.identifier; jOriginX = rect.left + rect.width / 2; jOriginY = rect.top + rect.height / 2; joystickActive = true; jMove(e);
    }
    function jMove(e) {
      e.preventDefault(); if (!joystickActive) return; let touch = null;
      for (let i = 0; i < e.changedTouches.length; i++)if (e.changedTouches[i].identifier === jTouchId) touch = e.changedTouches[i];
      if (!touch) return; let dx = touch.clientX - jOriginX, dy = touch.clientY - jOriginY;
      const d = Math.sqrt(dx * dx + dy * dy); if (d > J_MAX) { dx = dx / d * J_MAX; dy = dy / d * J_MAX; }
      jKnob.style.left = (72 + dx - 28) + 'px'; jKnob.style.top = (72 + dy - 28) + 'px';
      const mag = Math.sqrt(dx * dx + dy * dy);
      if (mag > 5) { GS.p.vx = dx / J_MAX; GS.p.vy = dy / J_MAX; GS.p.fx = dx / mag; GS.p.fy = dy / mag; } else { GS.p.vx = 0; GS.p.vy = 0; }
    }
    function jEnd(e) {
      e.preventDefault(); joystickActive = false; jTouchId = null;
      jKnob.style.left = '44px'; jKnob.style.top = '44px'; GS.p.vx = 0; GS.p.vy = 0;
    }
    jZone.addEventListener('touchstart', jStart, { passive: false });
    jZone.addEventListener('touchmove', jMove, { passive: false });
    jZone.addEventListener('touchend', jEnd, { passive: false });
    jZone.addEventListener('touchcancel', jEnd, { passive: false });

    // ‚îÄ‚îÄ‚îÄ Boutons skills mobiles ‚îÄ‚îÄ‚îÄ
    const skMap = [
      ['bsk-spin', () => doAtk(1)],
      ['bsk-proj', () => doAtk(2)],
      ['bsk-dash', () => doDash()],
      ['bsk-charge', 'charge'],
    ];
    for (const [id, action] of skMap) {
      const btn = document.getElementById(id);
      if (!btn) continue;
      if (action === 'charge') {
        btn.addEventListener('touchstart', (e) => { e.preventDefault(); startCharge(); }, { passive: false });
        btn.addEventListener('touchend', (e) => { e.preventDefault(); releaseCharge(); }, { passive: false });
      } else {
        btn.addEventListener('touchstart', (e) => { e.preventDefault(); action(); }, { passive: false });
      }
    }

    // ‚îÄ‚îÄ‚îÄ Canvas : 1 tap = attaque, double-tap = dash ‚îÄ‚îÄ‚îÄ
    let lastTap = 0;
    canvas.addEventListener('touchstart', (e) => {
      if (GS.dlgActive) { e.preventDefault(); nextLine(); return; }
      e.preventDefault();
      const now = Date.now();
      if (now - lastTap < 260) {
        doDash(); // double-tap
      } else {
        doAtk(0); // simple tap
      }
      lastTap = now;
    }, { passive: false });

    // ‚îÄ‚îÄ‚îÄ Clic souris (PC) : 1 clic = attaque, double-clic = dash ‚îÄ‚îÄ‚îÄ
    canvas.addEventListener('click', (e) => {
      if (!GS.dlgActive && !joystickActive) doAtk(0);
    });
    canvas.addEventListener('dblclick', (e) => {
      if (!GS.dlgActive) doDash();
    });

    // ============================================================
    // HELPERS
    // ============================================================
    function dst(a, b) { const dx = a.x - b.x, dy = a.y - b.y; return Math.sqrt(dx * dx + dy * dy); }
    function lerp(a, b, t) { return a + (b - a) * t; }
    function blk(wx, wy, map) { const c = Math.floor(wx / TSIZ), r = Math.floor(wy / TSIZ); if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return true; return !!BLOCK[map[r][c]]; }
    function dmgFx(wx, wy, val, cls) {
      const sx = wx - GS.cam.x, sy = wy - GS.cam.y;
      const d = document.createElement('div'); d.className = `dmg ${cls}`;
      d.textContent = (cls === 'heal' ? '+' : cls === 'crit' ? '‚òÖ' : '') + Math.abs(val);
      d.style.left = (sx + (Math.random() - 0.5) * 30) + 'px'; d.style.top = (sy - 30) + 'px';
      document.body.appendChild(d); setTimeout(() => d.remove(), 900);
    }
    function screenFlash(r, g, b, a, dur = 200) {
      const fl = document.getElementById('atkflash');
      fl.style.background = `radial-gradient(ellipse at center,rgba(${r},${g},${b},${a}) 0%,transparent 70%)`;
      fl.style.opacity = '1'; setTimeout(() => { fl.style.opacity = '0'; }, dur);
    }
    function warnFlash() {
      const w = document.getElementById('warn-overlay');
      w.style.opacity = '0.6'; w.style.borderColor = 'rgba(255,0,0,0.6)';
      setTimeout(() => { w.style.opacity = '0'; w.style.borderColor = 'transparent'; }, 150);
    }
    function hitMon(m, dmg, cls = 'normal') {
      if (m.state === 'dead' || m.state === 'dying') return;
      // Premier coup sur le boss = d√©but du combat
      if (m.boss && typeof BossMusic !== 'undefined' && !BossMusic.engaged) BossMusic.onCombatStart(curLvl);
      m.hp -= dmg; m.hitFlash = 8; m.state = 'chase';
      GS.shake = cls === 'crit' ? 10 : cls === 'boss' ? 4 : 3; sHit(); dmgFx(m.x, m.y, dmg, cls);
      if (m.hp <= 0) killMon(m);
    }
    function killMon(m) {
      m.state = 'dying'; m.dyingTimer = 22; sDie();
      GS.p.xp += m.xp;
      if (GS.p.xp >= GS.p.lvl * 100) { GS.p.lvl++; GS.p.xp = 0; GS.p.maxHp = Math.min(12, GS.p.maxHp + 1); GS.p.hp = GS.p.maxHp; sLvlUp(); dmgFx(GS.p.x, GS.p.y, GS.p.lvl, 'heal'); }
      updHUD();
      if (m.boss) {
        GS.bossDefeated = true;
        if (typeof BossMusic !== 'undefined') BossMusic.stop(2.0);
        document.getElementById('boss-hud').style.display = 'none';
        setTimeout(() => openDlg(m.icon, m.name, LEVELS[curLvl].bossDialog, () => showLT()), 600);
      } else if (LEVELS[curLvl].questType === 'kill') {
        GS.p.qKills++; updHUD();
        const lv = LEVELS[curLvl]; const mi = Math.min(GS.p.qKills - 1, lv.questMsgs.length - 1);
        const msg = lv.questMsgs[mi]; openDlg(msg[0], msg[1], msg.slice(2), null);
        if (GS.p.qKills >= lv.questCount && !GS.bossSpawned) spawnBoss();
      }
    }

    // ============================================================
    // PLAYER DAMAGE
    // ============================================================
    function damagePlayer(dmg, cls = 'normal') {
      const p = GS.p;
      // Invincibilit√© totale pendant le dash ‚Äî aucun d√©g√¢t
      if (p.invincible) return;
      if (p.inv > 0) return;
      // Premier d√©g√¢t boss sur le joueur = d√©but du combat
      if (GS.boss && GS.boss.state !== 'dead' && typeof BossMusic !== 'undefined' && !BossMusic.engaged) BossMusic.onCombatStart(curLvl);
      p.hp -= dmg; p.inv = 60; GS.shake = 6; sDmg();
      dmgFx(p.x, p.y, -dmg, cls); updHUD();
      warnFlash();
      if (p.hp <= 0) playerDie();
    }

    // ============================================================
    // DEATH / RESPAWN
    // ============================================================
    function playerDie() {
      if (isDead) return; isDead = true; gRun = false; sDeath(); GS.shake = 25;
      if (typeof BossMusic !== 'undefined') BossMusic.stop(0.8);
      screenFlash(200, 0, 0, 0.5, 600);
      document.getElementById('boss-hud').style.display = 'none';
      setTimeout(() => document.getElementById('deathscreen').style.display = 'flex', 900);
    }
    function restartLevel() {
      document.getElementById('deathscreen').style.display = 'none';
      isDead = false; gRun = true; loadLevel(curLvl);
    }

    // ============================================================
    // ATTACKS (PLAYER)
    // ============================================================
    function doAtk(type = 0) {
      if (GS.dlgActive || isDead) return;
      const p = GS.p; if (p.atkCDs[type] > 0) return;
      p.atkCDs[type] = SKILL_CD[type]; p.atkAnim = 14;
      if (type === 0) {
        sSwing(); GS.lightPulse = 10;
        screenFlash(255, 255, 255, 0.25, 60);
        const range = 55 + p.wPow * 5, angle = Math.atan2(p.fy, p.fx);
        GS.atks.push({ worldX: p.x + p.fx * 34, worldY: p.y + p.fy * 34, icon: '‚ú®', sz: 18, life: 10, maxLife: 10, vx: p.fx, vy: p.fy });
        const all = [...GS.mons]; if (GS.boss && GS.boss.state !== 'dead') all.push(GS.boss);
        for (const m of all) {
          if (m.state === 'dead' || m.state === 'dying') continue; if (dst(p, m) > range + m.r) continue;
          const ma = Math.atan2(m.y - p.y, m.x - p.x); let da = ma - angle;
          while (da > Math.PI) da -= Math.PI * 2; while (da < -Math.PI) da += Math.PI * 2;
          if (Math.abs(da) > 1.1) continue;
          const crit = Math.random() < 0.2;
          hitMon(m, Math.ceil(p.wPow * (crit ? 2.5 : 1) + (Math.random() < 0.3 ? 1 : 0)), crit ? 'crit' : 'normal');
        }
      } else if (type === 1) {
        sSpin(); GS.shake = 4; screenFlash(200, 100, 255, 0.3, 120);
        const range = 65 + p.wPow * 4;
        for (let i = 0; i < 8; i++) {
          const a = i / 8 * Math.PI * 2;
          GS.atks.push({ worldX: p.x + Math.cos(a) * range * 0.55, worldY: p.y + Math.sin(a) * range * 0.55, icon: 'üí•', sz: 19, life: 15, maxLife: 15, vx: Math.cos(a) * 0.4, vy: Math.sin(a) * 0.4 });
        }
        const all = [...GS.mons]; if (GS.boss && GS.boss.state !== 'dead') all.push(GS.boss);
        for (const m of all) {
          if (m.state === 'dead' || m.state === 'dying') continue; if (dst(p, m) > range + m.r) continue;
          hitMon(m, Math.ceil(p.wPow * 0.9 + (Math.random() < 0.25 ? 1 : 0)), 'spin');
        }
        GS.spinAnim = { timer: 24, maxTimer: 24 };
      } else if (type === 2) {
        sProj(); GS.lightPulse = 8;
        const icon = curLvl === 0 ? '‚ö°' : curLvl === 1 ? 'üîÆ' : '‚ùÑÔ∏è';
        GS.projectiles.push({ x: p.x + p.fx * 20, y: p.y + p.fy * 20, vx: p.fx * 6.2, vy: p.fy * 6.2, power: Math.ceil(p.wPow), icon, sz: 20, life: 85, r: 10, owner: 'player' });
        GS.atks.push({ worldX: p.x + p.fx * 20, worldY: p.y + p.fy * 20, icon, sz: 22, life: 8, maxLife: 8, vx: p.fx * 0.3, vy: p.fy * 0.3 });
      } else if (type === 3) {
        if (p.charging) releaseCharge(); else startCharge();
      }
      updSkillBar();
    }
    function startCharge() { if (GS.dlgActive || isDead) return; GS.p.charging = true; GS.p.chargeTime = 0; }
    function releaseCharge() {
      const p = GS.p; if (!p.charging) return; p.charging = false;
      if (p.atkCDs[3] > 0) { p.chargeTime = 0; return; }
      p.atkCDs[3] = SKILL_CD[3]; const charge = Math.min(1, p.chargeTime / 60); sCharge();
      screenFlash(255, 200, 50, 0.8, 180); GS.shake = 12 + charge * 8; GS.lightPulse = 24;
      const range = (74 + p.wPow * 6) * (1 + charge * 0.8), angle = Math.atan2(p.fy, p.fx);
      for (let i = 0; i < 6; i++) {
        const sp = (Math.random() - 0.5) * 1.8;
        GS.atks.push({ worldX: p.x + p.fx * range * 0.5, worldY: p.y + p.fy * range * 0.5, icon: 'üí´', sz: 30 + charge * 14, life: 22, maxLife: 22, vx: p.fx + sp, vy: p.fy + sp });
      }
      const all = [...GS.mons]; if (GS.boss && GS.boss.state !== 'dead') all.push(GS.boss);
      for (const m of all) {
        if (m.state === 'dead' || m.state === 'dying') continue; if (dst(p, m) > range + m.r) continue;
        const ma = Math.atan2(m.y - p.y, m.x - p.x); let da = ma - angle;
        while (da > Math.PI) da -= Math.PI * 2; while (da < -Math.PI) da += Math.PI * 2;
        if (Math.abs(da) > 1.4) continue;
        const dmg = Math.ceil(p.wPow * (1 + charge * 3.5));
        hitMon(m, dmg, 'crit');
        if (m.state !== 'dying') { const kd = Math.min(70, 100 / (dst(p, m) + 1)); m.x += (m.x - p.x) / (dst(p, m) + 1) * kd; m.y += (m.y - p.y) / (dst(p, m) + 1) * kd; }
      }
      p.chargeTime = 0; updSkillBar();
    }

    // ‚îÄ‚îÄ ESQUIVE / DASH ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const INVINCIBLE_DUR = 36; // ~0.6s √† 60fps
    function doDash() {
      if (GS.dlgActive || isDead) return;
      const p = GS.p; if (p.dashCD > 0) return;
      p.dashCD = DASH_CD;
      // Dash dans la direction du mouvement (ou vers l'avant si immobile)
      const dx = p.vx !== 0 || p.vy !== 0 ? p.vx : p.fx;
      const dy = p.vx !== 0 || p.vy !== 0 ? p.vy : p.fy;
      const mag = Math.sqrt(dx * dx + dy * dy) || 1;
      const nx = dx / mag, ny = dy / mag;
      // Propulser le joueur
      const dashDist = 80; const { map } = GS.map;
      let tx = p.x + nx * dashDist, ty = p.y + ny * dashDist;
      // Pas dans un mur
      if (blk(tx, p.y, map)) tx = p.x;
      if (blk(p.x, ty, map)) ty = p.y;
      p.x = tx; p.y = ty;
      // Invincibilit√©
      p.invincible = true; p.invincibleTimer = INVINCIBLE_DUR;
      p.inv = INVINCIBLE_DUR + 10; // immunit√© d√©g√¢ts normaux aussi
      // Effets visuels
      GS.shake = 3;
      screenFlash(0, 255, 200, 0.35, 180);
      // Train√©e
      for (let i = 0; i < 6; i++) {
        GS.atks.push({
          worldX: p.x - nx * i * 12, worldY: p.y - ny * i * 12,
          icon: 'üí®', sz: 18 - i * 2, life: 14 - i, maxLife: 14, vx: -nx * 0.5, vy: -ny * 0.5
        });
      }
      // Son
      try {
        const c = ac(), o = c.createOscillator(), g = c.createGain();
        o.connect(g); g.connect(c.destination); o.type = 'sine';
        o.frequency.setValueAtTime(800, c.currentTime); o.frequency.linearRampToValueAtTime(400, c.currentTime + 0.12);
        g.gain.setValueAtTime(0.12, c.currentTime); g.gain.linearRampToValueAtTime(0, c.currentTime + 0.14);
        o.start(); o.stop(c.currentTime + 0.16);
      } catch (e) { }
      updDashBtn();
    }
    function updSkillBar() {
      // Skill 1 = SPIN (atkCDs[1])
      _updSkRing('bsk-spin', 'ring-spin', GS.p.atkCDs[1], SKILL_CD[1]);
      // Skill 2 = PROJ (atkCDs[2])
      _updSkRing('bsk-proj', 'ring-proj', GS.p.atkCDs[2], SKILL_CD[2]);
      // Skill 3 = CHARGE (atkCDs[3])
      _updSkRing('bsk-charge', 'ring-charge', GS.p.atkCDs[3], SKILL_CD[3]);
      updDashBtn();
    }
    function _updSkRing(btnId, ringId, cd, max) {
      const btn = document.getElementById(btnId);
      const ring = document.getElementById(ringId);
      if (!btn || !ring) return;
      if (cd > 0) {
        const pct = ((max - cd) / max * 100);
        ring.style.setProperty('--p', pct + '%'); ring.classList.add('on'); btn.classList.add('cd');
      } else { ring.classList.remove('on'); btn.classList.remove('cd'); }
    }
    function updDashBtn() {
      const btn = document.getElementById('bsk-dash');
      const ring = document.getElementById('ring-dash');
      if (!btn || !ring) return;
      const p = GS.p;
      if (p.invincible) {
        btn.classList.add('inv'); btn.classList.remove('cd'); ring.classList.remove('on');
        document.getElementById('invincible-overlay').classList.add('active');
      } else {
        btn.classList.remove('inv');
        document.getElementById('invincible-overlay').classList.remove('active');
        if (p.dashCD > 0) {
          const pct = ((DASH_CD - p.dashCD) / DASH_CD * 100);
          ring.style.setProperty('--p', pct + '%'); ring.classList.add('on'); btn.classList.add('cd');
        } else { ring.classList.remove('on'); btn.classList.remove('cd'); }
      }
    }

    // ============================================================
    // BOSS SPAWN
    // ============================================================
    function spawnBoss() {
      if (GS.bossSpawned) return; GS.bossSpawned = true;
      const lv = LEVELS[curLvl]; const pos = GS.map.bossPos;
      GS.boss = {
        icon: lv.bossIcon, name: lv.bossName, hp: lv.bossHP, maxHp: lv.bossHP,
        spd: lv.bossSpeed || (0.55 + curLvl * 0.12), dmg: 2 + curLvl, x: pos.x, y: pos.y,
        state: 'idle', dyingTimer: 0, atkCD: 0,
        aggroR: lv.bossAggroR || 480, loseR: 700, warnR: lv.bossWarnR || null, wAngle: 0, wTimer: 0,
        hitFlash: 0, r: 24, boss: true, xp: 80 + curLvl * 40,
        // Boss-specific
        phase: 0, phaseTimer: 0, pattern: 0, patternTimer: 0,
        patterns: lv.bossPatterns || [],
        dashTarget: { x: pos.x, y: pos.y }, dashTimer: 0, dashActive: false,
        teleportCooldown: 0, rageMode: false,
        warningTimer: 0, beamAngle: 0, beamActive: false, beamTimer: 0,
        orbiting: false, orbitAngle: 0,
        timeStopActive: false,
        // Boss 2 warning
        warnZone: false, warnZoneTimer: 0, warnZoneAlerted: false,
        // Boss 3 aerial
        aerialActive: false, aerialTimer: 0, aerialTargetX: 0, aerialTargetY: 0
      };
      GS.bossSpawned = true;
      // Setup boss HP bar
      const bossHud = document.getElementById('boss-hud');
      bossHud.style.display = 'flex';
      document.getElementById('boss-hud-name').textContent = lv.bossName.toUpperCase();
      // Phase pips
      const pip = document.getElementById('boss-phase-wrap'); pip.innerHTML = '';
      const phases = lv.bossPhases || 2;
      for (let i = 0; i < phases; i++) { const d = document.createElement('div'); d.className = 'boss-phase-pip' + (i === 0 ? ' active' : ''); d.id = `bpip${i}`; pip.appendChild(d); }
      sBossSpawn();
      if (typeof BossMusic !== 'undefined') BossMusic.onSpawnBoss(curLvl);
      openDlg('‚ö†Ô∏è', 'DANGER !', [`üëπ ${lv.bossName} APPARA√éT !`, 'Attention ! Ce boss a des patterns d√©vastateurs !', 'Esquive et frappe au bon moment !'], null);
    }
    function updBossHPBar() {
      const b = GS.boss; if (!b) return;
      const pct = Math.max(0, b.hp / b.maxHp * 100);
      document.getElementById('boss-hp-fill').style.width = pct + '%';
      // Phase transitions
      const lv = LEVELS[curLvl]; const phases = lv.bossPhases || 2;
      const threshold = 1 / phases;
      const currentPhase = Math.floor((1 - b.hp / b.maxHp) / threshold);
      if (currentPhase !== b.phase && currentPhase < phases) {
        b.phase = currentPhase;
        // Light up phase pip
        for (let i = 0; i < phases; i++) { const pip = document.getElementById(`bpip${i}`); if (pip) pip.classList.toggle('active', i <= currentPhase); }
        // Rage at last phase
        if (currentPhase >= phases - 1) { b.rageMode = true; sBossRage(); screenFlash(255, 50, 0, 0.6, 500); GS.shake = 20; if (typeof BossMusic !== 'undefined') BossMusic.onRageMode(curLvl); }
      }
    }

    // ============================================================
    // BOSS AI ‚Äî Patterns
    // ============================================================
    function doBossPattern(b) {
      const p = GS.p; const lv = LEVELS[curLvl];
      if (!b.patterns || b.patterns.length === 0) return;
      if (b.patternTimer > 0) { b.patternTimer--; return; }
      // Pick next pattern
      const patterns = b.patterns;
      const patIdx = Math.floor(GS.frame / 200) % patterns.length;
      const pattern = patterns[patIdx + (b.rageMode ? 1 : 0) % patterns.length] || patterns[0];
      const cd = b.rageMode ? 140 : 200;
      b.patternTimer = cd;
      executeBossPattern(b, pattern, p);
    }

    function executeBossPattern(b, pattern, p) {
      switch (pattern) {
        // ---- PATTERN 1: Slash (melee dash toward player) ----
        case 'slash': {
          if (dst(b, p) < 200) {
            b.dashActive = true; b.dashTimer = 12;
            const ang = Math.atan2(p.y - b.y, p.x - b.x);
            b.dashVx = Math.cos(ang) * 10; b.dashVy = Math.sin(ang) * 10;
            // Warning indicator
            GS.bossWarnings.push({ x: p.x, y: p.y, r: 60, life: 25, maxLife: 25, type: 'circle', color: '#ff4400' });
            sBossDash();
          }
          break;
        }
        // ---- PATTERN 2: Poison ring ----
        case 'poison_ring': {
          for (let i = 0; i < 8; i++) {
            const ang = i / 8 * Math.PI * 2;
            GS.bossProjectiles.push({ x: b.x, y: b.y, vx: Math.cos(ang) * 2.2, vy: Math.sin(ang) * 2.2, icon: '‚ò†Ô∏è', sz: 18, life: 100, r: 12, dmg: 2, cls: 'spin' });
          }
          GS.bossWarnings.push({ x: b.x, y: b.y, r: 80, life: 20, maxLife: 20, type: 'ring', color: '#44ff44' });
          screenFlash(0, 200, 0, 0.25, 200); sBossWave();
          break;
        }
        // ---- PATTERN 3: Teleport strike ----
        case 'teleport_strike': {
          if (b.teleportCooldown <= 0) {
            // Teleport near player
            const ang = Math.random() * Math.PI * 2; const dist = 80 + Math.random() * 60;
            const nx = p.x + Math.cos(ang) * dist, ny = p.y + Math.sin(ang) * dist;
            // Safety check
            if (!blk(nx, ny, GS.map.map)) {
              // Warning first
              GS.bossWarnings.push({ x: nx, y: ny, r: 50, life: 30, maxLife: 30, type: 'circle', color: '#cc00ff' });
              setTimeout(() => {
                if (b.state === 'dead' || b.state === 'dying') return;
                b.x = nx; b.y = ny; b.hitFlash = 5;
                GS.atks.push({ worldX: b.x, worldY: b.y, icon: 'üåÄ', sz: 40, life: 18, maxLife: 18, vx: 0, vy: 0 });
                screenFlash(150, 0, 255, 0.4, 200); sBossDash();
                // Instant hit if still close
                if (dst(b, p) < 60) damagePlayer(3, 'spin');
              }, 500);
              b.teleportCooldown = 180;
            }
          }
          break;
        }
        // ---- PATTERN 4: Shadow wave (row of projectiles) ----
        case 'shadow_wave': {
          const ang = Math.atan2(p.y - b.y, p.x - b.x);
          for (let i = -2; i <= 2; i++) {
            const a = ang + i * 0.25;
            setTimeout(() => {
              if (b.state === 'dead' || b.state === 'dying') return;
              GS.bossProjectiles.push({ x: b.x, y: b.y, vx: Math.cos(a) * 4, vy: Math.sin(a) * 4, icon: 'üíú', sz: 22, life: 90, r: 14, dmg: 2, cls: 'spin' });
            }, i * 80 + 80);
          }
          GS.bossWarnings.push({ x: b.x, y: b.y, r: 120, life: 24, maxLife: 24, type: 'ring', color: '#8800ff' });
          sBossWave();
          break;
        }
        // ---- PATTERN 5: Death beam (sweeping laser) ----
        case 'death_beam': {
          // Charge-up phase first ‚Äî boss stops, glows, then fires
          b.beamCharging = true; b.beamChargeTimer = 70; // ~1.2s warning
          b.beamTargetAngle = Math.atan2(p.y - b.y, p.x - b.x);
          b.beamSweepDir = 1; b.beamDmgCD = 0;
          // Big visible warnings: multiple expanding rings + screen tint
          for (let i = 0; i < 3; i++) {
            setTimeout(() => {
              if (b.state === 'dead' || b.state === 'dying') return;
              GS.bossWarnings.push({ x: b.x, y: b.y, r: 60 + i * 60, life: 50, maxLife: 50, type: 'ring', color: '#ff0000' });
            }, i * 200);
          }
          // Directional warning line (shows where beam will fire)
          GS.bossWarnings.push({ x: b.x, y: b.y, r: 260, life: 65, maxLife: 65, type: 'beam_warn', angle: b.beamTargetAngle, color: '#ff4400' });
          screenFlash(255, 0, 0, 0.25, 1200); sBossBeam();
          // Actually fire after charge-up delay
          setTimeout(() => {
            if (b.state === 'dead' || b.state === 'dying' || !b.beamCharging) return;
            b.beamCharging = false;
            b.beamActive = true; b.beamTimer = 100;
            b.beamAngle = b.beamTargetAngle - 0.5;
            screenFlash(255, 80, 0, 0.5, 300); GS.shake = 10;
          }, 1150);
          break;
        }
        // ---- PATTERN 6: Fireball burst ----
        case 'fireball_burst': {
          for (let i = 0; i < 12; i++) {
            setTimeout(() => {
              if (b.state === 'dead' || b.state === 'dying') return;
              const ang = Math.atan2(p.y - b.y, p.x - b.x) + (Math.random() - 0.5) * 0.6;
              GS.bossProjectiles.push({ x: b.x, y: b.y, vx: Math.cos(ang) * 4.5, vy: Math.sin(ang) * 4.5, icon: 'üî•', sz: 24, life: 70, r: 14, dmg: 3, cls: 'fire' });
            }, i * 80);
          }
          GS.bossWarnings.push({ x: b.x, y: b.y, r: 150, life: 26, maxLife: 26, type: 'ring', color: '#ff5500' });
          screenFlash(255, 150, 0, 0.4, 300); sBossBeam();
          break;
        }
        // ---- PATTERN 7: Dash slam (fast dash then shockwave) ----
        case 'dash_slam': {
          const ang = Math.atan2(p.y - b.y, p.x - b.x);
          b.dashActive = true; b.dashTimer = 18;
          b.dashVx = Math.cos(ang) * 14; b.dashVy = Math.sin(ang) * 14;
          GS.bossWarnings.push({ x: p.x, y: p.y, r: 90, life: 28, maxLife: 28, type: 'circle', color: '#ff8800' });
          sBossDash();
          // After dash, shockwave
          setTimeout(() => {
            if (b.state === 'dead' || b.state === 'dying') return;
            for (let i = 0; i < 12; i++) {
              const a = i / 12 * Math.PI * 2;
              GS.bossProjectiles.push({ x: b.x, y: b.y, vx: Math.cos(a) * 3.5, vy: Math.sin(a) * 3.5, icon: 'üåä', sz: 20, life: 60, r: 12, dmg: 2, cls: 'ice' });
            }
            GS.shake = 15; screenFlash(255, 200, 50, 0.5, 250);
          }, 350);
          break;
        }
        // ---- PATTERN 8: Time stop ----
        case 'time_stop': {
          GS.timeStop = true; GS.timeStopTimer = 120;
          screenFlash(100, 100, 255, 0.6, 600); GS.shake = 12;
          // During time stop, boss fires a spiral
          for (let i = 0; i < 20; i++) {
            setTimeout(() => {
              if (b.state === 'dead' || b.state === 'dying') return;
              const a = i * 0.5;
              GS.bossProjectiles.push({ x: b.x, y: b.y, vx: Math.cos(a) * 3, vy: Math.sin(a) * 3, icon: '‚è∞', sz: 18, life: 80, r: 12, dmg: 2, cls: 'ice' });
            }, i * 100);
          }
          sBossRage();
          break;
        }
        // ---- PATTERN 9: Meteor shower ----
        case 'meteor': {
          for (let i = 0; i < 6; i++) {
            setTimeout(() => {
              if (b.state === 'dead' || b.state === 'dying') return;
              const tx = p.x + (Math.random() - 0.5) * 200; const ty = p.y + (Math.random() - 0.5) * 200;
              GS.bossWarnings.push({ x: tx, y: ty, r: 55, life: 40, maxLife: 40, type: 'circle', color: '#ff3300' });
              setTimeout(() => {
                if (b.state === 'dead' || b.state === 'dying') return;
                GS.atks.push({ worldX: tx, worldY: ty, icon: '‚òÑÔ∏è', sz: 44, life: 22, maxLife: 22, vx: 0, vy: 0 });
                GS.shake = 10;
                if (dst({ x: tx, y: ty }, p) < 65) damagePlayer(4, 'fire');
              }, 600);
            }, i * 200);
          }
          sBossBeam();
          break;
        }
        // ---- PATTERN 10: Enrage (speed + fire ring) ----
        case 'enrage': {
          b.rageMode = true;
          for (let i = 0; i < 16; i++) {
            const a = i / 16 * Math.PI * 2;
            GS.bossProjectiles.push({ x: b.x, y: b.y, vx: Math.cos(a) * 3, vy: Math.sin(a) * 3, icon: 'üí¢', sz: 16, life: 120, r: 10, dmg: 2, cls: 'fire' });
          }
          GS.shake = 18; screenFlash(255, 0, 0, 0.6, 500); sBossRage();
          break;
        }
        // ---- PATTERN NEW: Void Spiral (spirale de projectiles void qui s'enroule) ----
        case 'void_spiral': {
          const totalProj = b.rageMode ? 24 : 16;
          for (let i = 0; i < totalProj; i++) {
            setTimeout(() => {
              if (b.state === 'dead' || b.state === 'dying') return;
              const spiralAngle = i / totalProj * Math.PI * 4; // 2 rotations
              const speed = 2.8 + (i / totalProj) * 1.5;
              GS.bossProjectiles.push({ x: b.x, y: b.y, vx: Math.cos(spiralAngle) * speed, vy: Math.sin(spiralAngle) * speed, icon: 'üåÄ', sz: 20, life: 85, r: 12, dmg: 2, cls: 'spin' });
            }, i * 60);
          }
          GS.bossWarnings.push({ x: b.x, y: b.y, r: 130, life: 30, maxLife: 30, type: 'ring', color: '#9900ff' });
          screenFlash(150, 0, 255, 0.35, 400); sBossWave();
          break;
        }
        // ---- PATTERN NEW: Shadow Clone (boss cr√©e 3 clones fant√¥mes qui attaquent) ----
        case 'shadow_clone': {
          for (let i = 0; i < 3; i++) {
            setTimeout(() => {
              if (b.state === 'dead' || b.state === 'dying') return;
              const ang = (i / 3) * Math.PI * 2;
              const cx = b.x + Math.cos(ang) * 90, cy = b.y + Math.sin(ang) * 90;
              GS.bossWarnings.push({ x: cx, y: cy, r: 40, life: 35, maxLife: 35, type: 'circle', color: '#6600cc' });
              // Clone shoots toward player after brief delay
              setTimeout(() => {
                if (b.state === 'dead' || b.state === 'dying') return;
                const p2 = GS.p; const tAng = Math.atan2(p2.y - cy, p2.x - cx);
                for (let j = -1; j <= 1; j++) {
                  const a2 = tAng + j * 0.3;
                  GS.bossProjectiles.push({ x: cx, y: cy, vx: Math.cos(a2) * 4.5, vy: Math.sin(a2) * 4.5, icon: 'üíú', sz: 22, life: 75, r: 12, dmg: b.rageMode ? 3 : 2, cls: 'spin' });
                }
                GS.atks.push({ worldX: cx, worldY: cy, icon: 'üåÄ', sz: 36, life: 15, maxLife: 15, vx: 0, vy: 0 });
              }, 500);
            }, i * 300);
          }
          screenFlash(100, 0, 200, 0.3, 500); sBossBeam();
          break;
        }
        // ---- PATTERN NEW: Ground Crack (fissures au sol qui convergent vers le joueur) ----
        case 'ground_crack': {
          const p3 = GS.p;
          for (let i = 0; i < (b.rageMode ? 5 : 3); i++) {
            setTimeout(() => {
              if (b.state === 'dead' || b.state === 'dying') return;
              const offsetAng = (i / (b.rageMode ? 5 : 3)) * Math.PI * 2;
              const startX = b.x + Math.cos(offsetAng) * 120;
              const startY = b.y + Math.sin(offsetAng) * 120;
              // Warning line from start toward player
              GS.bossWarnings.push({ x: startX, y: startY, r: 80, life: 40, maxLife: 40, type: 'beam_warn', angle: Math.atan2(p3.y - startY, p3.x - startX), color: '#ff6600' });
              setTimeout(() => {
                if (b.state === 'dead' || b.state === 'dying') return;
                // Fire crack projectile
                const cAng = Math.atan2(p3.y - startY, p3.x - startX);
                for (let k = -1; k <= 1; k++) {
                  const a3 = cAng + k * 0.2;
                  GS.bossProjectiles.push({ x: startX, y: startY, vx: Math.cos(a3) * 5.5, vy: Math.sin(a3) * 5.5, icon: '‚òÑÔ∏è', sz: 20, life: 60, r: 13, dmg: b.rageMode ? 4 : 3, cls: 'fire' });
                }
                GS.shake = 8;
              }, 600);
            }, i * 200);
          }
          screenFlash(255, 100, 0, 0.4, 600); sBossBeam();
          break;
        }
        // ---- PATTERN NEW: Chain Lightning (√©clairs en cha√Æne autour du boss) ----
        case 'chain_lightning': {
          const p4 = GS.p;
          // Boss charges briefly then unleashes arc lightning
          b.beamCharging = true; b.beamChargeTimer = 55;
          b.beamTargetAngle = Math.atan2(p4.y - b.y, p4.x - b.x);
          b.beamSweepDir = b.rageMode ? 2 : 1; b.beamDmgCD = 0;
          for (let i = 0; i < 3; i++) {
            setTimeout(() => {
              if (b.state === 'dead' || b.state === 'dying') return;
              GS.bossWarnings.push({ x: b.x, y: b.y, r: 50 + i * 40, life: 40, maxLife: 40, type: 'ring', color: '#00ffff' });
            }, i * 150);
          }
          GS.bossWarnings.push({ x: b.x, y: b.y, r: 280, life: 50, maxLife: 50, type: 'beam_warn', angle: b.beamTargetAngle, color: '#00eeff' });
          screenFlash(0, 220, 255, 0.3, 900); sBossBeam();
          setTimeout(() => {
            if (b.state === 'dead' || b.state === 'dying' || !b.beamCharging) return;
            b.beamCharging = false; b.beamActive = true; b.beamTimer = b.rageMode ? 140 : 100;
            b.beamAngle = b.beamTargetAngle - 0.4;
            // Additional scatter bolts
            for (let j = 0; j < (b.rageMode ? 8 : 5); j++) {
              const ang5 = Math.random() * Math.PI * 2;
              GS.bossProjectiles.push({ x: b.x, y: b.y, vx: Math.cos(ang5) * 3.5, vy: Math.sin(ang5) * 3.5, icon: '‚ö°', sz: 22, life: 70, r: 12, dmg: 2, cls: 'ice' });
            }
            screenFlash(0, 255, 255, 0.6, 300); GS.shake = 14;
          }, 900);
          break;
        }
        // ---- PATTERN NEW: Dark Nova (explosion sombre massive centr√©e sur le boss) ----
        case 'dark_nova': {
          // Big charge-up, then massive explosion
          screenFlash(50, 0, 80, 0.5, 1500);
          for (let i = 0; i < 4; i++) {
            setTimeout(() => {
              if (b.state === 'dead' || b.state === 'dying') return;
              GS.bossWarnings.push({ x: b.x, y: b.y, r: 40 + i * 50, life: 55, maxLife: 55, type: 'ring', color: '#cc00ff' });
            }, i * 250);
          }
          sBossRage();
          setTimeout(() => {
            if (b.state === 'dead' || b.state === 'dying') return;
            // Massive radial burst: 20 projectiles
            const numProj = b.rageMode ? 28 : 20;
            for (let i = 0; i < numProj; i++) {
              const ang6 = (i / numProj) * Math.PI * 2;
              const speed2 = 3.5 + Math.random() * 2;
              GS.bossProjectiles.push({ x: b.x, y: b.y, vx: Math.cos(ang6) * speed2, vy: Math.sin(ang6) * speed2, icon: 'üíú', sz: 24, life: 90, r: 14, dmg: b.rageMode ? 4 : 3, cls: 'spin' });
            }
            GS.shake = 25; screenFlash(180, 0, 255, 0.85, 400);
            // Point-blank damage
            if (dst(b, GS.p) < 120) damagePlayer(b.rageMode ? 5 : 3, 'spin');
            for (let k = 0; k < 8; k++) GS.atks.push({ worldX: b.x + (Math.random() - 0.5) * 100, worldY: b.y + (Math.random() - 0.5) * 100, icon: 'üí•', sz: 30 + Math.random() * 15, life: 20, maxLife: 20, vx: 0, vy: 0 });
          }, 1400);
          b.patternTimer += 160; // extra cooldown
          break;
        }
        // ---- ARAKHNE: Web Snare (filet qui capture et ralentit) ----
        case 'web_snare': {
          const p5 = GS.p;
          // Lance 3 fils vers le joueur qui convergent
          for (let i = 0; i < 3; i++) {
            setTimeout(() => {
              if (b.state === 'dead' || b.state === 'dying') return;
              const offset = (i - 1) * 0.5;
              const ang = Math.atan2(p5.y - b.y, p5.x - b.x) + offset;
              GS.bossProjectiles.push({ x: b.x, y: b.y, vx: Math.cos(ang) * 5, vy: Math.sin(ang) * 5, icon: 'üï∏Ô∏è', sz: 26, life: 80, r: 16, dmg: b.rageMode ? 3 : 2, cls: 'spin' });
            }, i * 150);
          }
          // Grande toile pi√®ge au sol sous le joueur
          GS.bossWarnings.push({ x: p5.x, y: p5.y, r: 70, life: 40, maxLife: 40, type: 'circle', color: '#880088' });
          setTimeout(() => {
            if (b.state === 'dead' || b.state === 'dying') return;
            if (dst({ x: p5.x, y: p5.y }, GS.p) < 90) damagePlayer(b.rageMode ? 4 : 2, 'spin');
          }, 700);
          screenFlash(100, 0, 100, 0.3, 400); sBossWave();
          break;
        }
        // ---- ARAKHNE: Venom Burst (crachat de venin radial) ----
        case 'venom_burst': {
          const numV = b.rageMode ? 14 : 10;
          for (let i = 0; i < numV; i++) {
            setTimeout(() => {
              if (b.state === 'dead' || b.state === 'dying') return;
              const a = (i / numV) * Math.PI * 2;
              GS.bossProjectiles.push({ x: b.x, y: b.y, vx: Math.cos(a) * 3.5, vy: Math.sin(a) * 3.5, icon: '‚ò†Ô∏è', sz: 20, life: 90, r: 12, dmg: 2, cls: 'spin' });
            }, i * 50);
          }
          GS.bossWarnings.push({ x: b.x, y: b.y, r: 100, life: 22, maxLife: 22, type: 'ring', color: '#44aa00' });
          screenFlash(0, 150, 0, 0.3, 300); sBossWave();
          break;
        }
        // ---- ARAKHNE: Silk Storm (temp√™te de fils depuis tous c√¥t√©s) ----
        case 'silk_storm': {
          const p6 = GS.p;
          for (let i = 0; i < (b.rageMode ? 8 : 5); i++) {
            setTimeout(() => {
              if (b.state === 'dead' || b.state === 'dying') return;
              // Depuis les bords de l'√©cran vers le joueur
              const edgeAngle = (i / (b.rageMode ? 8 : 5)) * Math.PI * 2;
              const ex = p6.x + Math.cos(edgeAngle) * 250, ey = p6.y + Math.sin(edgeAngle) * 250;
              const toAng = Math.atan2(p6.y - ey, p6.x - ex);
              GS.bossWarnings.push({ x: ex, y: ey, r: 45, life: 35, maxLife: 35, type: 'beam_warn', angle: toAng, color: '#cc44cc' });
              setTimeout(() => {
                if (b.state === 'dead' || b.state === 'dying') return;
                for (let j = -1; j <= 1; j++) {
                  const a2 = toAng + j * 0.2;
                  GS.bossProjectiles.push({ x: ex, y: ey, vx: Math.cos(a2) * 6, vy: Math.sin(a2) * 6, icon: 'üï∏Ô∏è', sz: 22, life: 60, r: 12, dmg: b.rageMode ? 3 : 2, cls: 'spin' });
                }
              }, 600);
            }, i * 200);
          }
          screenFlash(150, 0, 150, 0.35, 800); sBossBeam();
          break;
        }
        // ---- ARAKHNE: Brood Summon (invoque des araign√©es) ----
        case 'brood_summon': {
          for (let i = 0; i < 6; i++) {
            const ang = (i / 6) * Math.PI * 2;
            const ex = b.x + Math.cos(ang) * 80, ey = b.y + Math.sin(ang) * 80;
            GS.atks.push({ worldX: ex, worldY: ey, icon: 'üï∑Ô∏è', sz: 28, life: 20, maxLife: 20, vx: 0, vy: 0 });
          }
          // Projectiles depuis les positions des araign√©es invoqu√©es
          setTimeout(() => {
            if (b.state === 'dead' || b.state === 'dying') return;
            for (let i = 0; i < 6; i++) {
              const ang = (i / 6) * Math.PI * 2;
              const ex = b.x + Math.cos(ang) * 80, ey = b.y + Math.sin(ang) * 80;
              const tAng = Math.atan2(GS.p.y - ey, GS.p.x - ex);
              GS.bossProjectiles.push({ x: ex, y: ey, vx: Math.cos(tAng) * 4.5, vy: Math.sin(tAng) * 4.5, icon: '‚ò†Ô∏è', sz: 18, life: 75, r: 11, dmg: 2, cls: 'spin' });
            }
          }, 400);
          GS.shake = 6; screenFlash(80, 0, 80, 0.3, 500); sBossWave();
          break;
        }
        // ---- ZARVETH: Crystal Shard (√©clats de cristal depuis le sol) ----
        case 'crystal_shard': {
          const p7 = GS.p;
          const numShards = b.rageMode ? 8 : 5;
          for (let i = 0; i < numShards; i++) {
            setTimeout(() => {
              if (b.state === 'dead' || b.state === 'dying') return;
              const tx = p7.x + (Math.random() - 0.5) * 180;
              const ty = p7.y + (Math.random() - 0.5) * 180;
              GS.bossWarnings.push({ x: tx, y: ty, r: 42, life: 38, maxLife: 38, type: 'circle', color: '#00ccff' });
              setTimeout(() => {
                if (b.state === 'dead' || b.state === 'dying') return;
                // √âclats partant vers l'ext√©rieur
                for (let j = 0; j < 4; j++) {
                  const a = j * Math.PI / 2 + Math.random() * 0.5;
                  GS.bossProjectiles.push({ x: tx, y: ty, vx: Math.cos(a) * 5.5, vy: Math.sin(a) * 5.5, icon: 'üí†', sz: 20, life: 55, r: 12, dmg: b.rageMode ? 3 : 2, cls: 'ice' });
                }
                GS.atks.push({ worldX: tx, worldY: ty, icon: 'üí•', sz: 38, life: 18, maxLife: 18, vx: 0, vy: 0 });
                if (dst({ x: tx, y: ty }, p7) < 50) damagePlayer(2, 'ice');
              }, 650);
            }, i * 180);
          }
          screenFlash(0, 150, 255, 0.35, 600); sBossBeam();
          break;
        }
        // ---- ZARVETH: Prism Beam (rayon prismatique d√©vastateur) ----
        case 'prism_beam': {
          b.beamCharging = true; b.beamChargeTimer = 65;
          b.beamTargetAngle = Math.atan2(GS.p.y - b.y, GS.p.x - b.x);
          b.beamSweepDir = b.rageMode ? 2 : 1; b.beamDmgCD = 0;
          for (let i = 0; i < 3; i++) {
            setTimeout(() => {
              if (b.state === 'dead' || b.state === 'dying') return;
              GS.bossWarnings.push({ x: b.x, y: b.y, r: 55 + i * 45, life: 55, maxLife: 55, type: 'ring', color: '#00eeff' });
            }, i * 180);
          }
          GS.bossWarnings.push({ x: b.x, y: b.y, r: 320, life: 60, maxLife: 60, type: 'beam_warn', angle: b.beamTargetAngle, color: '#88ffff' });
          screenFlash(0, 200, 255, 0.35, 1000); sBossBeam();
          setTimeout(() => {
            if (b.state === 'dead' || b.state === 'dying' || !b.beamCharging) return;
            b.beamCharging = false; b.beamActive = true; b.beamTimer = b.rageMode ? 130 : 95;
            b.beamAngle = b.beamTargetAngle - 0.45;
            // Projections lat√©rales arc-en-ciel
            for (let j = 0; j < (b.rageMode ? 6 : 4); j++) {
              const ang = b.beamTargetAngle + (j % 2 === 0 ? 1 : -1) * (j * 0.35 + 0.3);
              GS.bossProjectiles.push({ x: b.x, y: b.y, vx: Math.cos(ang) * 4, vy: Math.sin(ang) * 4, icon: 'üí†', sz: 22, life: 70, r: 12, dmg: 2, cls: 'ice' });
            }
            screenFlash(0, 255, 255, 0.55, 300); GS.shake = 13;
          }, 1100);
          break;
        }
        // ---- ZARVETH: Quake Stomp (s√©isme qui fissure le sol en croix) ----
        case 'quake_stomp': {
          GS.bossWarnings.push({ x: b.x, y: b.y, r: 200, life: 30, maxLife: 30, type: 'ring', color: '#ffee00' });
          sBossRage();
          setTimeout(() => {
            if (b.state === 'dead' || b.state === 'dying') return;
            GS.shake = 22;
            screenFlash(255, 220, 0, 0.6, 350);
            // 4 lignes de fissures dans les 4 directions cardinales
            for (let dir = 0; dir < 4; dir++) {
              const a = dir * Math.PI / 2;
              for (let dist = 1; dist <= (b.rageMode ? 7 : 5); dist++) {
                const delay = dist * 80;
                setTimeout(() => {
                  if (b.state === 'dead' || b.state === 'dying') return;
                  const ex = b.x + Math.cos(a) * dist * 55;
                  const ey = b.y + Math.sin(a) * dist * 55;
                  GS.atks.push({ worldX: ex, worldY: ey, icon: 'üí•', sz: 35, life: 16, maxLife: 16, vx: 0, vy: 0 });
                  if (dst({ x: ex, y: ey }, GS.p) < 45) damagePlayer(b.rageMode ? 4 : 3, 'fire');
                }, delay);
              }
            }
          }, 500);
          break;
        }
        // ---- ZARVETH: Mirror Barrage (copies miroir du projectile) ----
        case 'mirror_barrage': {
          const numMirrors = b.rageMode ? 6 : 4;
          for (let i = 0; i < numMirrors; i++) {
            setTimeout(() => {
              if (b.state === 'dead' || b.state === 'dying') return;
              const mirrorAng = (i / numMirrors) * Math.PI * 2;
              const mx = b.x + Math.cos(mirrorAng) * 70, my = b.y + Math.sin(mirrorAng) * 70;
              // Chaque miroir tire vers le joueur
              const tAng = Math.atan2(GS.p.y - my, GS.p.x - mx);
              for (let k = -1; k <= 1; k++) {
                GS.bossProjectiles.push({ x: mx, y: my, vx: Math.cos(tAng + k * 0.3) * 5.2, vy: Math.sin(tAng + k * 0.3) * 5.2, icon: 'üî∑', sz: 20, life: 70, r: 12, dmg: b.rageMode ? 3 : 2, cls: 'ice' });
              }
              GS.atks.push({ worldX: mx, worldY: my, icon: '‚ú®', sz: 25, life: 14, maxLife: 14, vx: 0, vy: 0 });
            }, i * 220);
          }
          screenFlash(100, 200, 255, 0.3, 500); sBossWave();
          break;
        }
        // ---- ZARVETH: Refraction Nova (explosion prismatique g√©ante) ----
        case 'refraction_nova': {
          screenFlash(0, 100, 200, 0.5, 1800);
          for (let i = 0; i < 5; i++) {
            setTimeout(() => {
              if (b.state === 'dead' || b.state === 'dying') return;
              GS.bossWarnings.push({ x: b.x, y: b.y, r: 35 + i * 45, life: 60, maxLife: 60, type: 'ring', color: '#00ddff' });
            }, i * 280);
          }
          sBossRage();
          setTimeout(() => {
            if (b.state === 'dead' || b.state === 'dying') return;
            const numR = b.rageMode ? 24 : 18;
            for (let i = 0; i < numR; i++) {
              const ang = (i / numR) * Math.PI * 2;
              const spd = 3.8 + Math.random() * 2;
              GS.bossProjectiles.push({ x: b.x, y: b.y, vx: Math.cos(ang) * spd, vy: Math.sin(ang) * spd, icon: 'üí†', sz: 24, life: 95, r: 14, dmg: b.rageMode ? 4 : 3, cls: 'ice' });
            }
            // Rafales de cristaux secondaires d√©cal√©es
            for (let i = 0; i < numR; i++) {
              const ang = (i / numR) * Math.PI * 2 + Math.PI / numR;
              GS.bossProjectiles.push({ x: b.x, y: b.y, vx: Math.cos(ang) * 2.5, vy: Math.sin(ang) * 2.5, icon: 'üî∑', sz: 18, life: 75, r: 11, dmg: 2, cls: 'ice' });
            }
            GS.shake = 28; screenFlash(0, 200, 255, 0.9, 500);
            if (dst(b, GS.p) < 130) damagePlayer(b.rageMode ? 5 : 3, 'ice');
            for (let k = 0; k < 10; k++) GS.atks.push({ worldX: b.x + (Math.random()-0.5)*120, worldY: b.y + (Math.random()-0.5)*120, icon: 'üí•', sz: 28+Math.random()*15, life: 20, maxLife: 20, vx: 0, vy: 0 });
          }, 1700);
          b.patternTimer += 180;
          break;
        }
        // ---- PATTERN 11: Aerial Slam (Dragon takes flight, picks target, CRASHES DOWN) ----
        case 'aerial_slam': {
          if (b.aerialActive) break; // already in flight
          b.aerialActive = true;
          b.aerialTimer = 0;
          b.aerialTargetX = p.x;
          b.aerialTargetY = p.y;
          b.aerialPhase = 'rising'; // rising ‚Üí hovering ‚Üí warning ‚Üí slamming ‚Üí impact
          // Phase 1: Dragon rises (scale up, glow)
          screenFlash(255, 100, 0, 0.4, 300); GS.shake = 8;
          sBossRage();
          // Store original pos for rendering offset
          b.aerialOriginX = b.x; b.aerialOriginY = b.y;
          b.aerialRiseTimer = 50; // frames rising
          b.patternTimer += 220; // give extra cooldown since this is a long attack
          break;
        }
      }
    }

    // ============================================================
    // MONSTER AI
    // ============================================================
    function updMons() {
      if (GS.timeStop && GS.timeStopTimer > 0) {
        GS.timeStopTimer--; if (GS.timeStopTimer <= 0) { GS.timeStop = false; screenFlash(100, 100, 255, 0.3, 300); }
        // Only update boss during time stop (it attacks)
        if (GS.boss && GS.boss.state !== 'dead' && GS.boss.state !== 'dying') {
          updBoss(GS.boss); updBossHPBar();
        }
        return;
      }
      const p = GS.p; const { map } = GS.map;
      for (const m of GS.mons) {
        if (m.hitFlash > 0) m.hitFlash--; if (m.atkCD > 0) m.atkCD--;
        if (m.state === 'dying') { m.dyingTimer--; if (m.dyingTimer <= 0) m.state = 'dead'; continue; }
        if (m.state === 'dead') continue;
        const d = dst(m, p);
        if (m.state === 'idle' || m.state === 'wander') {
          m.wTimer--; if (m.wTimer <= 0) { m.wAngle += (Math.random() - 0.5) * Math.PI; m.wTimer = 60 + Math.random() * 90; }
          m.vx = Math.cos(m.wAngle) * m.spd * 0.3; m.vy = Math.sin(m.wAngle) * m.spd * 0.3; m.state = 'wander';
          if (d < m.aggroR) m.state = 'chase';
        }
        if (m.state === 'chase') {
          if (d > m.loseR) { m.state = 'idle'; m.vx = 0; m.vy = 0; continue; }
          m.vx = lerp(m.vx, (p.x - m.x) / d * m.spd, 0.12); m.vy = lerp(m.vy, (p.y - m.y) / d * m.spd, 0.12);
          if (d < m.r + p.r + 6 && m.atkCD <= 0) { damagePlayer(m.dmg, 'normal'); m.atkCD = 65; }
        }
        let nx = m.x + m.vx, ny = m.y + m.vy;
        if (!blk(nx, m.y, map)) m.x = nx; else m.vx *= -1;
        if (!blk(m.x, ny, map)) m.y = ny; else m.vy *= -1;
        m.x = Math.max(TSIZ, Math.min(WW - TSIZ, m.x)); m.y = Math.max(TSIZ, Math.min(WH - TSIZ, m.y));
      }
      if (GS.boss && GS.boss.state !== 'dead') { updBoss(GS.boss); updBossHPBar(); }
    }

    function updBoss(b) {
      if (b.hitFlash > 0) b.hitFlash--; if (b.atkCD > 0) b.atkCD--; if (b.teleportCooldown > 0) b.teleportCooldown--;
      if (b.state === 'dying') { b.dyingTimer--; if (b.dyingTimer <= 0) b.state = 'dead'; return; }
      if (b.state === 'dead') return;
      const p = GS.p; const d = dst(b, p); const { map } = GS.map;
      // Boss 2: show "DANGER" warning zone before aggro
      if (b.warnR && b.state === 'idle' && !b.warnZoneAlerted) {
        if (d < b.warnR) {
          b.warnZoneAlerted = true;
          GS.bossWarnings.push({ x: b.x, y: b.y, r: b.warnR, life: 60, maxLife: 60, type: 'warn_zone', color: '#ff8800' });
          screenFlash(255, 120, 0, 0.3, 800); GS.shake = 6;
          // pulse warning to player
          for (let i = 0; i < 3; i++) setTimeout(() => { if (b.state === 'dead') return; GS.bossWarnings.push({ x: b.x, y: b.y, r: b.warnR * 0.6, life: 30, maxLife: 30, type: 'ring', color: '#ff6600' }); }, i * 350);
        }
      }
      if (b.state === 'idle') { if (d < b.aggroR) { b.state = 'chase'; if (b.warnR) { screenFlash(255, 50, 0, 0.5, 400); GS.shake = 12; } } }
      if (b.state === 'chase' || b.state === 'attack') {
        // Dash movement
        if (b.dashActive && b.dashTimer > 0) {
          b.dashTimer--;
          const nx = b.x + b.dashVx, ny = b.y + b.dashVy;
          if (!blk(nx, b.y, map)) b.x = nx; else { b.dashVx *= -0.5; b.x += b.dashVx; }
          if (!blk(b.x, ny, map)) b.y = ny; else { b.dashVy *= -0.5; b.y += b.dashVy; }
          // Damage if hits player during dash
          if (dst(b, p) < b.r + p.r + 10 && b.atkCD <= 0) { damagePlayer(b.dmg + 1, 'boss'); b.atkCD = 40; }
          if (b.dashTimer <= 0) { b.dashActive = false; GS.shake = 8; }
        } else if (b.aerialActive && (b.aerialPhase === 'rising' || b.aerialPhase === 'hovering' || b.aerialPhase === 'frozen')) {
          // During aerial: hover in place, don't move horizontally
          b.vx = 0; b.vy = 0;
        } else {
          // Normal chase ‚Äî boss PHASES through walls (no getting stuck!)
          const spd = b.rageMode ? b.spd * 1.7 : b.spd;
          const tx = (p.x - b.x) / d * spd, ty = (p.y - b.y) / d * spd;
          b.vx = lerp(b.vx || 0, tx, 0.08); b.vy = lerp(b.vy || 0, ty, 0.08);
          // Bosses are too powerful to be stopped by walls ‚Äî they phase through!
          b.x += b.vx || 0; b.y += b.vy || 0;
          // Wall phase visual effect: emit ghostly particles when inside a wall
          if (blk(b.x, b.y, map)) {
            GS.atks.push({ worldX: b.x, worldY: b.y, icon: 'üëÅÔ∏è', sz: 28, life: 12, maxLife: 12, vx: (Math.random() - 0.5) * 1.5, vy: (Math.random() - 0.5) * 1.5 });
          }
        }
        b.x = Math.max(TSIZ, Math.min(WW - TSIZ, b.x)); b.y = Math.max(TSIZ, Math.min(WH - TSIZ, b.y));
        // Melee attack
        if (d < b.r + p.r + 10 && b.atkCD <= 0 && !b.dashActive) { damagePlayer(b.dmg, 'boss'); b.atkCD = 55; }
        // Beam damage
        if (b.beamActive && b.beamTimer > 0) {
          b.beamTimer--;
          // Slow sweep ‚Äî much more dodgeable
          b.beamAngle += 0.008 * b.beamSweepDir * (b.rageMode ? 1.3 : 1);
          if (b.beamDmgCD > 0) b.beamDmgCD--;
          const beamDirX = Math.cos(b.beamAngle), beamDirY = Math.sin(b.beamAngle);
          const toPX = p.x - b.x, toPY = p.y - b.y;
          const dot = toPX * beamDirX + toPY * beamDirY;
          const cross = Math.abs(toPX * beamDirY - toPY * beamDirX);
          // Damage only every 30 frames (0.5s) and only if truly in beam
          if (dot > 0 && cross < 24 && dst(b, p) < 450 && b.beamDmgCD <= 0) {
            damagePlayer(b.rageMode ? 2 : 1, 'fire');
            b.beamDmgCD = 30;
          }
          if (b.beamTimer <= 0) { b.beamActive = false; }
        }
        // Pattern trigger
        doBossPattern(b);
        // ---- AERIAL SLAM (Boss 3) state machine ----
        if (b.aerialActive) {
          b.aerialTimer++;
          const t = b.aerialTimer;
          if (b.aerialPhase === 'rising') {
            // Move upward visually (we store aerialY offset)
            b.aerialYOff = (b.aerialYOff || 0) - 2.5;
            if (b.aerialYOff < -80) b.aerialYOff = -80;
            if (t >= b.aerialRiseTimer) {
              b.aerialPhase = 'hovering';
              b.aerialTimer = 0;
              // Lock onto current player position for slam
              b.aerialTargetX = p.x; b.aerialTargetY = p.y;
            }
          } else if (b.aerialPhase === 'hovering') {
            // 40 frames: dragon hovers above, shadow + warning circle grows below
            const progress = t / 40;
            if (t % 8 === 0) GS.bossWarnings.push({ x: b.aerialTargetX, y: b.aerialTargetY, r: 20 + progress * 80, life: 18, maxLife: 18, type: 'slam_zone', color: '#ff3300' });
            if (t === 15) { screenFlash(255, 50, 0, 0.3, 200); GS.shake = 4; }
            if (t >= 40) {
              b.aerialPhase = 'frozen'; // freeze moment before slam
              b.aerialTimer = 0;
              // Big final warning
              GS.bossWarnings.push({ x: b.aerialTargetX, y: b.aerialTargetY, r: 90, life: 20, maxLife: 20, type: 'slam_zone', color: '#ff0000' });
              screenFlash(255, 0, 0, 0.6, 300); GS.shake = 10;
            }
          } else if (b.aerialPhase === 'frozen') {
            // Freeze in air for dramatic effect (20 frames)
            b.aerialYOff = (b.aerialYOff || -80); // stay up
            if (t >= 20) {
              b.aerialPhase = 'slamming';
              b.aerialTimer = 0;
              sBossRage();
            }
          } else if (b.aerialPhase === 'slamming') {
            // Fast crash down (15 frames)
            const progress = Math.min(1, t / 15);
            b.aerialYOff = -80 * (1 - progress);
            b.x = lerp(b.x, b.aerialTargetX, 0.18);
            b.y = lerp(b.y, b.aerialTargetY, 0.08);
            if (t >= 15 || (b.aerialYOff >= -5)) {
              b.aerialYOff = 0;
              b.x = b.aerialTargetX; b.y = b.aerialTargetY;
              b.aerialPhase = 'impact';
              b.aerialTimer = 0;
              // IMPACT ‚Äî massive damage, shockwave, screen shake
              GS.shake = 30; screenFlash(255, 100, 0, 0.9, 400);
              const impDist = dst(b, p);
              if (impDist < 110) { damagePlayer(b.rageMode ? 7 : 5, 'fire'); }
              else if (impDist < 180) { damagePlayer(b.rageMode ? 4 : 2, 'fire'); }
              // Shockwave projectiles radially
              for (let i = 0; i < 16; i++) {
                const a = i / 16 * Math.PI * 2;
                GS.bossProjectiles.push({ x: b.x, y: b.y, vx: Math.cos(a) * 5, vy: Math.sin(a) * 5, icon: 'üî•', sz: 22, life: 55, r: 13, dmg: b.rageMode ? 3 : 2, cls: 'fire' });
              }
              // Big impact visuals
              for (let i = 0; i < 10; i++) {
                GS.atks.push({ worldX: b.x + (Math.random() - 0.5) * 80, worldY: b.y + (Math.random() - 0.5) * 80, icon: 'üí•', sz: 34 + Math.random() * 20, life: 22, maxLife: 22, vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2 });
              }
              sBossBeam();
            }
          } else if (b.aerialPhase === 'impact') {
            if (t >= 30) { b.aerialActive = false; b.aerialYOff = 0; b.aerialPhase = null; }
          }
        }
      }
    }

    // ============================================================
    // PROJECTILE UPDATE
    // ============================================================
    function updProjectiles() {
      const { map } = GS.map; const p = GS.p;
      // Player projectiles
      for (let i = GS.projectiles.length - 1; i >= 0; i--) {
        const pr = GS.projectiles[i]; pr.life--; pr.x += pr.vx; pr.y += pr.vy;
        if (blk(pr.x, pr.y, map) || pr.life <= 0) { GS.projectiles.splice(i, 1); continue; }
        let hit = false;
        const all = [...GS.mons]; if (GS.boss && GS.boss.state !== 'dead') all.push(GS.boss);
        for (const m of all) {
          if (m.state === 'dead' || m.state === 'dying') continue;
          if (dst(pr, m) < m.r + pr.r) {
            const cls = curLvl === 2 ? 'ice' : curLvl === 1 ? 'fire' : 'normal';
            hitMon(m, pr.power, cls);
            GS.atks.push({ worldX: pr.x, worldY: pr.y, icon: 'üí•', sz: 24, life: 12, maxLife: 12, vx: 0, vy: 0 });
            GS.projectiles.splice(i, 1); hit = true; break;
          }
        }
      }
      // Boss projectiles
      for (let i = GS.bossProjectiles.length - 1; i >= 0; i--) {
        const pr = GS.bossProjectiles[i]; pr.life--; pr.x += pr.vx; pr.y += pr.vy;
        if (blk(pr.x, pr.y, map) || pr.life <= 0) { GS.bossProjectiles.splice(i, 1); continue; }
        if (dst(pr, p) < p.r + pr.r) {
          damagePlayer(pr.dmg, pr.cls || 'normal');
          GS.atks.push({ worldX: pr.x, worldY: pr.y, icon: 'üí•', sz: 22, life: 10, maxLife: 10, vx: 0, vy: 0 });
          GS.bossProjectiles.splice(i, 1);
        }
      }
      // Boss warnings
      for (let i = GS.bossWarnings.length - 1; i >= 0; i--) { GS.bossWarnings[i].life--; if (GS.bossWarnings[i].life <= 0) GS.bossWarnings.splice(i, 1); }
    }

    // ============================================================
    // PLAYER UPDATE
    // ============================================================
    function updPlayer() {
      const p = GS.p; if (GS.dlgActive) return;
      if (GS.timeStop && GS.timeStopTimer > 0) {
        // Slowed movement during time stop
        let mx = 0, my = 0;
        if (K['ArrowLeft'] || K['KeyA']) mx = -1; if (K['ArrowRight'] || K['KeyD']) mx = 1;
        if (K['ArrowUp'] || K['KeyW']) my = -1; if (K['ArrowDown'] || K['KeyS']) my = 1;
        if (p.vx !== 0 || p.vy !== 0) { mx = p.vx; my = p.vy; }
        if (mx !== 0 || my !== 0) { const mg = Math.sqrt(mx * mx + my * my); mx /= mg; my /= mg; }
        const { map } = GS.map; const slow = 0.4;
        let nx = p.x + mx * p.spd * slow, ny = p.y + my * p.spd * slow;
        if (!blk(nx, p.y, map)) p.x = nx; if (!blk(p.x, ny, map)) p.y = ny;
        GS.cam.x = lerp(GS.cam.x, p.x - canvas.width / 2, 0.1); GS.cam.y = lerp(GS.cam.y, p.y - canvas.height / 2, 0.1);
        GS.cam.x = Math.max(0, Math.min(WW - canvas.width, GS.cam.x)); GS.cam.y = Math.max(0, Math.min(WH - canvas.height, GS.cam.y));
        for (let i = 0; i < 4; i++)if (p.atkCDs[i] > 0) p.atkCDs[i]--;
        if (p.inv > 0) p.inv--;
        if (p.dashCD > 0) { p.dashCD--; updDashBtn(); }
        if (p.invincible) { p.invincibleTimer--; if (p.invincibleTimer <= 0) { p.invincible = false; updDashBtn(); } }
        return;
      }
      for (let i = 0; i < 4; i++)if (p.atkCDs[i] > 0) p.atkCDs[i]--;
      if (p.atkAnim > 0) p.atkAnim--; if (p.inv > 0) p.inv--;
      // Dash cooldown
      if (p.dashCD > 0) { p.dashCD--; updDashBtn(); }
      // Invincibilit√©
      if (p.invincible) {
        p.invincibleTimer--;
        if (p.invincibleTimer <= 0) { p.invincible = false; updDashBtn(); }
      }
      if (p.charging) { p.chargeTime++; if (p.chargeTime > 90) p.chargeTime = 90; }
      let mx = 0, my = 0;
      if (K['ArrowLeft'] || K['KeyA']) mx = -1; if (K['ArrowRight'] || K['KeyD']) mx = 1;
      if (K['ArrowUp'] || K['KeyW']) my = -1; if (K['ArrowDown'] || K['KeyS']) my = 1;
      if (p.vx !== 0 || p.vy !== 0) { mx = p.vx; my = p.vy; }
      if (mx !== 0 || my !== 0) { const mg = Math.sqrt(mx * mx + my * my); mx /= mg; my /= mg; p.fx = mx; p.fy = my; if (GS.frame % 8 === 0) sWalk(); }
      const { map } = GS.map;
      let nx = p.x + mx * p.spd, ny = p.y + my * p.spd;
      if (!blk(nx, p.y, map)) p.x = nx; if (!blk(p.x, ny, map)) p.y = ny;
      p.x = Math.max(TSIZ, Math.min(WW - TSIZ, p.x)); p.y = Math.max(TSIZ, Math.min(WH - TSIZ, p.y));
      if (LEVELS[curLvl].questType === 'collect') {
        const lv = LEVELS[curLvl];
        for (let i = 0; i < GS.qItems.length; i++) {
          const qi = GS.qItems[i];
          if (!qi.collected && dst(p, qi) < 38) {
            qi.collected = true; p.qItems++; sPick(); updHUD();
            const mi = Math.min(i, lv.questMsgs.length - 1); const msg = lv.questMsgs[mi];
            openDlg(msg[0], msg[1], msg.slice(2), null);
            if (p.qItems >= lv.questCount && !GS.bossSpawned) spawnBoss();
          }
        }
      }
      GS.cam.x = lerp(GS.cam.x, p.x - canvas.width / 2, 0.11); GS.cam.y = lerp(GS.cam.y, p.y - canvas.height / 2, 0.11);
      GS.cam.x = Math.max(0, Math.min(WW - canvas.width, GS.cam.x)); GS.cam.y = Math.max(0, Math.min(WH - canvas.height, GS.cam.y));
    }

    // ============================================================
    // RENDER MAP
    // ============================================================
    function renderMap() {
      const { cam, map: { map } } = GS;
      const biome = LEVELS[curLvl].biome;
      const sc = Math.max(0, Math.floor(cam.x / TSIZ) - 1), ec = Math.min(COLS - 1, Math.ceil((cam.x + canvas.width) / TSIZ) + 1);
      const sr = Math.max(0, Math.floor(cam.y / TSIZ) - 1), er = Math.min(ROWS - 1, Math.ceil((cam.y + canvas.height) / TSIZ) + 1);
      for (let r = sr; r <= er; r++)for (let c = sc; c <= ec; c++) {
        const px = Math.round(c * TSIZ - cam.x), py = Math.round(r * TSIZ - cam.y);
        const t = map[r][c];
        C.drawImage(buildTile(t, tileFrame), px, py, TSIZ, TSIZ);
        // Overlay biome pour biomes sombres ‚Äî rend le sol visible
        if (biome === 'webs') {
          if (t === TB.FLOOR) {
            // Sol de toile : l√©g√®re teinte violette-verte pour le distinguer des murs
            C.fillStyle = 'rgba(40,60,30,0.32)';
            C.fillRect(px, py, TSIZ, TSIZ);
          } else if (t === TB.DARK || t === TB.WALL) {
            // Murs : l√©g√®re texture violette pour qu'on voit qu'il y a un mur
            C.fillStyle = 'rgba(60,10,80,0.25)';
            C.fillRect(px, py, TSIZ, TSIZ);
            // Contour subtil pour d√©limiter les murs
            C.strokeStyle = 'rgba(80,20,100,0.18)';
            C.lineWidth = 1;
            C.strokeRect(px+0.5, py+0.5, TSIZ-1, TSIZ-1);
          } else if (t === TB.WATER) {
            // Venin : teinte verte
            C.fillStyle = 'rgba(20,80,10,0.3)';
            C.fillRect(px, py, TSIZ, TSIZ);
          }
        } else if (biome === 'crystal') {
          if (t === TB.FLOOR) {
            // Sol cristallin : l√©g√®re teinte bleue-cyan
            C.fillStyle = 'rgba(0,40,60,0.20)';
            C.fillRect(px, py, TSIZ, TSIZ);
          }
        }
      }
    }

    // ============================================================
    // AMBIENT + DECOS ‚Äî pixel art par biome
    // ============================================================

    // ‚îÄ‚îÄ‚îÄ Particules ambiantes pixel art ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawAmbientParticle(ctx, sx, sy, type, sz, alpha) {
      ctx.save(); ctx.globalAlpha = alpha;
      const f = GS.frame;
      if (type === 'firefly') {
        // Luciole for√™t ‚Äî petit carr√© jaune-vert pulsant
        const p = (Math.sin(f * 0.18) + 1) / 2;
        ctx.fillStyle = `rgba(200,255,80,${0.6 + 0.4 * p})`;
        ctx.shadowColor = '#aaff44'; ctx.shadowBlur = 6 + p * 6;
        ctx.fillRect(sx - sz * 0.4, sy - sz * 0.4, sz * 0.8, sz * 0.8);
        // Trail
        ctx.shadowBlur = 0; ctx.globalAlpha *= 0.3;
        ctx.fillRect(sx - sz * 0.3, sy + sz * 0.3, sz * 0.5, sz * 0.3);
      } else if (type === 'leaf_fall') {
        // Feuille qui tombe ‚Äî losange vert pivotant
        const rot = f * 0.04;
        ctx.translate(sx, sy); ctx.rotate(rot);
        ctx.fillStyle = `rgba(${60 + Math.floor(Math.random() * 20)},160,60,0.8)`;
        ctx.fillRect(-sz * 0.4, -sz * 0.15, sz * 0.8, sz * 0.3);
        ctx.fillRect(-sz * 0.15, -sz * 0.4, sz * 0.3, sz * 0.8);
      } else if (type === 'spark') {
        // √âtincelle ch√¢teau ‚Äî pixel blanc-bleu
        ctx.fillStyle = '#aabbff';
        ctx.shadowColor = '#6688ff'; ctx.shadowBlur = 8;
        ctx.fillRect(sx - 1, sy - 1, 2, 2);
        // croisillon
        ctx.fillRect(sx - 3, sy, 6, 1); ctx.fillRect(sx, sy - 3, 1, 6);
      } else if (type === 'candle') {
        // Flamme chandelle ch√¢teau
        const flicker = Math.sin(f * 0.3 + sz) * 2;
        ctx.fillStyle = '#ffaa00'; ctx.fillRect(sx - 2, sy - 4 + flicker, 4, 6);
        ctx.fillStyle = '#ffee44'; ctx.fillRect(sx - 1, sy - 6 + flicker, 2, 4);
        ctx.fillStyle = 'rgba(255,150,0,0.3)'; ctx.fillRect(sx - 4, sy - 4 + flicker, 8, 8);
      } else if (type === 'snowflake') {
        // Flocon montagne
        ctx.strokeStyle = `rgba(200,230,255,0.8)`; ctx.lineWidth = 1;
        for (let a = 0; a < Math.PI * 2; a += Math.PI / 3) {
          ctx.beginPath();
          ctx.moveTo(sx, sy);
          ctx.lineTo(sx + Math.cos(a) * sz * 0.6, sy + Math.sin(a) * sz * 0.6);
          ctx.stroke();
        }
        ctx.fillStyle = 'rgba(220,240,255,0.9)'; ctx.fillRect(sx - 1, sy - 1, 2, 2);
      } else if (type === 'web_strand') {
        // Fil de toile qui tombe lentement
        ctx.strokeStyle = `rgba(200,220,170,${0.3 + 0.15 * Math.sin(f * 0.06 + sz)})`;
        ctx.lineWidth = 0.8;
        const sway = Math.sin(f * 0.04 + sz) * 3;
        ctx.beginPath();
        ctx.moveTo(sx, sy - sz);
        ctx.quadraticCurveTo(sx + sway, sy, sx + sway * 0.5, sy + sz); ctx.stroke();
        // Petite araign√©e au bout du fil
        ctx.fillStyle = `rgba(20,15,20,${0.6 + 0.2 * Math.sin(f * 0.1)})`;
        ctx.beginPath(); ctx.arc(sx + sway * 0.5, sy + sz, 2, 0, Math.PI * 2); ctx.fill();
      } else if (type === 'web_spore') {
        // Spore lumineuse verte (venin en suspension)
        const glow = (Math.sin(f * 0.11 + sz) + 1) * 0.5;
        ctx.fillStyle = `rgba(60,220,40,${0.15 + 0.25 * glow})`;
        ctx.shadowColor = '#40ff20'; ctx.shadowBlur = 6 + glow * 6;
        ctx.beginPath(); ctx.arc(sx, sy, sz * 0.35, 0, Math.PI * 2); ctx.fill();
        ctx.shadowBlur = 0;
        // Point central
        ctx.fillStyle = `rgba(180,255,100,${0.5 + 0.3 * glow})`;
        ctx.fillRect(sx - 1, sy - 1, 2, 2);
      }
      ctx.restore();
    }

    function renderAmbient() {
      const { cam, ambient } = GS;
      const biome = LEVELS[curLvl].biome;
      for (const p of ambient) {
        p.y -= p.spd * 0.3; if (p.y < 0) p.y = WH;
        p.x += Math.sin(GS.frame * 0.01 + p.off) * 0.3;
        const sx = p.x - cam.x, sy = p.y - cam.y;
        if (sx < -30 || sx > canvas.width + 30 || sy < -30 || sy > canvas.height + 30) continue;
        const a = p.alpha * (0.5 + 0.5 * Math.sin(GS.frame * 0.03 + p.off));
        // Utiliser le type stock√© dans la particule
        const type = p.icon || 'firefly';
        drawAmbientParticle(C, sx, sy, type, p.sz, a);
      }
    }

    // ‚îÄ‚îÄ‚îÄ D√©cors pixel art par biome ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawDecoForest(ctx, sx, sy, bob, scale) {
      const s = Math.max(1, Math.round(scale * TSIZ * 0.75 / 16));
      const t = GS.frame;
      const variant = Math.floor((sx * 7 + sy * 13) % 5);
      if (variant === 0) {
        // Champignon
        ctx.fillStyle = '#cc3333'; ctx.beginPath(); ctx.arc(sx, sy - s * 3 + bob, s * 3, Math.PI, 0); ctx.fill();
        ctx.fillStyle = '#ff6666'; ctx.fillRect(sx - s, sy - s * 3 + bob, s, s); ctx.fillRect(sx + s, sy - s * 4 + bob, s, s);
        ctx.fillStyle = '#e8d0b0'; ctx.fillRect(sx - s, sy - s * 3 + bob, s * 2, s * 4);
        ctx.fillStyle = '#c0a888'; ctx.fillRect(sx - s * 2, sy + bob, s * 4, s);
      } else if (variant === 1) {
        // Fleur rose
        for (let i = 0; i < 5; i++) {
          const a = (i / 5) * Math.PI * 2 + t * 0.01;
          ctx.fillStyle = i % 2 === 0 ? '#ff88aa' : '#ffaabb';
          ctx.fillRect(sx + Math.cos(a) * s * 2 - s, sy - s * 3 + Math.sin(a) * s * 2 + bob, s * 2, s * 2);
        }
        ctx.fillStyle = '#ffee44'; ctx.fillRect(sx - s, sy - s * 3 - s + bob, s * 2, s * 2);
        ctx.fillStyle = '#2a8040'; ctx.fillRect(sx, sy - s * 2 + bob, s, s * 3);
      } else if (variant === 2) {
        // Rocher moussu
        ctx.fillStyle = '#5a5a4a'; ctx.fillRect(sx - s * 3, sy - s * 2 + bob, s * 6, s * 3);
        ctx.fillStyle = '#6a6a58'; ctx.fillRect(sx - s * 2, sy - s * 3 + bob, s * 4, s);
        ctx.fillStyle = '#2a8040'; ctx.fillRect(sx - s * 3, sy - s * 3 + bob, s * 3, s);
        ctx.fillRect(sx + s, sy - s * 4 + bob, s * 2, s);
        ctx.fillStyle = 'rgba(255,255,255,0.18)'; ctx.fillRect(sx - s * 2, sy - s * 3 + bob, s * 2, s);
      } else if (variant === 3) {
        // Petit arbre touffu
        ctx.fillStyle = '#4a2e10'; ctx.fillRect(sx - s, sy + bob, s * 2, s * 4);
        ctx.fillStyle = '#1a5010'; ctx.fillRect(sx - s * 4, sy - s * 5 + bob, s * 8, s * 6);
        ctx.fillStyle = '#2a7020'; ctx.fillRect(sx - s * 3, sy - s * 7 + bob, s * 6, s * 4);
        ctx.fillStyle = '#3a9030'; ctx.fillRect(sx - s * 2, sy - s * 8 + bob, s * 4, s * 3);
        ctx.fillStyle = '#1a4010'; ctx.fillRect(sx - s * 2, sy - s * 4 + bob, s * 4, s);
      } else {
        // Buisson baies
        ctx.fillStyle = '#1a5010'; ctx.fillRect(sx - s * 3, sy - s * 3 + bob, s * 6, s * 4);
        ctx.fillStyle = '#2a7020'; ctx.fillRect(sx - s * 2, sy - s * 4 + bob, s * 4, s * 2);
        // Baies rouges
        for (let i = 0; i < 4; i++) {
          ctx.fillStyle = '#cc2222';
          ctx.beginPath(); ctx.arc(sx - s * 2 + i * s * 1.3, sy - s * 2 + bob, s * 0.8, 0, Math.PI * 2); ctx.fill();
        }
      }
    }

    function drawDecoCastle(ctx, sx, sy, bob, scale) {
      const s = Math.max(1, Math.round(scale * TSIZ * 0.75 / 16));
      const t = GS.frame;
      const variant = Math.floor((sx * 11 + sy * 7) % 5);
      if (variant === 0) {
        // Chandelier mural
        ctx.fillStyle = '#888'; ctx.fillRect(sx - s * 2, sy - s * 6 + bob, s * 4, s);
        ctx.fillStyle = '#c8a020'; ctx.fillRect(sx - s * 2, sy - s * 6 + bob, s * 4, s * 2);
        // 3 bougies
        for (let i = 0; i < 3; i++) {
          const cx = sx - s * 2 + i * s * 2;
          ctx.fillStyle = '#f0d080'; ctx.fillRect(cx - s * 0.5, sy - s * 4 + bob, s, s * 3);
          const flicker = Math.sin(t * 0.3 + i) * 1;
          ctx.fillStyle = '#ffaa00'; ctx.fillRect(cx - s * 0.5, sy - s * 5 + bob + flicker, s, s * 1.5);
          ctx.fillStyle = '#ffee44'; ctx.fillRect(cx - s * 0.3, sy - s * 6 + bob + flicker, s * 0.6, s);
          ctx.fillStyle = `rgba(255,160,0,${0.2 + 0.1 * Math.sin(t * 0.3 + i)})`;
          ctx.beginPath(); ctx.arc(cx, sy - s * 5 + bob + flicker, s * 2, 0, Math.PI * 2); ctx.fill();
        }
      } else if (variant === 1) {
        // Cr√¢ne d√©coratif
        ctx.fillStyle = '#c8c0a8';
        ctx.fillRect(sx - s * 2, sy - s * 4 + bob, s * 4, s * 4);
        ctx.fillRect(sx - s * 3, sy - s * 2 + bob, s * 6, s * 2);
        ctx.fillStyle = '#000'; ctx.fillRect(sx - s * 2, sy - s * 3 + bob, s, s * 2); ctx.fillRect(sx + s, sy - s * 3 + bob, s, s * 2);
        ctx.fillStyle = '#c8c0a8'; ctx.fillRect(sx - s * 2, sy + bob, s, s * 2); ctx.fillRect(sx, sy + bob, s, s * 2); ctx.fillRect(sx + s * 2, sy + bob, s, s * 2);
        ctx.fillStyle = '#aaa'; ctx.fillRect(sx - s * 2, sy - s * 5 + bob, s, s * 2); ctx.fillRect(sx + s, sy - s * 5 + bob, s, s * 2);
      } else if (variant === 2) {
        // Coffre
        ctx.fillStyle = '#6a4010'; ctx.fillRect(sx - s * 3, sy - s * 2 + bob, s * 6, s * 4);
        ctx.fillStyle = '#c8a020'; ctx.fillRect(sx - s * 3, sy - s * 2 + bob, s * 6, s);
        ctx.fillRect(sx - s * 3, sy - s * 2 + bob, s, s * 4);
        ctx.fillRect(sx + s * 2, sy - s * 2 + bob, s, s * 4);
        ctx.fillRect(sx - s * 3, sy + s + bob, s * 6, s);
        ctx.fillStyle = '#ffd700'; ctx.fillRect(sx - s, sy - s + bob, s * 2, s * 2);
        ctx.fillStyle = '#ffee88'; ctx.fillRect(sx - s * 0.5, sy - s * 0.5 + bob, s, s);
      } else if (variant === 3) {
        // Torche murale
        ctx.fillStyle = '#6a4010'; ctx.fillRect(sx - s, sy - s * 6 + bob, s * 2, s * 5);
        ctx.fillStyle = '#888'; ctx.fillRect(sx - s * 2, sy - s * 8 + bob, s * 4, s * 2);
        const fl = Math.sin(t * 0.25) * 1.5;
        ctx.fillStyle = '#ff6600'; ctx.fillRect(sx - s, sy - s * 10 + bob + fl, s * 2, s * 3);
        ctx.fillStyle = '#ffaa00'; ctx.fillRect(sx - s * 0.5, sy - s * 12 + bob + fl, s, s * 3);
        ctx.fillStyle = '#ffee44'; ctx.fillRect(sx - s * 0.3, sy - s * 13 + bob + fl, s * 0.6, s * 2);
        ctx.fillStyle = `rgba(255,120,0,${0.2 + 0.1 * Math.abs(fl)})`;
        ctx.beginPath(); ctx.arc(sx, sy - s * 10 + bob + fl, s * 3, 0, Math.PI * 2); ctx.fill();
      } else {
        // Banni√®re royale
        ctx.fillStyle = '#333'; ctx.fillRect(sx - s * 0.5, sy - s * 8 + bob, s, s * 8);
        ctx.fillStyle = '#8800aa'; ctx.fillRect(sx, sy - s * 7 + bob, s * 4, s * 5);
        ctx.fillStyle = '#aa00cc'; ctx.fillRect(sx + s, sy - s * 6 + bob, s * 2, s * 3);
        ctx.fillStyle = '#ffd700'; ctx.fillRect(sx + s, sy - s * 5 + bob, s * 2, s);
        // Bas frang√©
        for (let i = 0; i < 4; i++) { ctx.fillStyle = '#6600aa'; ctx.fillRect(sx + i * s, sy - s * 2 + bob, s * 0.6, s * 2); }
      }
    }

    function drawDecoMountain(ctx, sx, sy, bob, scale) {
      const s = Math.max(1, Math.round(scale * TSIZ * 0.75 / 16));
      const t = GS.frame;
      const variant = Math.floor((sx * 9 + sy * 17) % 5);
      if (variant === 0) {
        // Cristal de glace
        ctx.fillStyle = '#88ccff'; ctx.fillRect(sx - s, sy - s * 6 + bob, s * 2, s * 6);
        ctx.fillStyle = '#aaddff'; ctx.fillRect(sx - s * 2, sy - s * 4 + bob, s * 4, s * 2);
        // Pointe
        ctx.fillStyle = '#cceeFF';
        ctx.beginPath(); ctx.moveTo(sx, sy - s * 7 + bob); ctx.lineTo(sx - s, sy - s * 6 + bob); ctx.lineTo(sx + s, sy - s * 6 + bob); ctx.closePath(); ctx.fill();
        // Reflet
        const glow = ctx.createLinearGradient(sx, sy - s * 7 + bob, sx, sy + bob);
        glow.addColorStop(0, 'rgba(200,240,255,0.6)'); glow.addColorStop(1, 'rgba(100,180,255,0.1)');
        ctx.fillStyle = glow; ctx.fillRect(sx - s * 2, sy - s * 6 + bob, s, s * 6);
      } else if (variant === 1) {
        // Cairn (empilement de pierres)
        const sizes = [4, 3, 2.5, 1.5];
        for (let i = 0; i < sizes.length; i++) {
          const w = sizes[i] * s; const y = sy + bob - i * s * 2;
          ctx.fillStyle = i % 2 === 0 ? '#7a7a8a' : '#8a8a9a';
          ctx.fillRect(sx - w, y - s * 2, w * 2, s * 2);
          ctx.fillStyle = 'rgba(255,255,255,0.12)'; ctx.fillRect(sx - w, y - s * 2, w * 2, s * 0.5);
        }
      } else if (variant === 2) {
        // Stalactite / stalagmite
        ctx.fillStyle = '#9090a0';
        // stalagmite bas
        ctx.beginPath(); ctx.moveTo(sx - s * 2, sy + bob); ctx.lineTo(sx, sy - s * 5 + bob); ctx.lineTo(sx + s * 2, sy + bob); ctx.closePath(); ctx.fill();
        ctx.fillStyle = '#b0b0c0'; ctx.beginPath(); ctx.moveTo(sx - s, sy + bob); ctx.lineTo(sx, sy - s * 4 + bob); ctx.lineTo(sx + s, sy + bob); ctx.closePath(); ctx.fill();
        ctx.fillStyle = 'rgba(200,220,255,0.3)'; ctx.fillRect(sx - s * 0.5, sy - s * 4 + bob, s * 0.5, s * 4);
      } else if (variant === 3) {
        // Ruines enneig√©es
        ctx.fillStyle = '#6a6a7a'; ctx.fillRect(sx - s * 3, sy + bob, s * 6, s * 2);
        ctx.fillRect(sx - s * 3, sy - s * 5 + bob, s * 2, s * 5);
        ctx.fillRect(sx + s, sy - s * 4 + bob, s * 2, s * 4);
        // Neige sur le dessus
        ctx.fillStyle = '#e8f4ff'; ctx.fillRect(sx - s * 3, sy - s * 5 + bob, s * 6, s);
        ctx.fillRect(sx - s * 3, sy + bob, s * 6, s * 0.5);
        ctx.fillStyle = '#ffffff'; ctx.fillRect(sx - s * 3, sy - s * 5 + bob, s * 2, s * 0.5);
        ctx.fillRect(sx + s, sy - s * 4 + bob, s * 2, s * 0.5);
      } else {
        // Ossements anciens
        ctx.fillStyle = '#d4ccb0';
        // cr√¢ne
        ctx.fillRect(sx - s * 2, sy - s * 4 + bob, s * 4, s * 3);
        ctx.fillRect(sx - s * 3, sy - s * 2 + bob, s * 6, s);
        ctx.fillStyle = '#000'; ctx.fillRect(sx - s * 2, sy - s * 3 + bob, s, s); ctx.fillRect(sx + s, sy - s * 3 + bob, s, s);
        // Os crois√©s
        ctx.fillStyle = '#c8c0a8';
        ctx.save(); ctx.translate(sx, sy + s * 2 + bob); ctx.rotate(0.4);
        ctx.fillRect(-s * 4, -s * 0.5, s * 8, s); ctx.restore();
        ctx.save(); ctx.translate(sx, sy + s * 2 + bob); ctx.rotate(-0.4);
        ctx.fillRect(-s * 4, -s * 0.5, s * 8, s); ctx.restore();
      }
    }

    // ‚îÄ‚îÄ‚îÄ D√©cor Toile (biome webs) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawDecoWebs(ctx, sx, sy, bob, scale) {
      const s = Math.max(1, Math.round(scale * TSIZ * 0.75 / 16));
      const f = GS.frame;
      const variant = Math.floor(Math.abs(sx * 7 + sy * 13)) % 5;

      if (variant === 0) {
        // Grande toile d'araign√©e dans un coin
        const pulse = (Math.sin(f * 0.05 + sx * 0.01) + 1) * 0.5;
        ctx.strokeStyle = `rgba(200,220,180,${0.25 + 0.1 * pulse})`;
        ctx.lineWidth = 0.8;
        // Fils radiaux
        for (let i = 0; i < 8; i++) {
          const a = (i / 8) * Math.PI * 2;
          ctx.beginPath(); ctx.moveTo(sx, sy + bob);
          ctx.lineTo(sx + Math.cos(a) * 18 * s, sy + bob + Math.sin(a) * 18 * s); ctx.stroke();
        }
        // Anneaux concentriques
        for (let r = 4; r <= 18; r += 4) {
          ctx.beginPath(); ctx.arc(sx, sy + bob, r * s, 0, Math.PI * 2); ctx.stroke();
        }
        // Araign√©e au centre
        ctx.fillStyle = '#111';
        ctx.beginPath(); ctx.arc(sx, sy + bob, 2 * s, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#cc1100';
        ctx.fillRect(sx - s, sy + bob, s, 2 * s); // motif ventre

      } else if (variant === 1) {
        // Cr√¢ne pixel art avec toile
        ctx.fillStyle = '#c8c0a0';
        ctx.fillRect(sx - 3 * s, sy - 4 * s + bob, 6 * s, 5 * s); // cr√¢ne
        ctx.fillRect(sx - 4 * s, sy - 2 * s + bob, 8 * s, s);     // maxillaire
        ctx.fillStyle = '#000';
        ctx.fillRect(sx - 2 * s, sy - 3 * s + bob, s, s);           // ≈ìil G
        ctx.fillRect(sx + s, sy - 3 * s + bob, s, s);                // ≈ìil D
        // Petite toile sur le cr√¢ne
        ctx.strokeStyle = 'rgba(200,220,180,0.4)'; ctx.lineWidth = 0.6;
        ctx.beginPath(); ctx.arc(sx - 3 * s, sy - 4 * s + bob, 5 * s, Math.PI, 0); ctx.stroke();

      } else if (variant === 2) {
        // Ossements avec fils de toile
        ctx.fillStyle = '#b8b098';
        ctx.save(); ctx.translate(sx, sy + bob); ctx.rotate(0.3);
        ctx.fillRect(-6 * s, -s * 0.5, 12 * s, s);
        ctx.restore();
        ctx.save(); ctx.translate(sx, sy + bob); ctx.rotate(-0.3);
        ctx.fillRect(-6 * s, -s * 0.5, 12 * s, s);
        ctx.restore();
        // Fils
        ctx.strokeStyle = 'rgba(180,200,160,0.3)'; ctx.lineWidth = 0.7;
        for (let i = 0; i < 3; i++) {
          ctx.beginPath();
          ctx.moveTo(sx - 6 * s + i * 4 * s, sy - 12 * s + bob);
          ctx.lineTo(sx - 4 * s + i * 4 * s, sy + bob); ctx.stroke();
        }

      } else if (variant === 3) {
        // Cocon petit (d√©cor)
        ctx.fillStyle = '#c8d0b0';
        ctx.beginPath(); ctx.ellipse(sx, sy + bob, 4 * s, 6 * s, 0, 0, Math.PI * 2); ctx.fill();
        ctx.strokeStyle = 'rgba(200,220,180,0.5)'; ctx.lineWidth = 0.7;
        for (let i = -2; i <= 2; i++) {
          ctx.beginPath();
          ctx.moveTo(sx - 4 * s, sy + bob + i * 2.5 * s);
          ctx.lineTo(sx + 4 * s, sy + bob + i * 2.5 * s + s); ctx.stroke();
        }
        // Yeux lumineux si pulse √©lev√©
        const p2 = (Math.sin(f * 0.07 + sx) + 1) * 0.5;
        if (p2 > 0.65) {
          ctx.fillStyle = `rgba(60,255,20,${(p2 - 0.65) * 2})`;
          ctx.fillRect(sx - 2 * s, sy + bob - s, s, s);
          ctx.fillRect(sx + s, sy + bob - s, s, s);
        }

      } else {
        // Stalactite de r√©sine / toile qui tombe
        ctx.fillStyle = '#2a2218';
        ctx.fillRect(sx - s, sy - 10 * s + bob, 2 * s, 10 * s);
        // Gouttes
        const dropY = (f * 0.4 + sx) % (10 * s);
        ctx.fillStyle = 'rgba(180,220,80,0.5)';
        ctx.beginPath(); ctx.ellipse(sx, sy - 10 * s + bob + dropY, s * 0.8, s, 0, 0, Math.PI * 2); ctx.fill();
        // Toile autour
        ctx.strokeStyle = 'rgba(200,220,180,0.25)'; ctx.lineWidth = 0.7;
        for (let i = 0; i < 4; i++) {
          const a = i * 0.7;
          ctx.beginPath();
          ctx.moveTo(sx, sy - 8 * s + bob);
          ctx.lineTo(sx + Math.cos(a) * 10 * s, sy - 8 * s + bob + Math.sin(a) * 6 * s); ctx.stroke();
        }
      }
    }

    function renderDecos() {
      const { cam, decos } = GS;
      const biome = LEVELS[curLvl].biome;
      for (const d of decos) {
        const sx = d.x - cam.x, sy = d.y - cam.y;
        if (sx < -TSIZ * 3 || sx > canvas.width + TSIZ * 3 || sy < -TSIZ * 3 || sy > canvas.height + TSIZ * 3) continue;
        const bob = Math.sin(GS.frame * 0.022 + d.off) * 1.5;
        C.save(); C.globalAlpha = 0.85;
        if (biome === 'forest') drawDecoForest(C, sx, sy, bob, d.scale);
        else if (biome === 'castle') drawDecoCastle(C, sx, sy, bob, d.scale);
        else if (biome === 'webs') drawDecoWebs(C, sx, sy, bob, d.scale);
        else drawDecoMountain(C, sx, sy, bob, d.scale);
        C.restore();
      }
    }

    // ============================================================
    // QUEST ITEMS
    // ============================================================

    // ‚îÄ‚îÄ‚îÄ Dessin pixel art : Cocon d'araign√©e ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawCocon(ctx, cx, cy, bob) {
      const f = GS.frame;
      const pulse = (Math.sin(f * 0.08) + 1) * 0.5;
      const s = 1;

      ctx.save(); ctx.translate(cx, cy + bob);

      // Lueur verte malsaine
      const glow = ctx.createRadialGradient(0, 0, 2, 0, 0, 28);
      glow.addColorStop(0, `rgba(60,200,30,${0.18 + 0.12 * pulse})`);
      glow.addColorStop(1, 'transparent');
      ctx.fillStyle = glow; ctx.beginPath(); ctx.arc(0, 0, 28, 0, Math.PI * 2); ctx.fill();

      // Fils de toile autour (7 fils en √©toile)
      ctx.strokeStyle = `rgba(200,220,180,${0.25 + 0.1 * pulse})`;
      ctx.lineWidth = 0.8;
      for (let i = 0; i < 7; i++) {
        const a = (i / 7) * Math.PI * 2;
        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(Math.cos(a) * 22, Math.sin(a) * 22); ctx.stroke();
      }
      // Anneaux concentriques de toile
      for (let r = 6; r <= 20; r += 5) {
        ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.stroke();
      }

      // Corps du cocon (forme ovo√Øde)
      ctx.fillStyle = '#d4ddc0';
      ctx.beginPath(); ctx.ellipse(0, 0, 9, 13, 0, 0, Math.PI * 2); ctx.fill();

      // Bandages de toile (stries diagonales)
      ctx.strokeStyle = `rgba(180,200,160,0.85)`;
      ctx.lineWidth = 1.5;
      for (let i = -3; i <= 3; i++) {
        ctx.beginPath();
        ctx.moveTo(-9, i * 3.5);
        ctx.lineTo(9, i * 3.5 + 4); ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(-9, i * 3.5);
        ctx.lineTo(9, i * 3.5 - 4); ctx.stroke();
      }
      // Clip ellipse
      ctx.save();
      ctx.globalCompositeOperation = 'destination-in';
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.ellipse(0, 0, 9, 13, 0, 0, Math.PI * 2); ctx.fill();
      ctx.restore();

      // Ombre ventrale
      ctx.fillStyle = 'rgba(80,100,60,0.35)';
      ctx.beginPath(); ctx.ellipse(0, 4, 7, 9, 0, 0, Math.PI * 2); ctx.fill();

      // Reflet lumineux
      ctx.fillStyle = `rgba(255,255,240,${0.3 + 0.15 * pulse})`;
      ctx.beginPath(); ctx.ellipse(-2, -5, 3, 5, -0.4, 0, Math.PI * 2); ctx.fill();

      // Yeux qui pulsent dans la fente (chose vivante dedans...)
      if (pulse > 0.5) {
        ctx.fillStyle = `rgba(80,255,20,${(pulse - 0.5) * 1.6})`;
        ctx.fillRect(-4, -1, 3, 2);
        ctx.fillRect(1, -1, 3, 2);
      }

      // Petite araign√©e gardienne pos√©e dessus
      const legO = Math.floor(f / 8) % 2;
      ctx.fillStyle = '#111';
      ctx.beginPath(); ctx.arc(0, -14, 3, 0, Math.PI * 2); ctx.fill(); // corps
      ctx.fillStyle = '#222';
      ctx.beginPath(); ctx.arc(0, -17, 2, 0, Math.PI * 2); ctx.fill(); // t√™te
      // yeux micro
      ctx.fillStyle = '#44ffaa';
      ctx.fillRect(-2, -18, 1, 1); ctx.fillRect(1, -18, 1, 1);
      // pattes mini
      ctx.strokeStyle = '#333'; ctx.lineWidth = 0.8;
      for (let i = 0; i < 4; i++) {
        const side = i < 2 ? -1 : 1;
        const y = -16 + (i % 2) * 2 + legO;
        ctx.beginPath();
        ctx.moveTo(side * 2, -14);
        ctx.lineTo(side * (6 + i % 2 * 2), y);
        ctx.stroke();
      }

      ctx.restore();
    }

    function renderQItems() {
      const { cam, qItems } = GS; const lv = LEVELS[curLvl];
      C.textAlign = 'center'; C.textBaseline = 'middle';
      for (const qi of qItems) {
        if (qi.collected) continue;
        const sx = qi.x - cam.x, sy = qi.y - cam.y;
        if (Math.abs(sx) > canvas.width / 2 + 80 || Math.abs(sy) > canvas.height / 2 + 80) continue;
        const bob = Math.sin(GS.frame * 0.07 + qi.x) * 6;

        const qi2 = lv.questItem;

        // Cocon : rendu sp√©cial sans halo dor√©
        if (qi2 === 'üï∏Ô∏è') {
          drawCocon(C, sx, sy, bob);
          continue;
        }

        // Halo dor√© g√©n√©rique
        const ag = C.createRadialGradient(sx, sy + bob, 0, sx, sy + bob, 30);
        ag.addColorStop(0, 'rgba(255,215,0,0.4)'); ag.addColorStop(1, 'transparent');
        C.fillStyle = ag; C.beginPath(); C.arc(sx, sy + bob, 30, 0, Math.PI * 2); C.fill();
        C.save(); C.shadowColor = '#ffd700'; C.shadowBlur = 22;
        // Dessin pixel art selon le type d'objet de qu√™te
        if (qi2 === 'ü•á') {
          // M√©daillon dor√©
          C.fillStyle = '#ffd700'; C.beginPath(); C.arc(sx, sy + bob, 10, 0, Math.PI * 2); C.fill();
          C.fillStyle = '#cc8800'; C.beginPath(); C.arc(sx, sy + bob, 10, 0, Math.PI * 2); C.stroke();
          C.strokeStyle = '#cc8800'; C.lineWidth = 2; C.stroke();
          C.fillStyle = '#ffee88'; C.fillRect(sx - 3, sy + bob - 4, 6, 8);
          C.fillStyle = '#cc8800'; C.fillRect(sx - 1, sy + bob - 6, 2, 3);
          C.fillStyle = '#ffee88'; C.fillRect(sx - 1, sy + bob - 1, 2, 2);
        } else if (qi2 === 'üíÄ') {
          // Cr√¢ne (pour les kills)
          C.fillStyle = '#e8e0c8';
          C.fillRect(sx - 7, sy + bob - 8, 14, 12);
          C.fillRect(sx - 5, sy + bob - 10, 10, 5);
          C.fillStyle = '#000'; C.fillRect(sx - 5, sy + bob - 8, 4, 4); C.fillRect(sx + 1, sy + bob - 8, 4, 4);
          C.fillStyle = '#e8e0c8'; C.fillRect(sx - 4, sy + bob + 3, 2, 3); C.fillRect(sx - 1, sy + bob + 3, 2, 3); C.fillRect(sx + 2, sy + bob + 3, 2, 3);
        } else if (qi2 === '‚≠ê') {
          // √âtoile or 5 branches
          C.fillStyle = '#ffd700';
          const starR = 12, starr = 5;
          C.beginPath();
          for (let i = 0; i < 10; i++) {
            const r2 = i % 2 === 0 ? starR : starr;
            const a = (i / 10) * Math.PI * 2 - Math.PI / 2;
            if (i === 0) C.moveTo(sx + Math.cos(a) * r2, sy + bob + Math.sin(a) * r2);
            else C.lineTo(sx + Math.cos(a) * r2, sy + bob + Math.sin(a) * r2);
          }
          C.closePath(); C.fill();
          C.fillStyle = '#ffe066'; C.fillRect(sx - 2, sy + bob - 4, 4, 4);
        } else {
          // Fallback g√©n√©rique : diamant brillant
          C.fillStyle = '#aaddff';
          C.beginPath(); C.moveTo(sx, sy + bob - 10); C.lineTo(sx + 8, sy + bob); C.lineTo(sx, sy + bob + 10); C.lineTo(sx - 8, sy + bob); C.closePath(); C.fill();
          C.fillStyle = '#fff'; C.fillRect(sx - 2, sy + bob - 5, 3, 3);
        }
        C.restore();
      }
    }

    // ============================================================
    // BOSS WARNINGS RENDER
    // ============================================================
    function renderBossWarnings() {
      const { cam } = GS;
      for (const w of GS.bossWarnings) {
        const sx = w.x - cam.x, sy = w.y - cam.y;
        const alpha = (w.life / w.maxLife) * 0.75;
        const pulse = Math.sin(GS.frame * 0.4) * 0.3;
        C.save();
        if (w.type === 'slam_zone') {
          // Aerial slam danger zone ‚Äî filled red circle + concentric rings
          const a = Math.max(0, alpha * 0.55 + pulse * 0.2);
          const rg = C.createRadialGradient(sx, sy, 0, sx, sy, w.r);
          rg.addColorStop(0, `rgba(255,60,0,${a * 0.6})`); rg.addColorStop(0.7, `rgba(255,20,0,${a * 0.3})`); rg.addColorStop(1, 'transparent');
          C.fillStyle = rg; C.beginPath(); C.arc(sx, sy, w.r, 0, Math.PI * 2); C.fill();
          C.strokeStyle = w.color; C.lineWidth = 4; C.globalAlpha = a + 0.2;
          C.shadowColor = '#ff0000'; C.shadowBlur = 18;
          C.setLineDash([8, 4]); C.beginPath(); C.arc(sx, sy, w.r, 0, Math.PI * 2); C.stroke();
          C.setLineDash([]);
          // Inner target cross
          C.strokeStyle = `rgba(255,200,0,${a + 0.1})`; C.lineWidth = 2; C.shadowBlur = 10;
          C.beginPath(); C.moveTo(sx - 16, sy); C.lineTo(sx + 16, sy); C.stroke();
          C.beginPath(); C.moveTo(sx, sy - 16); C.lineTo(sx, sy + 16); C.stroke();
        } else if (w.type === 'warn_zone') {
          // Boss 2 approach warning ‚Äî pulsing orange ring
          C.strokeStyle = w.color; C.lineWidth = 4; C.globalAlpha = (alpha + pulse) * 0.8;
          C.shadowColor = w.color; C.shadowBlur = 20;
          C.setLineDash([12, 8]);
          C.beginPath(); C.arc(sx, sy, w.r, 0, Math.PI * 2); C.stroke();
          C.setLineDash([]);
          // "DANGER" text pulsing
          if (Math.floor(GS.frame / 6) % 2 === 0) {
            C.globalAlpha = 0.9; C.fillStyle = '#ff8800'; C.shadowBlur = 12;
            C.font = '7px "Press Start 2P"'; C.textAlign = 'center'; C.textBaseline = 'middle';
            C.fillText('‚ö† DANGER ‚ö†', sx, sy - w.r - 12);
          }
        } else if (w.type === 'beam_warn') {
          // Directional warning ‚Äî shows beam trajectory before it fires
          const blink = Math.floor(GS.frame / 5) % 2 === 0;
          if (blink) {
            C.globalAlpha = (alpha + pulse) * 0.7;
            C.strokeStyle = '#ff2200'; C.lineWidth = 6; C.shadowColor = '#ff0000'; C.shadowBlur = 20;
            C.setLineDash([14, 8]);
            C.beginPath(); C.moveTo(sx, sy);
            C.lineTo(sx + Math.cos(w.angle) * w.r, sy + Math.sin(w.angle) * w.r);
            C.stroke(); C.setLineDash([]);
            // "LASER" label
            C.font = '7px "Press Start 2P"'; C.fillStyle = '#ff4400'; C.textAlign = 'center'; C.textBaseline = 'middle';
            C.fillText('‚ö° LASER ‚ö°', sx + Math.cos(w.angle) * w.r * 0.5, sy + Math.sin(w.angle) * w.r * 0.5 - 14);
          }
        } else if (w.type === 'circle') {
          C.strokeStyle = w.color; C.lineWidth = 3; C.globalAlpha = alpha + pulse;
          C.shadowColor = w.color; C.shadowBlur = 12;
          C.setLineDash([6, 4]);
          C.beginPath(); C.arc(sx, sy, w.r, 0, Math.PI * 2); C.stroke();
          C.setLineDash([]);
        } else {
          C.strokeStyle = w.color; C.lineWidth = 2; C.globalAlpha = alpha + pulse;
          C.shadowColor = w.color; C.shadowBlur = 10;
          C.beginPath(); C.arc(sx, sy, w.r, 0, Math.PI * 2); C.stroke();
        }
        C.restore();
      }
    }

    // ============================================================
    // BOSS BEAM RENDER
    // ============================================================
    function renderBossBeam() {
      const { boss, cam } = GS; if (!boss || !boss.beamActive || boss.beamTimer <= 0) return;
      const sx = boss.x - cam.x, sy = boss.y - cam.y;
      const len = 500;
      const ex = sx + Math.cos(boss.beamAngle) * len, ey = sy + Math.sin(boss.beamAngle) * len;
      const alpha = Math.min(1, boss.beamTimer / 15);
      C.save();
      // Outer glow
      C.globalAlpha = alpha * 0.25; C.strokeStyle = '#ff4400'; C.lineWidth = 28; C.shadowColor = '#ff4400'; C.shadowBlur = 30;
      C.beginPath(); C.moveTo(sx, sy); C.lineTo(ex, ey); C.stroke();
      // Core
      C.globalAlpha = alpha * 0.9; C.strokeStyle = '#fff'; C.lineWidth = 4; C.shadowBlur = 15;
      C.beginPath(); C.moveTo(sx, sy); C.lineTo(ex, ey); C.stroke();
      C.restore();
    }

    // ============================================================
    // MONSTERS RENDER
    // ============================================================

    // ‚îÄ‚îÄ‚îÄ Helper : aura d'√©tat anim√© sous le monstre ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawMonsterStateAura(ctx, sx, sy, m, alpha) {
      const f = GS.frame;
      const state = m.state;
      const r = (m.r || 14) * 1.4;

      if (state === 'aggro' || state === 'attack') {
        // Aura rouge pulsante en aggro
        const pulse = (Math.sin(f * 0.22) + 1) * 0.5;
        ctx.save(); ctx.globalAlpha = alpha * (0.35 + 0.25 * pulse);
        const ag = ctx.createRadialGradient(sx, sy, 0, sx, sy, r * 1.8);
        ag.addColorStop(0, 'rgba(255,30,0,0.6)');
        ag.addColorStop(0.6, 'rgba(200,0,0,0.2)');
        ag.addColorStop(1, 'transparent');
        ctx.fillStyle = ag; ctx.beginPath(); ctx.arc(sx, sy, r * 1.8, 0, Math.PI * 2); ctx.fill();
        // Petites √©tincelles de rage tournant autour
        const numSparks = 5;
        for (let i = 0; i < numSparks; i++) {
          const a = (i / numSparks) * Math.PI * 2 + f * 0.08;
          const sparkR = r * (1.1 + 0.2 * Math.sin(f * 0.15 + i));
          const px = sx + Math.cos(a) * sparkR, py = sy + Math.sin(a) * sparkR;
          ctx.globalAlpha = alpha * (0.6 + 0.4 * pulse);
          ctx.fillStyle = i % 2 === 0 ? '#ff4400' : '#ffaa00';
          ctx.shadowColor = '#ff3300'; ctx.shadowBlur = 5;
          ctx.fillRect(px - 2, py - 2, 3, 3);
        }
        ctx.restore();
      } else if (state === 'idle' || state === 'wander') {
        // L√©g√®re respiration sous l'ennemi ‚Äî shadow douce
        const breathe = (Math.sin(f * 0.05 + m.x * 0.01) + 1) * 0.5;
        ctx.save(); ctx.globalAlpha = alpha * (0.08 + 0.06 * breathe);
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.beginPath(); ctx.ellipse(sx, sy + r * 0.6, r * 0.9, r * 0.3, 0, 0, Math.PI * 2); ctx.fill();
        ctx.restore();
      }
    }

    function renderMons() {
      const { cam, mons, boss } = GS; const all = [...mons]; if (boss) all.push(boss);
      for (const m of all) {
        if (m.state === 'dead') continue;
        const sx = m.x - cam.x, sy = m.y - cam.y;
        if (sx < -140 || sx > canvas.width + 140 || sy < -140 || sy > canvas.height + 140) continue;
        const dying = m.state === 'dying';
        const alpha = dying ? Math.max(0, m.dyingTimer / 22) : 1;
        const bob = dying ? 0 : Math.sin(GS.frame * 0.07 + m.x * 0.01) * 2;

        // Aura d'√©tat pour les monstres normaux (pas boss)
        if (!m.boss && !dying) drawMonsterStateAura(C, sx, sy + bob, m, alpha);

        C.save();
        C.globalAlpha = alpha;
        if (m.hitFlash > 0) C.filter = 'brightness(3.5) saturate(0)';

        // Scale animation par √©tat (respiration / rage)

        const frame = getMonFrame(m);
        const dir = getMonDir(m);

        if (m.boss) {
          // ‚îÄ‚îÄ BOSS ‚îÄ‚îÄ
          const aerialOff = m.aerialYOff || 0;
          const lvlType = getBossType(curLvl);

          if (m.boss && aerialOff < -10) {
            // ombre au sol pendant le vol
            C.save();
            C.globalAlpha *= (0.15 + 0.3 * (1 - Math.abs(aerialOff) / 80));
            C.filter = 'blur(6px) brightness(0)';
            C.translate(sx + 5, sy + 8 + bob);
            C.scale(1, 0.3);
            if (lvlType === 'demon') drawDemon(C, 0, 0, dir, frame, 2.8, 1, m.rageMode);
            else if (lvlType === 'king') drawKingDoubt(C, 0, 0, dir, frame, 2.8, 1, m.rageMode);
            else if (lvlType === 'spider') drawSpider(C, 0, 0, frame, 2.8, 1, m.rageMode);
            else if (lvlType === 'crystal') drawCrystal(C, 0, 0, dir, frame, 2.8, 1, m.rageMode);
            else drawDragon(C, 0, 0, dir, frame, 3.2, 1, m.rageMode, 0);
            C.restore();
          }

          if (lvlType === 'demon') drawDemon(C, sx, sy + bob + aerialOff, dir, frame, 2.8, 1, m.rageMode);
          else if (lvlType === 'king') drawKingDoubt(C, sx, sy + bob + aerialOff, dir, frame, 2.8, 1, m.rageMode);
          else if (lvlType === 'spider') drawSpider(C, sx, sy + bob + aerialOff, frame, 2.8, 1, m.rageMode);
          else if (lvlType === 'crystal') drawCrystal(C, sx, sy + bob + aerialOff, dir, frame, 2.8, 1, m.rageMode);
          else drawDragon(C, sx, sy + bob, dir, frame, 3.2, 1, m.rageMode, aerialOff);

          // Aura boss
          C.save(); C.globalAlpha = alpha * (m.rageMode ? 0.35 : 0.18);
          const rageT = m.rageMode ? 0.22 : 0;
          const bg = C.createRadialGradient(sx, sy, 5, sx, sy, 70);
          bg.addColorStop(0, `rgba(255,${m.rageMode ? 30 : 80},50,${0.18 + rageT})`);
          bg.addColorStop(1, 'transparent');
          C.fillStyle = bg; C.beginPath(); C.arc(sx, sy, 70, 0, Math.PI * 2); C.fill();
          C.restore();

          if (m.rageMode) {
            C.save(); C.globalAlpha = alpha * 0.6; C.strokeStyle = '#ff2200'; C.lineWidth = 3;
            C.shadowColor = '#ff2200'; C.shadowBlur = 18;
            C.beginPath(); C.arc(sx, sy, 60 + Math.sin(GS.frame * 0.2) * 5, 0, Math.PI * 2); C.stroke();
            C.restore();
          }

        } else {
          // ‚îÄ‚îÄ MONSTRES NORMAUX ‚îÄ‚îÄ animations sp√©cifiques par type
          const type = getMonsterType(m);
          const f = GS.frame;
          const isAggro = m.state === 'aggro' || m.state === 'attack';

          C.save();
          C.translate(sx, sy + bob);

          if (type === 'wolf') {
            // Le loup : tremblement de t√™te en aggro
            if (isAggro) {
              const shk = Math.sin(f * 0.55) * 1.8;
              C.translate(shk, 0);
            }
            drawWolf(C, 0, 0, dir, frame, 1.8, 1);

          } else if (type === 'bat') {
            // La chauve-souris : flap rapide en aggro, lent en idle
            const batFrame = isAggro ? Math.floor(f / 3) % 2 : Math.floor(f / 8) % 2;
            // Oscillation verticale
            const batFloat = Math.sin(f * (isAggro ? 0.25 : 0.08)) * (isAggro ? 5 : 2);
            C.translate(0, batFloat);
            drawBat(C, 0, 0, batFrame, 1.5, 1);

          } else if (type === 'spider') {
            // L'araign√©e : tremble et grossit en aggro
            if (isAggro) {
              const spScale = 1 + Math.abs(Math.sin(f * 0.3)) * 0.1;
              C.scale(spScale, spScale);
            }
            drawSpiderMob(C, 0, 0, frame % 2, 1.5, 1);

          } else if (type === 'leaf') {
            // L'entit√© feuille : rotation oscillante
            const leafRot = Math.sin(f * 0.06 + m.x * 0.01) * (isAggro ? 0.25 : 0.10);
            C.rotate(leafRot);
            drawLeafMonster(C, 0, 0, frame % 2, 1.7, 1);

          } else if (type === 'skeleton') {
            // Le squelette : claque des dents (micro-bob de t√™te) en idle, se recroqueville en aggro
            if (isAggro) {
              C.translate(Math.sin(f * 0.4) * 2, 0);
            }
            drawSkeleton(C, 0, 0, dir, frame, 1.8, 1);

          } else if (type === 'zombie') {
            // Le zombie : mouvement saccad√©
            if (isAggro) {
              const jerk = Math.floor(f / 4) % 3 === 0 ? 2 : 0;
              C.translate(jerk, 0);
            }
            drawZombie(C, 0, 0, dir, frame, 1.8, 1);

          } else if (type === 'ghost') {
            // Le fant√¥me : oscillation sinuso√Ødale + stretch en aggro
            if (isAggro) {
              const stretch = 1 + Math.sin(f * 0.2) * 0.12;
              C.scale(1 / stretch, stretch);
            }
            drawGhost(C, 0, 0, frame % 2, 1.7, 1);

          } else if (type === 'knight') {
            // Le chevalier : pas lourd, tremble en aggro
            if (isAggro) {
              C.translate(0, Math.abs(Math.sin(f * 0.18)) * -2);
            }
            drawKnight(C, 0, 0, dir, frame, 1.8, 1);

          } else if (type === 'iceGiant') {
            // Le g√©ant de glace : rotation lente imposante
            const iceSwing = Math.sin(f * 0.04) * (isAggro ? 0.12 : 0.04);
            C.rotate(iceSwing);
            drawIceGiant(C, 0, 0, dir, frame, 2.0, 1);

          } else if (type === 'griffon') {
            // Le griffon : battement d'ailes + saut en aggro
            if (isAggro) {
              C.translate(0, Math.sin(f * 0.3) * -4);
            }
            drawGriffon(C, 0, 0, dir, frame, 1.7, 1);

          } else if (type === 'golem') {
            // Le golem : tremblement lent
            const golemShk = isAggro ? Math.sin(f * 0.22) * 3 : 0;
            C.translate(golemShk, 0);
            drawGolem(C, 0, 0, dir, frame, 2.0, 1);

          } else if (type === 'elemental') {
            // L'√©l√©mental : rotation + pulsation
            const elRot = f * (isAggro ? 0.04 : 0.015);
            C.rotate(elRot);
            drawElemental(C, 0, 0, frame % 2, 1.7, 1);

          } else if (type === 'spiderVenom') {
            // Araign√©e v√©n√©neuse : tremble et pulse en vert
            if (isAggro) {
              const spScale = 1 + Math.abs(Math.sin(f * 0.4)) * 0.15;
              C.scale(spScale, spScale);
            }
            C.filter = 'hue-rotate(80deg) saturate(2) brightness(1.2)';
            drawSpiderMob(C, 0, 0, frame % 2, 1.6, 1);

          } else if (type === 'scorpion') {
            // Scorpion g√©ant : marche lourde, queue dress√©e en aggro
            if (isAggro) {
              C.translate(0, Math.abs(Math.sin(f * 0.18)) * -3);
            }
            // Scorpion dessin√© via un squelette re-color√© en orange/brun
            C.filter = 'hue-rotate(30deg) saturate(2.5) brightness(0.85)';
            drawSkeleton(C, 0, 0, dir, frame, 1.6, 1);

          } else if (type === 'beetle') {
            // Col√©opt√®re sombre : golem lent re-color√© en violet fonc√©
            const beetleShk = isAggro ? Math.sin(f * 0.18) * 2 : 0;
            C.translate(beetleShk, 0);
            C.filter = 'hue-rotate(270deg) saturate(2) brightness(0.75)';
            drawGolem(C, 0, 0, dir, frame, 1.7, 1);

          } else if (type === 'cricket') {
            // Chasseur silencieux : bat rapide + tr√®s agile
            const cricketFloat = Math.sin(f * (isAggro ? 0.35 : 0.1)) * (isAggro ? 6 : 2);
            C.translate(0, cricketFloat);
            C.filter = 'hue-rotate(180deg) saturate(1.8) brightness(1.1)';
            drawBat(C, 0, 0, frame % 2, 1.6, 1);

          } else if (type === 'eclatVivant') {
            // √âclat Vivant : oscillation + rotation l√©g√®re
            const elv = Math.sin(f * (isAggro ? 0.2 : 0.07)) * (isAggro ? 4 : 2);
            C.translate(0, elv);
            if (isAggro) { const spScale = 1 + Math.abs(Math.sin(f * 0.25)) * 0.15; C.scale(spScale, spScale); }
            drawEclatVivant(C, 0, 0, dir, frame, 1.6, 1);

          } else if (type === 'golemCristal') {
            // Golem de Cristal : pas lourd, tremblement imposant en aggro
            if (isAggro) { C.translate(0, Math.abs(Math.sin(f * 0.15)) * -2); }
            const gShk = isAggro ? Math.sin(f * 0.2) * 2 : 0;
            C.translate(gShk, 0);
            drawGolemCristal(C, 0, 0, dir, frame, 1.8, 1);

          } else if (type === 'lueurPrismatique') {
            // Lueur Prismatique : flottement rapide en aggro
            const lFloat = Math.sin(f * (isAggro ? 0.28 : 0.09)) * (isAggro ? 5 : 2);
            C.translate(0, lFloat);
            if (isAggro) { const lScale = 1 + Math.sin(f * 0.18) * 0.1; C.scale(lScale, lScale); }
            drawLueurPrismatique(C, 0, 0, frame % 2, 1.5, 1);

          } else if (type === 'vortexVerre') {
            // Vortex de Verre : spin rapide en aggro
            if (isAggro) {
              const vRot = Math.sin(f * 0.12) * 0.18;
              C.rotate(vRot);
            }
            drawVortexVerre(C, 0, 0, frame % 2, 1.6, 1);

          } else {
            C.textAlign = 'center'; C.textBaseline = 'middle';
            C.font = '20px serif'; C.fillStyle = '#fff'; C.fillText('?', 0, 0);
          }

          C.restore();

        } // fin else monstres normaux

        C.restore(); // restore du C.save() principal du monstre

        // HP bar ‚Äî visible si HP < max OU si en aggro/attaque
        const showHp = !dying && (m.hp < m.maxHp || m.state === 'aggro' || m.state === 'attack');
        if (showHp) {
          const bw = m.boss ? 72 : 38, bh = m.boss ? 9 : 5;
          const bx = sx - bw / 2, by = sy - (m.boss ? 55 : 28);
          const hpAlpha = m.hp < m.maxHp ? 1 : (0.5 + 0.5 * Math.sin(GS.frame * 0.2));
          C.save(); C.globalAlpha = hpAlpha;
          C.fillStyle = 'rgba(0,0,0,0.8)'; C.fillRect(bx - 1, by - 1, bw + 2, bh + 2);
          C.fillStyle = '#2a0000'; C.fillRect(bx, by, bw, bh);
          const pct = m.hp / m.maxHp;
          C.fillStyle = pct > 0.6 ? '#44ff44' : pct > 0.3 ? '#ffaa00' : '#ff2222';
          C.fillRect(bx, by, bw * pct, bh);
          C.fillStyle = 'rgba(255,255,255,0.18)'; C.fillRect(bx, by, bw * pct, bh / 2);
          C.restore();
          if (m.boss) {
            C.save(); C.font = '6px "Press Start 2P"';
            C.fillStyle = m.rageMode ? '#ff4444' : '#ff8888';
            C.textAlign = 'center';
            C.fillText(m.name + (m.rageMode ? ' ‚ö°RAGE' : m.phase > 0 ? ` P${m.phase + 1}` : ''), sx, sy - 68);
            C.restore();
          }
        }

        // Indicateurs d'√©tat pour monstres normaux
        if (!m.boss && !dying) {
          // Point d'exclamation quand le monstre rep√®re le joueur (transition idle->aggro)
          if (m.state === 'aggro' && !m._wasAggro) {
            m._wasAggro = true; m._aggroAlert = 22;
          } else if (m.state !== 'aggro') {
            m._wasAggro = false;
          }
          if (m._aggroAlert > 0) {
            m._aggroAlert--;
            const alertA = m._aggroAlert / 22;
            const alertY = sy - (m.r || 14) * 2.2 - (1 - alertA) * 12;
            C.save();
            C.globalAlpha = alertA;
            C.font = 'bold 14px "Press Start 2P"';
            C.textAlign = 'center'; C.textBaseline = 'middle';
            C.fillStyle = '#ffdd00'; C.shadowColor = '#ff8800'; C.shadowBlur = 12;
            C.fillText('!', sx, alertY);
            C.restore();
          }
        }
      }
    }

    // ============================================================
    // PLAYER RENDER
    // ============================================================
    function renderPlayer() {
      const { p, cam } = GS;
      const sx = p.x - cam.x, sy = p.y - cam.y;
      const moving = Math.abs(p.vx) > 0.05 || Math.abs(p.vy) > 0.05 || K['ArrowLeft'] || K['ArrowRight'] || K['ArrowUp'] || K['ArrowDown'] || K['KeyA'] || K['KeyD'] || K['KeyW'] || K['KeyS'];
      const bob = moving ? Math.sin(GS.frame * 0.3) * 3 : 0;
      C.save();
      // Invincibilit√© dash ‚Äî clignotement rapide + aura cyan
      if (p.invincible) {
        if (Math.floor(GS.frame / 2) % 2 === 0) C.globalAlpha = 0.15;
        C.save();
        const ia = C.createRadialGradient(sx, sy, 4, sx, sy, 38);
        ia.addColorStop(0, 'rgba(0,255,200,0.45)'); ia.addColorStop(1, 'transparent');
        C.fillStyle = ia; C.beginPath(); C.arc(sx, sy, 38, 0, Math.PI * 2); C.fill();
        C.strokeStyle = 'rgba(0,255,200,0.7)'; C.lineWidth = 2.5;
        C.beginPath(); C.arc(sx, sy, 30 + Math.sin(GS.frame * 0.4) * 4, 0, Math.PI * 2); C.stroke();
        C.restore();
      } else if (p.inv > 0 && Math.floor(GS.frame / 3) % 2 === 0) {
        C.globalAlpha = 0.22;
      }
      // Time stop aura
      if (GS.timeStop) {
        C.save(); C.globalAlpha = 0.3 + Math.sin(GS.frame * 0.2) * 0.1; C.strokeStyle = '#8888ff'; C.lineWidth = 3;
        C.beginPath(); C.arc(sx, sy, 28, 0, Math.PI * 2); C.stroke(); C.restore();
      }
      // Attack arc
      if (p.atkAnim > 0) {
        const prog = 1 - p.atkAnim / 14, angle = Math.atan2(p.fy, p.fx);
        C.save(); C.globalAlpha = 0.7 * (1 - prog); C.strokeStyle = '#ffd700'; C.lineWidth = 7;
        C.shadowColor = '#ffd700'; C.shadowBlur = 18;
        C.beginPath(); C.arc(sx, sy, 48, angle - 1.0, angle + 1.0); C.stroke();
        C.strokeStyle = 'rgba(255,255,255,0.35)'; C.lineWidth = 2.5;
        C.beginPath(); C.arc(sx, sy, 48, angle - 1.0, angle + 1.0); C.stroke(); C.restore();
      }
      // Spin ring
      if (GS.spinAnim && GS.spinAnim.timer > 0) {
        const prog = GS.spinAnim.timer / GS.spinAnim.maxTimer;
        C.save(); C.globalAlpha = 0.5 * prog; C.strokeStyle = '#cc44ff'; C.lineWidth = 5;
        C.shadowColor = '#cc44ff'; C.shadowBlur = 20;
        C.beginPath(); C.arc(sx, sy, 55, 0, Math.PI * 2); C.stroke(); C.restore();
        GS.spinAnim.timer--;
      }
      // Charge aura
      if (p.charging && p.chargeTime > 0) {
        const ch = p.chargeTime / 90;
        const cg = C.createRadialGradient(sx, sy, 5, sx, sy, 32 + ch * 22);
        cg.addColorStop(0, `rgba(255,200,50,${0.45 * ch})`); cg.addColorStop(1, 'transparent');
        C.fillStyle = cg; C.beginPath(); C.arc(sx, sy, 52 + ch * 22, 0, Math.PI * 2); C.fill();
      }
      // Glow
      const glow = C.createRadialGradient(sx, sy + bob, 0, sx, sy + bob, 34);
      glow.addColorStop(0, `rgba(100,200,255,${0.12 + 0.05 * Math.sin(GS.frame * 0.05)})`); glow.addColorStop(1, 'transparent');
      C.fillStyle = glow; C.beginPath(); C.arc(sx, sy + bob, 34, 0, Math.PI * 2); C.fill();
      // Sprite sorcier pixel art
      const pdir = getPlayerDir(p);
      // scale up slightly if dying ‚Äî non (no dying state for player), just draw
      drawWizard(C, sx, sy + bob, pdir, p.atkAnim > 0 ? (Math.floor(GS.frame / 4) % 3) : (Math.floor(GS.frame / 10) % 3), 2.4);
      C.restore();
    }

    // ============================================================
    // ATTACK FX
    // ============================================================
    function renderAtks() {
      const { cam, atks } = GS;
      for (let i = atks.length - 1; i >= 0; i--) {
        const a = atks[i]; a.life--; if (a.life <= 0) { atks.splice(i, 1); continue; }
        const prog = (a.maxLife - a.life) / a.maxLife;
        const elapsed = a.maxLife - a.life;
        const sx = (a.worldX || a.x) - cam.x + a.vx * elapsed * 2.5;
        const sy = (a.worldY || a.y) - cam.y + a.vy * elapsed * 2.5;
        const fa = 1 - prog;
        C.save(); C.globalAlpha = fa;
        const sz = a.sz * (1 + prog * 0.3);

        if (a.icon === '‚ú®' || a.icon === 'üí´') {
          // √âclat dor√© ‚Äî croix de pixels + glow
          C.shadowColor = '#ffd700'; C.shadowBlur = 14 + prog * 10;
          C.fillStyle = '#ffd700';
          C.fillRect(sx - sz * 0.5, sy - 2, sz, 4);
          C.fillRect(sx - 2, sy - sz * 0.5, 4, sz);
          C.fillStyle = '#fff'; C.fillRect(sx - 2, sy - 2, 4, 4);
        } else if (a.icon === 'üí•') {
          // Explosion ‚Äî cercles concentriques pixelis√©s
          C.shadowColor = '#ff6600'; C.shadowBlur = 10;
          const rings = [['#ffcc00', sz * 0.9], ['#ff6600', sz * 0.65], ['#cc2200', sz * 0.35]];
          for (const [col, r] of rings) {
            C.strokeStyle = col; C.lineWidth = 3;
            C.beginPath(); C.arc(sx, sy, r, 0, Math.PI * 2); C.stroke();
          }
          C.fillStyle = '#fff'; C.fillRect(sx - 2, sy - 2, 4, 4);
        } else if (a.icon === 'üí®') {
          // Tra√Æn√©e dash ‚Äî petits rectangles bleus
          C.fillStyle = `rgba(0,220,180,${fa * 0.8})`;
          C.fillRect(sx - sz * 0.4, sy - 2, sz * 0.8, 4);
          C.fillRect(sx - 2, sy - sz * 0.3, 4, sz * 0.6);
        } else if (a.icon === 'üåÄ') {
          // T√©l√©port ‚Äî spirale violette
          C.strokeStyle = '#cc44ff'; C.lineWidth = 2; C.shadowColor = '#cc44ff'; C.shadowBlur = 12;
          for (let t = 0; t < Math.PI * 4; t += 0.3) {
            const r = (t / (Math.PI * 4)) * sz * 0.6;
            const px2 = sx + Math.cos(t + GS.frame * 0.3) * r;
            const py2 = sy + Math.sin(t + GS.frame * 0.3) * r;
            C.fillStyle = `rgba(200,80,255,${fa * (1 - t / (Math.PI * 4))})`;
            C.fillRect(px2, py2, 2, 2);
          }
        } else if (a.icon === '‚òÑÔ∏è') {
          // M√©t√©ore ‚Äî cercle rouge + tra√Æn√©e
          C.shadowColor = '#ff3300'; C.shadowBlur = 18;
          C.fillStyle = '#ff8800';
          C.beginPath(); C.arc(sx, sy, sz * 0.5, 0, Math.PI * 2); C.fill();
          C.fillStyle = '#ffdd00';
          C.beginPath(); C.arc(sx, sy, sz * 0.25, 0, Math.PI * 2); C.fill();
          // tra√Æn√©e
          C.fillStyle = 'rgba(255,100,0,0.4)';
          for (let t = 1; t <= 4; t++) {
            C.beginPath(); C.arc(sx - t * sz * 0.15, sy - t * sz * 0.15, sz * 0.4 / t, 0, Math.PI * 2); C.fill();
          }
        } else if (a.icon === 'üëÅÔ∏è') {
          // Wall phase eye ‚Äî oeil flottant
          C.fillStyle = `rgba(180,0,255,${fa * 0.7})`;
          C.beginPath(); C.ellipse(sx, sy, sz * 0.6, sz * 0.35, 0, 0, Math.PI * 2); C.fill();
          C.fillStyle = '#cc00ff';
          C.beginPath(); C.arc(sx, sy, sz * 0.2, 0, Math.PI * 2); C.fill();
          C.fillStyle = '#000';
          C.beginPath(); C.arc(sx, sy, sz * 0.1, 0, Math.PI * 2); C.fill();
        } else if (a.icon === 'üï∑Ô∏è') {
          // Spawning araign√©e ‚Äî petite silhouette avec pattes
          C.shadowColor = '#44ff88'; C.shadowBlur = 10;
          C.fillStyle = '#1a1a1a';
          C.beginPath(); C.arc(sx, sy, sz * 0.3, 0, Math.PI * 2); C.fill();
          C.strokeStyle = '#2a2a2a'; C.lineWidth = 1.5;
          for (let leg = 0; leg < 8; leg++) {
            const a2 = (leg / 8) * Math.PI * 2;
            C.beginPath(); C.moveTo(sx, sy);
            C.lineTo(sx + Math.cos(a2) * sz * 0.5, sy + Math.sin(a2) * sz * 0.4); C.stroke();
          }
          C.fillStyle = `rgba(60,255,100,${fa * 0.6})`;
          C.beginPath(); C.arc(sx, sy, sz * 0.15, 0, Math.PI * 2); C.fill();
        } else {
          // Fallback : carr√© color√© g√©n√©rique
          C.fillStyle = '#ffd700'; C.shadowColor = '#ffd700'; C.shadowBlur = 10;
          C.fillRect(sx - sz * 0.4, sy - sz * 0.4, sz * 0.8, sz * 0.8);
        }
        C.restore();
      }
    }

    // ============================================================
    // PROJECTILES RENDER
    // ============================================================
    function renderProjectiles() {
      const { cam } = GS;
      // Player projectiles
      for (const pr of GS.projectiles) {
        const sx = pr.x - cam.x, sy = pr.y - cam.y;
        if (sx < -60 || sx > canvas.width + 60 || sy < -60 || sy > canvas.height + 60) continue;
        C.save(); C.shadowBlur = 14;
        const ang = Math.atan2(pr.vy, pr.vx);
        C.translate(sx, sy); C.rotate(ang);
        if (pr.icon === '‚ö°') {
          // √âclair ‚Äî zigzag jaune
          C.shadowColor = '#ffd700'; C.strokeStyle = '#ffee00'; C.lineWidth = 3;
          C.beginPath(); C.moveTo(-10, 0); C.lineTo(-3, -5); C.lineTo(2, 3); C.lineTo(8, -4); C.lineTo(12, 0); C.stroke();
          C.strokeStyle = '#fff'; C.lineWidth = 1.5; C.stroke();
        } else if (pr.icon === 'üîÆ') {
          // Orbe violet
          C.shadowColor = '#aa00ff';
          C.fillStyle = '#8800cc';
          C.beginPath(); C.arc(0, 0, pr.sz * 0.5, 0, Math.PI * 2); C.fill();
          C.fillStyle = '#cc44ff';
          C.beginPath(); C.arc(-2, -2, pr.sz * 0.2, 0, Math.PI * 2); C.fill();
        } else if (pr.icon === '‚ùÑÔ∏è') {
          // Flocon glace
          C.shadowColor = '#88ccff'; C.strokeStyle = '#aaddff'; C.lineWidth = 2;
          for (let a = 0; a < Math.PI * 2; a += Math.PI / 3) {
            C.beginPath(); C.moveTo(0, 0); C.lineTo(Math.cos(a) * 10, Math.sin(a) * 10); C.stroke();
          }
          C.fillStyle = '#88ccff'; C.beginPath(); C.arc(0, 0, 3, 0, Math.PI * 2); C.fill();
        } else {
          C.fillStyle = '#ffd700'; C.shadowColor = '#ffd700';
          C.fillRect(-pr.sz * 0.4, -pr.sz * 0.4, pr.sz * 0.8, pr.sz * 0.8);
        }
        C.restore();
      }
      // Boss projectiles
      for (const pr of GS.bossProjectiles) {
        const sx = pr.x - cam.x, sy = pr.y - cam.y;
        if (sx < -60 || sx > canvas.width + 60 || sy < -60 || sy > canvas.height + 60) continue;
        C.save(); C.shadowBlur = 12; C.translate(sx, sy);
        if (pr.icon === '‚ò†Ô∏è') {
          // Poison ‚Äî cr√¢ne pixelis√©
          C.shadowColor = '#44ff44';
          C.fillStyle = '#228822';
          C.fillRect(-6, -6, 12, 10);
          C.fillStyle = '#44ff44'; C.fillRect(-4, -8, 4, 3); C.fillRect(2, -8, 4, 3);
          C.fillStyle = '#002200'; C.fillRect(-3, -4, 3, 3); C.fillRect(2, -4, 3, 3);
          C.fillRect(-2, 0, 2, 3); C.fillRect(0, 0, 2, 3); C.fillRect(2, 0, 2, 3);
        } else if (pr.icon === 'üíú') {
          // Ombre violette
          C.shadowColor = '#8800ff';
          C.fillStyle = '#6600cc';
          C.beginPath(); C.arc(0, 0, pr.sz * 0.5, 0, Math.PI * 2); C.fill();
          C.fillStyle = '#aa44ff'; C.beginPath(); C.arc(-2, -2, pr.sz * 0.2, 0, Math.PI * 2); C.fill();
        } else if (pr.icon === 'üî•') {
          // Flamme
          C.shadowColor = '#ff4400';
          C.fillStyle = '#ff4400'; C.fillRect(-4, -8, 8, 10);
          C.fillStyle = '#ff8800'; C.fillRect(-3, -10, 6, 7);
          C.fillStyle = '#ffcc00'; C.fillRect(-2, -12, 4, 6);
          C.fillStyle = '#fff'; C.fillRect(-1, -13, 2, 3);
        } else if (pr.icon === 'üåä') {
          // Onde choc
          C.shadowColor = '#4488ff';
          C.strokeStyle = '#4488ff'; C.lineWidth = 2;
          C.beginPath(); C.arc(0, 0, pr.sz * 0.6, 0, Math.PI * 2); C.stroke();
          C.strokeStyle = '#88ccff'; C.lineWidth = 1;
          C.beginPath(); C.arc(0, 0, pr.sz * 0.35, 0, Math.PI * 2); C.stroke();
        } else if (pr.icon === 'üí¢') {
          // Enrage ‚Äî losange rouge
          C.shadowColor = '#ff0000';
          C.fillStyle = '#cc0000';
          C.save(); C.rotate(Math.PI / 4 + GS.frame * 0.05);
          C.fillRect(-5, -5, 10, 10);
          C.restore();
          C.fillStyle = '#ff4444'; C.fillRect(-2, -2, 4, 4);
        } else if (pr.icon === '‚è∞') {
          // Arr√™t du temps ‚Äî horloge
          C.shadowColor = '#8888ff';
          C.strokeStyle = '#8888ff'; C.lineWidth = 2;
          C.beginPath(); C.arc(0, 0, pr.sz * 0.5, 0, Math.PI * 2); C.stroke();
          C.fillStyle = '#8888ff'; C.fillRect(-1, -7, 2, 7); C.fillRect(0, -2, 5, 2);
        } else if (pr.icon === 'üï∏Ô∏è') {
          // Projectile toile araign√©e ‚Äî sph√®re de soie avec fils
          const spin = GS.frame * 0.12;
          C.shadowColor = '#aaffcc'; C.shadowBlur = 8;
          // Anneaux de toile
          C.strokeStyle = `rgba(200,230,190,${0.7})`;
          C.lineWidth = 1.2;
          C.beginPath(); C.arc(0, 0, pr.sz * 0.5, 0, Math.PI * 2); C.stroke();
          C.beginPath(); C.arc(0, 0, pr.sz * 0.3, 0, Math.PI * 2); C.stroke();
          // Fils radiaux qui tournent
          C.lineWidth = 0.8;
          for (let i = 0; i < 6; i++) {
            const a2 = spin + (i / 6) * Math.PI * 2;
            C.beginPath(); C.moveTo(0, 0);
            C.lineTo(Math.cos(a2) * pr.sz * 0.5, Math.sin(a2) * pr.sz * 0.5); C.stroke();
          }
          // Centre gluant
          C.fillStyle = `rgba(220,240,180,0.85)`;
          C.beginPath(); C.arc(0, 0, pr.sz * 0.15, 0, Math.PI * 2); C.fill();
        } else {
          // Fallback : carr√© color√© g√©n√©rique
          C.fillStyle = '#ff4400'; C.shadowColor = '#ff4400';
          C.fillRect(-pr.sz * 0.4, -pr.sz * 0.4, pr.sz * 0.8, pr.sz * 0.8);
        }
        C.restore();
      } // fin for bossProjectiles
    } // fin renderProjectiles

    // ============================================================
    // LIGHTING + RENDER DISTANCE (Fog of War progressif)
    // ============================================================

    // Render distance config par biome
    function renderLighting() {
      const { p, cam } = GS;
      const sx = p.x - cam.x, sy = p.y - cam.y;
      const biome = LEVELS[curLvl].biome;
      const W = canvas.width, H = canvas.height;

      // ‚îÄ‚îÄ Vignette douce sur les bords (purement esth√©tique, pas de render distance)
      const vSize = Math.min(W, H);
      const outerA = biome === 'castle' ? 0.50 : biome === 'webs' ? 0.45 : biome === 'crystal' ? 0.38 : biome === 'mountain' ? 0.38 : 0.32;
      const vg = C.createRadialGradient(sx, sy, vSize * 0.22, sx, sy, vSize * 0.82);
      vg.addColorStop(0, 'rgba(0,0,0,0)');
      vg.addColorStop(1, `rgba(0,0,0,${outerA})`);
      C.fillStyle = vg; C.fillRect(0, 0, W, H);

      // ‚îÄ‚îÄ Lueur ambiante autour du joueur (couleur par biome)
      if (GS.lightPulse > 0) GS.lightPulse--;
      const breathe = Math.sin(GS.frame * 0.022) * 6;
      const lr = 260 + GS.lightPulse * 14 + breathe;
      const lc = biome === 'castle'   ? 'rgba(100,110,230,'
               : biome === 'mountain' ? 'rgba(160,215,255,'
               : biome === 'webs'     ? 'rgba(70,200,50,'
               : biome === 'crystal'  ? 'rgba(0,205,255,'
               :                        'rgba(255,210,80,';
      const lg = C.createRadialGradient(sx, sy, 0, sx, sy, lr);
      lg.addColorStop(0, lc + '0.18)');
      lg.addColorStop(0.45, lc + '0.07)');
      lg.addColorStop(1, 'transparent');
      C.fillStyle = lg; C.fillRect(0, 0, W, H);

      // ‚îÄ‚îÄ Tinte de biome (ambiance globale l√©g√®re)
      if (biome === 'webs')    { C.fillStyle = 'rgba(15,0,25,0.16)';  C.fillRect(0, 0, W, H); }
      if (biome === 'crystal') { C.fillStyle = 'rgba(0,8,22,0.12)';   C.fillRect(0, 0, W, H); }
      if (biome === 'castle')  { C.fillStyle = 'rgba(4,4,18,0.10)';   C.fillRect(0, 0, W, H); }

      // ‚îÄ‚îÄ Time stop
      if (GS.timeStop) {
        C.fillStyle = `rgba(50,50,200,${0.15 + 0.05 * Math.sin(GS.frame * 0.1)})`;
        C.fillRect(0, 0, W, H);
      }

      // ‚îÄ‚îÄ Liseret sombre discret sur les bords de l'√©cran
      C.fillStyle = 'rgba(0,0,0,0.18)';
      const e = 5;
      C.fillRect(0, 64, e, H - 64); C.fillRect(W - e, 64, e, H - 64);
      C.fillRect(0, H - e, W, e);
    }


    // ============================================================
    // MINIMAP
    // ============================================================
    function renderMinimap() {
      const { map: { map }, p, cam, mons, boss, qItems } = GS;
      const mw = mm.width, mh = mm.height; const sx = mw / WW, sy = mh / WH;
      // Fond
      MC.fillStyle = '#020208'; MC.fillRect(0, 0, mw, mh);
      const step = 3;
      const tC = {
        0: '#2a7a2a', 1: '#a07830', 2: '#1a4a8a', 3: '#555', 4: '#1a3a1a', 5: '#3a8a3a',
        6: '#1e4a20', 7: '#252440', 8: '#16163a', 9: '#d0e8f8', 10: '#7aaac8', 11: '#cc2200',
        12: '#1a1430', 13: '#7a5020', 14: '#3a9a3a', 15: '#3a8c30', 16: '#c8a060', 17: '#1e5a2a'
      };
      for (let r = 0; r < ROWS; r += step)for (let c = 0; c < COLS; c += step) {
        MC.fillStyle = tC[map[r][c]] || '#333'; MC.fillRect(c * sx * TSIZ, r * sy * TSIZ, (step * sx * TSIZ) + 1, (step * sy * TSIZ) + 1);
      }
      // Items de qu√™te ‚Äî jaune vif
      for (const qi of qItems) if (!qi.collected) {
        MC.fillStyle = '#ffe000'; MC.fillRect(qi.x * sx - 2, qi.y * sy - 2, 4, 4);
      }
      // Ennemis ‚Äî rouge plus visible
      MC.fillStyle = '#ff3333';
      for (const m of mons) if (m.state !== 'dead') { MC.fillRect(m.x * sx - 1.5, m.y * sy - 1.5, 3, 3); }
      // Boss ‚Äî orange puls√©
      if (boss && boss.state !== 'dead') {
        MC.fillStyle = boss.rageMode ? '#ff6600' : '#ff2200';
        MC.fillRect(boss.x * sx - 3, boss.y * sy - 3, 6, 6);
      }
      // Vue cam√©ra
      MC.strokeStyle = 'rgba(255,255,100,0.25)'; MC.lineWidth = 1;
      MC.strokeRect(cam.x * sx, cam.y * sy, canvas.width * sx, canvas.height * sy);
      // Joueur ‚Äî point vert vif + halo
      MC.fillStyle = 'rgba(0,255,100,0.3)'; MC.beginPath(); MC.arc(p.x * sx, p.y * sy, 5, 0, Math.PI * 2); MC.fill();
      MC.fillStyle = '#00ff66'; MC.beginPath(); MC.arc(p.x * sx, p.y * sy, 2.5, 0, Math.PI * 2); MC.fill();
    }

    // ============================================================
    // HUD
    // ============================================================
    function updHUD() {
      const p = GS.p; const lv = LEVELS[curLvl];
      const hw = document.getElementById('hearts'); hw.innerHTML = '';
      for (let i = 0; i < p.maxHp; i++) { const h = document.createElement('div'); h.className = i < p.hp ? 'heart-full' : 'heart-empty'; hw.appendChild(h); }
      document.getElementById('xpbar').style.width = Math.min(100, p.xp / (p.lvl * 100) * 100) + '%';
      document.getElementById('hud-lvl').textContent = `Niv. ${p.lvl}`;
      document.getElementById('hud-weapon').textContent = p.weapon;
      const done = lv.questType === 'kill' ? p.qKills : p.qItems;
      const questStr = Array.isArray(lv.quest) ? lv.quest[0] : lv.quest;
      document.getElementById('hud-quest').textContent = `${questStr} (${Math.min(done, lv.questCount)}/${lv.questCount})`;
    }

    // ============================================================
    // DIALOG
    // ============================================================
    let dlgLines = [], dlgIdx = 0, dlgCB = null, dlgTyping = false, dlgTimer = null, dlgFull = '';
    function openDlg(portrait, name, lines, cb) {
      GS.dlgActive = true; dlgLines = lines; dlgIdx = 0; dlgCB = cb;
      document.getElementById('dialog').style.display = 'block';
      document.getElementById('dlg-portrait').textContent = portrait;
      document.getElementById('dlg-name').textContent = name.toUpperCase();
      document.getElementById('dlg-btn').style.display = 'none';
      document.getElementById('dlg-cont').style.display = 'none';
      typeNext();
    }
    function typeNext() {
      if (dlgIdx >= dlgLines.length) { closeDlg(); return; }
      dlgFull = dlgLines[dlgIdx++];
      const el = document.getElementById('dlg-text');
      const btn = document.getElementById('dlg-btn'), cont = document.getElementById('dlg-cont');
      btn.style.display = 'none'; cont.style.display = 'none';
      if (dlgTimer) clearInterval(dlgTimer);
      dlgTyping = true; el.textContent = ''; let i = 0;
      dlgTimer = setInterval(() => {
        el.textContent += dlgFull[i]; sBeep(); i++;
        if (i >= dlgFull.length) {
          clearInterval(dlgTimer); dlgTyping = false; btn.style.display = 'block';
          if (dlgIdx < dlgLines.length) { cont.style.display = 'block'; btn.textContent = 'SUITE ‚ñ∂'; }
          else btn.textContent = 'FERMER ‚úï';
        }
      }, 28);
    }
    function nextLine() {
      if (dlgTyping) {
        clearInterval(dlgTimer); dlgTyping = false; document.getElementById('dlg-text').textContent = dlgFull;
        const btn = document.getElementById('dlg-btn'); btn.style.display = 'block';
        if (dlgIdx < dlgLines.length) { document.getElementById('dlg-cont').style.display = 'block'; btn.textContent = 'SUITE ‚ñ∂'; }
        else { document.getElementById('dlg-cont').style.display = 'none'; btn.textContent = 'FERMER ‚úï'; } return;
      }
      if (dlgIdx < dlgLines.length) typeNext(); else closeDlg();
    }
    function closeDlg() {
      document.getElementById('dialog').style.display = 'none';
      GS.dlgActive = false; if (dlgCB) { const cb = dlgCB; dlgCB = null; cb(); }
    }

    // ============================================================
    // LEVEL TRANSITION / VICTORY
    // ============================================================
    function showLT() {
      const lv = LEVELS[curLvl];
      const isLast = (curLvl >= LEVELS.length - 1);
      document.getElementById('lt-icon').textContent = lv.rewardIcon;
      document.getElementById('lt-title').textContent = isLast ? 'üèÜ VICTOIRE FINALE !' : 'NIVEAU ACCOMPLI !';
      document.getElementById('lt-zone').textContent = (Array.isArray(lv.name) ? lv.name[0] : lv.name) + ' ‚Äî Termin√© !';
      document.getElementById('lt-reward').textContent = lv.reward;
      // Supprimer les boutons dynamiques pr√©c√©dents pour √©viter les doublons
      document.querySelectorAll('#leveltrans .lt-dyn-btn').forEach(b => b.remove());
      if (isLast) {
        document.getElementById('lt-btn').style.display = 'none';
        const vb = document.createElement('button');
        vb.className = 'lt-next-btn lt-dyn-btn'; vb.textContent = 'üåü VOIR LA FIN';
        vb.onclick = () => { document.getElementById('leveltrans').style.display = 'none'; showVic(); };
        document.getElementById('leveltrans').appendChild(vb);
      } else {
        document.getElementById('lt-btn').style.display = 'block';
      }
      document.getElementById('leveltrans').style.display = 'flex';
      sLvlUp(); fireworks();
    }
    function goNextLevel() {
      document.getElementById('leveltrans').style.display = 'none';
      curLvl++; if (curLvl >= LEVELS.length) { showVic(); return; }
      // Pr√©-rendre les tracks du niveau suivant si pas encore fait
      if (typeof BossMusic !== 'undefined') BossMusic.preloadLevel(curLvl);
      loadLevel(curLvl);
    }
    function showVic() { document.getElementById('victory').style.display = 'flex'; sVic(); fireworks(); }

    // ============================================================
    // LOAD LEVEL
    // ============================================================
    function loadLevel(idx) {
      if (typeof BossMusic !== 'undefined') BossMusic.onLoadLevel(idx);
      const lv = LEVELS[idx];
      // Map new biomes to existing tileset biomes for map generation
      const tilesetBiome = lv.biome === 'webs' ? 'webs' : lv.biome === 'crystal' ? 'crystal' : lv.biome;
      const mapData = genMap(tilesetBiome);
      // For MONS lookup, use the biome key (crypt/abyss supported)
      const monsBiome = lv.biome;
      GS.map = mapData; GS.decos = genDecos(mapData, tilesetBiome); GS.ambient = genAmbient(tilesetBiome);
      // Expand questPos if level needs more items than default 3
      const baseItems = mapData.questPos;
      if (lv.questType === 'collect' && lv.questCount > baseItems.length) {
        const sR = Math.floor(mapData.startPos.y / TSIZ), sC = Math.floor(mapData.startPos.x / TSIZ);
        const cells = bfsPassable(mapData.map, sR, sC, 5000);
        while (baseItems.length < lv.questCount) {
          const sp = safeSpawnCell(cells, mapData.startPos.x, mapData.startPos.y, 150 + baseItems.length * 30);
          if (!sp) break;
          baseItems.push({ ...sp, collected: false });
        }
      }
      GS.qItems = baseItems; GS.mons = spawnMons(mapData, monsBiome, idx);
      GS.boss = null; GS.bossSpawned = false; GS.bossDefeated = false;
      GS.projectiles = []; GS.bossProjectiles = []; GS.bossWarnings = []; GS.atks = []; GS.spinAnim = null;
      GS.timeStop = false; GS.timeStopTimer = 0;
      const p = GS.p;
      p.x = mapData.startPos.x; p.y = mapData.startPos.y;
      p.qItems = 0; p.qKills = 0; p.inv = 100; p.charging = false; p.chargeTime = 0; p.atkCDs = [0, 0, 0, 0];
      p.dashCD = 0; p.invincible = false; p.invincibleTimer = 0;
      if (idx > 0) { p.weapon = LEVELS[idx - 1].weapon; p.wPow = LEVELS[idx - 1].wPow; }
      p.hp = p.maxHp;
      // Level 4 (Dragon Supreme) has pre-placed star like original dragon
      if (idx === 4) {
        const bp = mapData.bossPos;
        GS.qItems = [{ x: bp.x, y: bp.y, collected: false }];
        GS.boss = {
          icon: lv.bossIcon, name: lv.bossName, hp: lv.bossHP, maxHp: lv.bossHP,
          spd: lv.bossSpeed || 0.9, dmg: 7, x: bp.x - 80, y: bp.y, state: 'idle', dyingTimer: 0, atkCD: 0,
          aggroR: lv.bossAggroR || 400, loseR: 680, warnR: lv.bossWarnR || 0, warnZoneAlerted: false,
          wAngle: 0, wTimer: 0, hitFlash: 0, r: 30, boss: true, xp: 400,
          phase: 0, phaseTimer: 0, patternTimer: 0, patterns: lv.bossPatterns || [],
          dashActive: false, dashTimer: 0, dashVx: 0, dashVy: 0, vx: 0, vy: 0,
          teleportCooldown: 0, rageMode: false, beamActive: false, beamTimer: 0, beamAngle: 0,
          beamSweepDir: 1, timeStopActive: false, aerialActive: false, aerialYOff: 0
        };
        GS.bossSpawned = true;
        document.getElementById('boss-hud').style.display = 'flex';
        document.getElementById('boss-hud-name').textContent = lv.bossName.toUpperCase();
        const pip = document.getElementById('boss-phase-wrap'); pip.innerHTML = '';
        for (let i = 0; i < (lv.bossPhases || 3); i++) { const d = document.createElement('div'); d.className = 'boss-phase-pip' + (i === 0 ? ' active' : ''); d.id = `bpip${i}`; pip.appendChild(d); }
      }
      GS.cam.x = p.x - canvas.width / 2; GS.cam.y = p.y - canvas.height / 2;
      GS.cam.x = Math.max(0, Math.min(WW - canvas.width, GS.cam.x)); GS.cam.y = Math.max(0, Math.min(WH - canvas.height, GS.cam.y));
      updHUD(); tileCache.clear();
      const nameLines = Array.isArray(lv.name) ? lv.name : [lv.name];
      const questLine = Array.isArray(lv.quest) ? lv.quest[0] : lv.quest;
      setTimeout(() => openDlg('üìú', `NIVEAU ${idx + 1}`, [...nameLines, `Objectif : ${questLine}`, 'En avant, h√©ros !'], null), 700);
    }

    function spawnMons(mapData, biome, idx) {
      const types = MONS[biome] || MONS.forest; const count = 12 + idx * 5; const { map } = mapData;
      const sR = Math.floor(mapData.startPos.y / TSIZ), sC = Math.floor(mapData.startPos.x / TSIZ);
      const cells = bfsPassable(map, sR, sC, 5000); const out = [];
      for (let i = 0; i < count && cells.length > 0; i++) {
        const type = types[Math.floor(Math.random() * types.length)];
        const cell = safeSpawnCell(cells, mapData.startPos.x, mapData.startPos.y, 120);
        if (!cell) continue;
        out.push({
          ...JSON.parse(JSON.stringify(type)), id: i, x: cell.x, y: cell.y, vx: 0, vy: 0,
          state: 'idle', dyingTimer: 0, atkCD: 0, aggroR: 160 + Math.random() * 80, loseR: 300,
          wAngle: Math.random() * Math.PI * 2, wTimer: Math.random() * 90, hitFlash: 0
        });
      }
      return out;
    }

    // ============================================================
    // PIXEL ART SPRITES ‚Äî toutes les fonctions de dessin
    // ============================================================

    // Helper : dessine un pixel art √† partir d'une palette + grille
    function px(ctx, x, y, s, palette, grid, cols) {
      for (let i = 0; i < grid.length; i++) {
        const c = grid[i]; if (c === 0) continue;
        ctx.fillStyle = palette[c - 1];
        ctx.fillRect(x + (i % cols) * s, y + Math.floor(i / cols) * s, s, s);
      }
    }

    // ‚îÄ‚îÄ‚îÄ SORCIER (joueur) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // 12√ó16 pixels, 4 directions, 3 frames
    // direction: 0=bas 1=gauche 2=droite 3=haut
    function drawWizard(ctx, cx, cy, dir, frame, scale = 2) {
      const s = scale;
      const flip = dir === 1; // gauche = flip horizontal
      ctx.save();
      ctx.translate(cx, cy);
      if (flip) { ctx.scale(-1, 1); }

      // Palette: 1=robe fonc√©e 2=robe claire 3=peau 4=barbe 5=chapeau 6=b√¢ton 7=orbe 8=yeux 9=accent dor√©
      const P = ['#2a1c6e', '#4a3ea8', '#f2c07a', '#e8e8e8', '#1a1240', '#7a4a1a', '#00d4ff', '#220022', '#ffd700'];

      const W = 12, H = 16;
      const ox = -Math.floor(W * s / 2), oy = -Math.floor(H * s / 2);

      // Bob walking
      const legFrame = frame;
      const bodyBob = (frame === 1) ? -1 : 0;

      // --- CHAPEAU ---
      // pointe du chapeau
      for (let i = 3; i <= 8; i++) {
        const h = Math.max(0, 4 - Math.abs(i - 5.5));
        ctx.fillStyle = P[4];
        ctx.fillRect(ox + i * s, oy + (1 + (3 - h)) * s, s, h * s);
      }
      // bord chapeau
      ctx.fillStyle = P[4];
      ctx.fillRect(ox + 1 * s, oy + 5 * s, 10 * s, s);
      // √©toile sur chapeau
      ctx.fillStyle = P[8];
      ctx.fillRect(ox + 5 * s, oy + 3 * s, s, s);
      ctx.fillRect(ox + 4 * s, oy + 4 * s, 3 * s, s);
      ctx.fillRect(ox + 5 * s, oy + 4 * s, s, s);

      // --- T√äTE ---
      ctx.fillStyle = P[2];
      ctx.fillRect(ox + 3 * s, oy + (6 + bodyBob) * s, 6 * s, 4 * s);
      // yeux (selon direction)
      ctx.fillStyle = P[7];
      if (dir !== 3) { // pas dos
        ctx.fillRect(ox + 4 * s, oy + (7 + bodyBob) * s, s, s);
        ctx.fillRect(ox + 7 * s, oy + (7 + bodyBob) * s, s, s);
      }
      // barbe
      ctx.fillStyle = P[3];
      ctx.fillRect(ox + 3 * s, oy + (9 + bodyBob) * s, 6 * s, s);
      ctx.fillRect(ox + 4 * s, oy + (9 + bodyBob) * s, 4 * s, 2 * s);

      // --- ROBE ---
      ctx.fillStyle = P[0];
      ctx.fillRect(ox + 2 * s, oy + 10 * s, 8 * s, 4 * s);
      ctx.fillStyle = P[1];
      // reflets robe
      ctx.fillRect(ox + 4 * s, oy + 10 * s, 4 * s, 3 * s);
      // bas robe √©vas√©
      ctx.fillStyle = P[0];
      ctx.fillRect(ox + 1 * s, oy + 13 * s, 10 * s, s);
      // motif dor√© robe
      ctx.fillStyle = P[8];
      ctx.fillRect(ox + 5 * s, oy + 11 * s, 2 * s, s);

      // --- JAMBES ---
      const legOff = legFrame === 0 ? 0 : legFrame === 1 ? -s : s;
      ctx.fillStyle = P[0];
      ctx.fillRect(ox + 3 * s + legOff, oy + 14 * s, 2 * s, 2 * s);
      ctx.fillRect(ox + 7 * s - legOff, oy + 14 * s, 2 * s, 2 * s);
      // chaussures
      ctx.fillStyle = P[4];
      ctx.fillRect(ox + 3 * s + legOff - s, oy + 15 * s, 3 * s, s);
      ctx.fillRect(ox + 7 * s - legOff, oy + 15 * s, 3 * s, s);

      // --- BATON ---
      ctx.fillStyle = P[5];
      ctx.fillRect(ox + 0 * s, oy + 5 * s, s, 11 * s);
      // orbe b√¢ton
      ctx.fillStyle = P[6];
      ctx.fillRect(ox + 0 * s, oy + 4 * s, 2 * s, 2 * s);
      // brillance orbe (pulse)
      const pulse = (Math.sin(GS.frame * 0.12) + 1) / 2;
      ctx.globalAlpha *= (0.5 + 0.5 * pulse);
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(ox + 0 * s, oy + 4 * s, s, s);
      ctx.globalAlpha = ctx.globalAlpha / (0.5 + 0.5 * pulse) || 1;

      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ LOUP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawWolf(ctx, cx, cy, dir, frame, scale = 2, alpha = 1) {
      const s = scale;
      const flip = dir < 0; // dir=-1 va √† gauche
      ctx.save();
      ctx.translate(cx, cy);
      ctx.globalAlpha *= alpha;
      if (flip) { ctx.scale(-1, 1); }

      const ox = -10 * s, oy = -10 * s;

      const legOff = frame === 0 ? 0 : 2 * s;
      const runBob = frame === 1 ? -s : 0;

      // Corps
      ctx.fillStyle = '#5a4030';
      ctx.fillRect(ox + 3 * s, oy + 5 * s + runBob, 12 * s, 7 * s);
      // Ventre plus clair
      ctx.fillStyle = '#7a6050';
      ctx.fillRect(ox + 5 * s, oy + 8 * s + runBob, 7 * s, 3 * s);
      // Queue
      ctx.fillStyle = '#4a3020';
      ctx.fillRect(ox + 15 * s, oy + 3 * s + runBob, 3 * s, 5 * s);
      ctx.fillRect(ox + 16 * s, oy + 2 * s + runBob, 2 * s, 3 * s);

      // T√™te
      ctx.fillStyle = '#4a3020';
      ctx.fillRect(ox + 0 * s, oy + 2 * s + runBob, 8 * s, 7 * s);
      // Museau
      ctx.fillStyle = '#6a5040';
      ctx.fillRect(ox + 0 * s, oy + 6 * s + runBob, 5 * s, 3 * s);
      // Truffe
      ctx.fillStyle = '#1a0808';
      ctx.fillRect(ox + 0 * s, oy + 6 * s + runBob, 2 * s, 2 * s);
      // Oreilles
      ctx.fillStyle = '#3a2010';
      ctx.fillRect(ox + 3 * s, oy + 0 * s + runBob, 3 * s, 3 * s);
      ctx.fillRect(ox + 6 * s, oy + 0 * s + runBob, 3 * s, 3 * s);
      // Yeux
      ctx.fillStyle = '#ffdd00';
      ctx.fillRect(ox + 2 * s, oy + 3 * s + runBob, 2 * s, 2 * s);
      ctx.fillRect(ox + 5 * s, oy + 3 * s + runBob, 2 * s, 2 * s);
      ctx.fillStyle = '#000';
      ctx.fillRect(ox + 3 * s, oy + 3 * s + runBob, s, s);
      ctx.fillRect(ox + 6 * s, oy + 3 * s + runBob, s, s);

      // Pattes avant
      ctx.fillStyle = '#4a3020';
      ctx.fillRect(ox + 3 * s, oy + 11 * s + legOff, 3 * s, 3 * s);
      ctx.fillRect(ox + 8 * s, oy + 11 * s - legOff, 3 * s, 3 * s);
      // Pattes arri√®re
      ctx.fillRect(ox + 11 * s, oy + 11 * s + legOff, 3 * s, 3 * s);
      ctx.fillRect(ox + 14 * s, oy + 11 * s - legOff, 3 * s, 3 * s);
      // Griffes
      ctx.fillStyle = '#aaa';
      ctx.fillRect(ox + 3 * s, oy + 13 * s + legOff, s, s);
      ctx.fillRect(ox + 5 * s, oy + 13 * s + legOff, s, s);
      ctx.fillRect(ox + 8 * s, oy + 13 * s - legOff, s, s);
      ctx.fillRect(ox + 10 * s, oy + 13 * s - legOff, s, s);

      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ CHAUVE-SOURIS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawBat(ctx, cx, cy, frame, scale = 2, alpha = 1) {
      const s = scale;
      ctx.save();
      ctx.translate(cx, cy);
      ctx.globalAlpha *= alpha;

      const ox = -10 * s, oy = -8 * s;
      const wingUp = frame === 0;

      // Ombre port√©e
      ctx.fillStyle = 'rgba(0,0,0,0.18)';
      ctx.beginPath(); ctx.ellipse(cx - cx + 0, oy + 18 * s - cy + cy, 8 * s, 2 * s, 0, 0, Math.PI * 2); ctx.fill();
      ctx.translate(-cx + cx, -cy + cy);

      // Ailes
      ctx.fillStyle = '#2a1848';
      if (wingUp) {
        // Ailes lev√©es
        ctx.beginPath();
        ctx.moveTo(ox + 6 * s, oy + 6 * s); ctx.lineTo(ox - 2 * s, oy + 0 * s);
        ctx.lineTo(ox + 0 * s, oy + 2 * s); ctx.lineTo(ox + 2 * s, oy + 0 * s);
        ctx.lineTo(ox + 4 * s, oy + 3 * s); ctx.closePath(); ctx.fill();
        ctx.beginPath();
        ctx.moveTo(ox + 14 * s, oy + 6 * s); ctx.lineTo(ox + 22 * s, oy + 0 * s);
        ctx.lineTo(ox + 20 * s, oy + 2 * s); ctx.lineTo(ox + 18 * s, oy + 0 * s);
        ctx.lineTo(ox + 16 * s, oy + 3 * s); ctx.closePath(); ctx.fill();
      } else {
        // Ailes baiss√©es
        ctx.beginPath();
        ctx.moveTo(ox + 6 * s, oy + 6 * s); ctx.lineTo(ox - 2 * s, oy + 10 * s);
        ctx.lineTo(ox + 0 * s, oy + 9 * s); ctx.lineTo(ox + 2 * s, oy + 10 * s);
        ctx.lineTo(ox + 4 * s, oy + 8 * s); ctx.closePath(); ctx.fill();
        ctx.beginPath();
        ctx.moveTo(ox + 14 * s, oy + 6 * s); ctx.lineTo(ox + 22 * s, oy + 10 * s);
        ctx.lineTo(ox + 20 * s, oy + 9 * s); ctx.lineTo(ox + 18 * s, oy + 10 * s);
        ctx.lineTo(ox + 16 * s, oy + 8 * s); ctx.closePath(); ctx.fill();
      }
      // Membrane aile (d√©tail)
      ctx.fillStyle = '#3a2860';
      if (wingUp) {
        ctx.fillRect(ox + 1 * s, oy + 1 * s, 4 * s, s); ctx.fillRect(ox + 15 * s, oy + 1 * s, 4 * s, s);
      }
      // Corps
      ctx.fillStyle = '#2a1848';
      ctx.beginPath(); ctx.arc(ox + 10 * s, oy + 7 * s, 5 * s, 0, Math.PI * 2); ctx.fill();
      // Fourrure ventre
      ctx.fillStyle = '#3a2868';
      ctx.fillRect(ox + 7 * s, oy + 6 * s, 6 * s, 3 * s);
      // Oreilles pointues
      ctx.fillStyle = '#1a0c30';
      ctx.beginPath();
      ctx.moveTo(ox + 7 * s, oy + 3 * s); ctx.lineTo(ox + 6 * s, oy - 1 * s); ctx.lineTo(ox + 9 * s, oy + 3 * s); ctx.closePath(); ctx.fill();
      ctx.beginPath();
      ctx.moveTo(ox + 11 * s, oy + 3 * s); ctx.lineTo(ox + 14 * s, oy - 1 * s); ctx.lineTo(ox + 13 * s, oy + 3 * s); ctx.closePath(); ctx.fill();
      // Yeux rouges brillants
      ctx.fillStyle = '#ff2200';
      ctx.fillRect(ox + 8 * s, oy + 5 * s, 2 * s, 2 * s);
      ctx.fillRect(ox + 11 * s, oy + 5 * s, 2 * s, 2 * s);
      ctx.fillStyle = '#ff8866';
      ctx.fillRect(ox + 8 * s, oy + 5 * s, s, s);
      ctx.fillRect(ox + 11 * s, oy + 5 * s, s, s);
      // Crocs
      ctx.fillStyle = '#eee';
      ctx.fillRect(ox + 9 * s, oy + 9 * s, s, 2 * s);
      ctx.fillRect(ox + 11 * s, oy + 9 * s, s, 2 * s);

      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ ARAIGN√âE V√âN√âNEUSE (monstre normal) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawSpiderMob(ctx, cx, cy, frame, scale = 2, alpha = 1) {
      const s = scale;
      ctx.save();
      ctx.translate(cx, cy);
      ctx.globalAlpha *= alpha;

      const f = GS.frame;
      // frame 0 = pattes pos A, frame 1 = pattes pos B
      const legPhase = frame; // alterne 0/1

      // 8 pattes anim√©es avec articulation en 2 segments
      ctx.lineCap = 'round';
      const legPairs = [
        // [angle de base, longueur segment1, longueur segment2]
        [-2.0, 7, 6],
        [-2.5, 8, 7],
        [2.0, 7, 6],
        [2.5, 8, 7],
      ];
      for (let side = -1; side <= 1; side += 2) {
        for (let li = 0; li < 4; li++) {
          const [baseAng, l1, l2] = legPairs[li];
          const ang = side > 0 ? baseAng : Math.PI - baseAng;
          // Alternance des pattes (paires 0,2 vs 1,3)
          const lift = (li % 2 === legPhase) ? 1 : -1;
          const bendAmount = (li % 2 === legPhase) ? 0.6 : -0.3;

          const x1 = side * 4 * s;
          const y1 = -1 * s;
          const kx = x1 + Math.cos(ang) * l1 * s;
          const ky = y1 + Math.sin(ang) * l1 * s + bendAmount * s;
          const ex = kx + Math.cos(ang + 0.4 * side) * l2 * s;
          const ey = ky + Math.sin(ang + 0.3) * l2 * s - bendAmount * s * 0.5;

          ctx.strokeStyle = li < 2 ? '#2a1a0a' : '#1a1a1a';
          ctx.lineWidth = s * 0.9;
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(kx, ky);
          ctx.lineTo(ex, ey);
          ctx.stroke();

          // Petite griffe au bout
          ctx.strokeStyle = '#888';
          ctx.lineWidth = 0.6 * s;
          ctx.beginPath();
          ctx.moveTo(ex, ey);
          ctx.lineTo(ex + side * s, ey + s);
          ctx.stroke();
        }
      }

      // Abdomen ‚Äî forme ovo√Øde avec motif venin
      ctx.fillStyle = '#1a1214';
      ctx.beginPath(); ctx.ellipse(0, 5 * s, 7 * s, 6 * s, 0, 0, Math.PI * 2); ctx.fill();
      // Motif sablier rouge (araign√©e veuvenoir√© style)
      ctx.fillStyle = '#cc1100';
      ctx.beginPath();
      ctx.moveTo(0, 2 * s); ctx.lineTo(-2.5 * s, 5 * s); ctx.lineTo(0, 8 * s); ctx.lineTo(2.5 * s, 5 * s);
      ctx.closePath(); ctx.fill();
      ctx.fillStyle = '#ff3300';
      ctx.fillRect(-s, 4 * s, 2 * s, 2 * s);
      // Reflet abdomen
      ctx.fillStyle = 'rgba(80,40,60,0.4)';
      ctx.beginPath(); ctx.ellipse(-1.5 * s, 3 * s, 3 * s, 2 * s, -0.3, 0, Math.PI * 2); ctx.fill();

      // C√©phalothorax
      ctx.fillStyle = '#2a1a2a';
      ctx.beginPath(); ctx.ellipse(0, -3 * s, 5 * s, 4.5 * s, 0, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#3a243a';
      ctx.beginPath(); ctx.ellipse(-0.5 * s, -4 * s, 3 * s, 3 * s, 0, 0, Math.PI * 2); ctx.fill();

      // 8 yeux en arc ‚Äî luisants
      const eyePulse = (Math.sin(f * 0.12) + 1) * 0.5;
      ctx.fillStyle = `rgba(50,255,140,${0.7 + 0.3 * eyePulse})`;
      const eyePositions = [[-3, -6], [-1.5, -7], [0, -7], [1.5, -7], [3, -6], [-2, -5], [0, -5], [2, -5]];
      for (const [ex, ey] of eyePositions) {
        ctx.beginPath(); ctx.arc(ex * s, ey * s, 0.7 * s, 0, Math.PI * 2); ctx.fill();
      }

      // Ch√©lic√®res (crochets √† venin)
      const chelAnim = Math.sin(f * 0.18) * 0.3;
      ctx.fillStyle = '#1a0a00';
      ctx.save();
      ctx.translate(-1.5 * s, -8 * s); ctx.rotate(-0.3 + chelAnim);
      ctx.fillRect(0, 0, s, 3 * s); ctx.restore();
      ctx.save();
      ctx.translate(0.5 * s, -8 * s); ctx.rotate(0.3 - chelAnim);
      ctx.fillRect(0, 0, s, 3 * s); ctx.restore();
      // Goutte de venin
      if (eyePulse > 0.7) {
        ctx.fillStyle = `rgba(80,255,20,${(eyePulse - 0.7) * 2})`;
        ctx.beginPath(); ctx.arc(-1.5 * s, -5 * s, 1.2 * s, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(1.5 * s, -5 * s, 1.2 * s, 0, Math.PI * 2); ctx.fill();
      }

      // P√©dicule (liaison abdomen/c√©phalo)
      ctx.fillStyle = '#1a1014';
      ctx.beginPath(); ctx.ellipse(0, 1 * s, 2 * s, 1.5 * s, 0, 0, Math.PI * 2); ctx.fill();

      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ MONSTRE FEUILLE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawLeafMonster(ctx, cx, cy, frame, scale = 2, alpha = 1) {
      const s = scale;
      ctx.save();
      ctx.translate(cx, cy);
      ctx.globalAlpha *= alpha;

      const ox = -9 * s, oy = -12 * s;
      const sway = frame === 0 ? 0 : s;

      // Feuilles de fond (d√©cor)
      ctx.fillStyle = '#1a5c2a';
      for (let i = 0; i < 3; i++) {
        ctx.save();
        ctx.rotate((i - 1) * 0.3 + sway * 0.05);
        ctx.beginPath();
        ctx.ellipse((-2 + i * 2) * s, -10 * s, 4 * s, 7 * s, (i - 1) * 0.4, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      // Corps principal (feuille g√©ante)
      ctx.fillStyle = '#2a8040';
      ctx.beginPath();
      ctx.moveTo(0, oy + 0 * s);
      ctx.bezierCurveTo(-8 * s + sway, oy + 6 * s, -6 * s - sway, oy + 16 * s, 0, oy + 22 * s);
      ctx.bezierCurveTo(6 * s + sway, oy + 16 * s, 8 * s - sway, oy + 6 * s, 0, oy + 0 * s);
      ctx.fill();
      // Nervure centrale
      ctx.strokeStyle = '#1a6030'; ctx.lineWidth = s;
      ctx.beginPath();
      ctx.moveTo(0, oy); ctx.lineTo(0, oy + 22 * s); ctx.stroke();
      // Nervures lat√©rales
      ctx.lineWidth = 0.5;
      for (let i = 1; i < 5; i++) {
        ctx.beginPath();
        ctx.moveTo(0, oy + i * 4 * s);
        ctx.lineTo(-4 * s, oy + i * 4 * s + 2 * s);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, oy + i * 4 * s);
        ctx.lineTo(4 * s, oy + i * 4 * s + 2 * s);
        ctx.stroke();
      }
      // Reflets
      ctx.fillStyle = '#4ab060';
      ctx.beginPath();
      ctx.ellipse(-2 * s, oy + 8 * s, 2 * s, 5 * s, -0.2, 0, Math.PI * 2);
      ctx.fill();

      // Yeux rouges brillants
      ctx.fillStyle = '#cc0000';
      ctx.beginPath(); ctx.arc(-3 * s, oy + 9 * s, 2 * s, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(3 * s, oy + 9 * s, 2 * s, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#ff4444';
      ctx.fillRect(-4 * s, oy + 8 * s, 2 * s, 2 * s);
      ctx.fillRect(2 * s, oy + 8 * s, 2 * s, 2 * s);
      // Pupilles
      ctx.fillStyle = '#000';
      ctx.fillRect(-3 * s, oy + 9 * s, s, s);
      ctx.fillRect(3 * s, oy + 9 * s, s, s);

      // Bouche dentel√©e
      ctx.fillStyle = '#0a3010';
      ctx.fillRect(-3 * s, oy + 13 * s, 6 * s, 2 * s);
      ctx.fillStyle = '#eee';
      for (let i = 0; i < 3; i++) {
        ctx.fillRect((-2 + i * 2) * s, oy + 13 * s, s, 2 * s);
      }

      // Petites griffes
      ctx.fillStyle = '#1a4020';
      ctx.fillRect(-4 * s, oy + 20 * s - sway, 2 * s, 3 * s);
      ctx.fillRect(2 * s, oy + 20 * s + sway, 2 * s, 3 * s);
      ctx.fillStyle = '#aad060';
      ctx.fillRect(-5 * s, oy + 22 * s - sway, s, 2 * s);
      ctx.fillRect(-3 * s, oy + 22 * s - sway, s, 2 * s);
      ctx.fillRect(2 * s, oy + 22 * s + sway, s, 2 * s);
      ctx.fillRect(4 * s, oy + 22 * s + sway, s, 2 * s);

      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ D√âMON RAGE (boss 1) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ‚îÄ‚îÄ‚îÄ VORGATH LE BR√õL√â ‚Äî D√©mon des Flammes ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function drawDemon(ctx, cx, cy, dir, frame, scale = 2.2, alpha = 1, rageMode = false) {
      const s = scale;
      const f = GS.frame;
      ctx.save();
      ctx.translate(cx, cy);
      ctx.globalAlpha *= alpha;
      if (dir === 1) ctx.scale(-1, 1);

      const ox = -12 * s, oy = -16 * s;

      // Timings anim√©s ind√©pendants
      const breathe   = Math.sin(f * 0.06);
      const pulse     = (Math.sin(f * 0.18) + 1) / 2;
      const fireFlick = (Math.sin(f * 0.38) + Math.sin(f * 0.71)) * 0.5;
      const legPhase  = (f % 32) / 32;
      const legL      = Math.sin(legPhase * Math.PI * 2) * 4 * s;
      const legR      = -legL;
      const armL      = Math.sin(f * 0.09) * 5 * s;
      const armR      = -armL;
      const bodyBob   = breathe * 1.2 * s;
      const hornPulse = rageMode ? 0.6 + 0.4 * pulse : 0.2 + 0.15 * pulse;

      // ‚îÄ‚îÄ Flammes au sol (en dessous de tout) ‚îÄ‚îÄ
      const flameCount = rageMode ? 8 : 5;
      for (let i = 0; i < flameCount; i++) {
        const fx2 = ox + (4 + i * 4) * s;
        const fh = (6 + Math.sin(f * 0.3 + i * 1.3) * 3 + fireFlick * 2) * s;
        const falpha = 0.35 + 0.25 * Math.sin(f * 0.25 + i * 0.8);
        ctx.fillStyle = `rgba(255,${60 + i * 15},0,${falpha})`;
        ctx.beginPath();
        ctx.moveTo(fx2, oy + 33 * s + bodyBob);
        ctx.lineTo(fx2 + 2 * s, oy + 33 * s - fh + bodyBob);
        ctx.lineTo(fx2 + 4 * s, oy + 33 * s + bodyBob);
        ctx.closePath(); ctx.fill();
      }

      // ‚îÄ‚îÄ Aura rage / braise ‚îÄ‚îÄ
      if (rageMode) {
        const gr = ctx.createRadialGradient(0, bodyBob, 3 * s, 0, bodyBob, 28 * s);
        gr.addColorStop(0, `rgba(255,80,0,${0.35 + 0.2 * pulse})`);
        gr.addColorStop(0.6, `rgba(200,20,0,${0.12 + 0.08 * pulse})`);
        gr.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gr;
        ctx.beginPath(); ctx.ellipse(0, bodyBob, 28 * s, 22 * s, 0, 0, Math.PI * 2); ctx.fill();
        // Particules de braise
        for (let i = 0; i < 6; i++) {
          const angle = (f * 0.04 + i * 1.047) % (Math.PI * 2);
          const r2 = (18 + Math.sin(f * 0.1 + i) * 4) * s;
          const px2 = Math.cos(angle) * r2, py2 = Math.sin(angle) * r2 * 0.6 + bodyBob;
          ctx.fillStyle = `rgba(255,${100 + i * 25},0,${0.5 + 0.3 * Math.sin(f * 0.2 + i)})`;
          ctx.fillRect(px2 - s, py2 - s, 2 * s, 2 * s);
        }
      } else {
        // braise passive
        const gr2 = ctx.createRadialGradient(0, bodyBob, 2 * s, 0, bodyBob, 20 * s);
        gr2.addColorStop(0, `rgba(200,40,0,${0.15 + 0.08 * pulse})`);
        gr2.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gr2; ctx.beginPath(); ctx.ellipse(0, bodyBob, 22 * s, 16 * s, 0, 0, Math.PI * 2); ctx.fill();
      }

      // ‚îÄ‚îÄ Corps (centr√© sur bodyBob) ‚îÄ‚îÄ
      ctx.save(); ctx.translate(0, bodyBob);

      // Ombre corps
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.fillRect(ox + 2 * s, oy + 7 * s, 20 * s, 21 * s);

      // JAMBES (anim√©es ind√©pendamment)
      // Jambe gauche
      ctx.fillStyle = '#6a0000';
      ctx.fillRect(ox + 4 * s, oy + 26 * s + legL, 6 * s, 6 * s);
      ctx.fillStyle = '#4a0000';
      ctx.fillRect(ox + 3 * s, oy + 31 * s + legL, 7 * s, 3 * s);
      // Sabot gauche avec petites flammes
      ctx.fillStyle = rageMode ? '#ff2200' : '#1a0000';
      ctx.fillRect(ox + 2 * s, oy + 33 * s + legL, 8 * s, 2 * s);
      if (rageMode) {
        ctx.fillStyle = `rgba(255,120,0,${0.6 + 0.3 * pulse})`;
        ctx.fillRect(ox + 3 * s, oy + 32 * s + legL, 2 * s, 2 * s);
        ctx.fillRect(ox + 7 * s, oy + 32 * s + legL, 2 * s, 2 * s);
      }
      // Jambe droite
      ctx.fillStyle = '#6a0000';
      ctx.fillRect(ox + 14 * s, oy + 26 * s + legR, 6 * s, 6 * s);
      ctx.fillStyle = '#4a0000';
      ctx.fillRect(ox + 13 * s, oy + 31 * s + legR, 7 * s, 3 * s);
      ctx.fillStyle = rageMode ? '#ff2200' : '#1a0000';
      ctx.fillRect(ox + 12 * s, oy + 33 * s + legR, 8 * s, 2 * s);
      if (rageMode) {
        ctx.fillStyle = `rgba(255,120,0,${0.6 + 0.3 * pulse})`;
        ctx.fillRect(ox + 13 * s, oy + 32 * s + legR, 2 * s, 2 * s);
        ctx.fillRect(ox + 17 * s, oy + 32 * s + legR, 2 * s, 2 * s);
      }

      // CORPS principal
      ctx.fillStyle = '#6a0000';
      ctx.fillRect(ox + 2 * s, oy + 16 * s, 20 * s, 11 * s);
      // Abdomen segment√©
      ctx.fillStyle = '#8b1a00';
      ctx.fillRect(ox + 4 * s, oy + 18 * s, 16 * s, 7 * s);
      // Segments abdomen anim√©s
      for (let i = 0; i < 3; i++) {
        const segAlpha = 0.4 + 0.2 * Math.sin(f * 0.12 + i * 1.2);
        ctx.fillStyle = `rgba(40,0,0,${segAlpha})`;
        ctx.fillRect(ox + 4 * s, oy + (19 + i * 2) * s, 16 * s, s);
      }
      // Lueur abdomen (lave interne)
      ctx.fillStyle = `rgba(255,${60 + 40 * pulse},0,${0.18 + 0.12 * pulse})`;
      ctx.fillRect(ox + 5 * s, oy + 19 * s, 14 * s, 5 * s);

      // √âPAULES avec lave
      const shoulderGlow = rageMode ? `rgba(255,80,0,${0.5 + 0.3 * pulse})` : `rgba(200,30,0,${0.25 + 0.15 * pulse})`;
      ctx.fillStyle = shoulderGlow;
      ctx.fillRect(ox + 0 * s, oy + 14 * s, 5 * s, 5 * s);
      ctx.fillRect(ox + 19 * s, oy + 14 * s, 5 * s, 5 * s);
      ctx.fillStyle = '#8b0000';
      ctx.fillRect(ox + 1 * s, oy + 15 * s, 3 * s, 3 * s);
      ctx.fillRect(ox + 20 * s, oy + 15 * s, 3 * s, 3 * s);

      // BRAS gauche (anim√©)
      ctx.save(); ctx.translate(ox + 2 * s, oy + 16 * s);
      ctx.rotate(armL * 0.025);
      ctx.fillStyle = '#7a0000';
      ctx.fillRect(-2 * s, 0, 4 * s, 9 * s);
      // Avant-bras
      ctx.fillStyle = '#6a0000';
      ctx.fillRect(-2 * s, 7 * s, 4 * s, 5 * s);
      // Griffes
      ctx.fillStyle = '#1a0000';
      ctx.fillRect(-2 * s, 11 * s, 2 * s, 3 * s);
      ctx.fillRect(0, 12 * s, 2 * s, 2 * s);
      ctx.fillRect(1 * s, 11 * s, 2 * s, 3 * s);
      if (rageMode) {
        ctx.fillStyle = `rgba(255,100,0,${0.5 + 0.3 * pulse})`;
        ctx.fillRect(-3 * s, 10 * s, 6 * s, 4 * s);
      }
      ctx.restore();

      // BRAS droit (anim√© miroir)
      ctx.save(); ctx.translate(ox + 22 * s, oy + 16 * s);
      ctx.rotate(armR * 0.025);
      ctx.fillStyle = '#7a0000';
      ctx.fillRect(-2 * s, 0, 4 * s, 9 * s);
      ctx.fillStyle = '#6a0000';
      ctx.fillRect(-2 * s, 7 * s, 4 * s, 5 * s);
      ctx.fillStyle = '#1a0000';
      ctx.fillRect(-2 * s, 11 * s, 2 * s, 3 * s);
      ctx.fillRect(0, 12 * s, 2 * s, 2 * s);
      ctx.fillRect(1 * s, 11 * s, 2 * s, 3 * s);
      if (rageMode) {
        ctx.fillStyle = `rgba(255,100,0,${0.5 + 0.3 * pulse})`;
        ctx.fillRect(-3 * s, 10 * s, 6 * s, 4 * s);
      }
      ctx.restore();

      // T√äTE
      // Ombre t√™te
      ctx.fillStyle = '#2a0000';
      ctx.fillRect(ox + 3 * s, oy + 3 * s, 18 * s, 4 * s);
      ctx.fillRect(ox + 2 * s, oy + 7 * s, 20 * s, 11 * s);

      // Cornes (anim√©es l√©g√®rement)
      const hornBend = Math.sin(f * 0.05) * s * 0.5;
      // Corne gauche
      ctx.fillStyle = '#1a0000';
      ctx.beginPath();
      ctx.moveTo(ox + 5 * s, oy + 7 * s);
      ctx.lineTo(ox + 2 * s + hornBend, oy + 0);
      ctx.lineTo(ox + 9 * s, oy + 7 * s);
      ctx.closePath(); ctx.fill();
      // Corne droite
      ctx.beginPath();
      ctx.moveTo(ox + 15 * s, oy + 7 * s);
      ctx.lineTo(ox + 22 * s - hornBend, oy + 0);
      ctx.lineTo(ox + 19 * s, oy + 7 * s);
      ctx.closePath(); ctx.fill();
      // Pointes cornes avec glow
      ctx.fillStyle = rageMode ? '#ff6600' : '#8b1a00';
      ctx.fillRect(ox + 2 * s, oy - s, 2 * s, 2 * s);
      ctx.fillRect(ox + 21 * s, oy - s, 2 * s, 2 * s);
      if (hornPulse > 0.25) {
        ctx.fillStyle = `rgba(255,${rageMode ? 80 : 30},0,${hornPulse})`;
        ctx.fillRect(ox + 1 * s, oy - 2 * s, 4 * s, 3 * s);
        ctx.fillRect(ox + 19 * s, oy - 2 * s, 4 * s, 3 * s);
      }

      // T√™te principale
      ctx.fillStyle = '#8b0000';
      ctx.fillRect(ox + 4 * s, oy + 7 * s, 16 * s, 10 * s);
      // Joues osseuses
      ctx.fillStyle = '#6a0000';
      ctx.fillRect(ox + 3 * s, oy + 10 * s, 3 * s, 5 * s);
      ctx.fillRect(ox + 18 * s, oy + 10 * s, 3 * s, 5 * s);
      // D√©tail front
      ctx.fillStyle = '#7a0000';
      ctx.fillRect(ox + 5 * s, oy + 7 * s, 14 * s, 3 * s);

      // YEUX (anim√©s ‚Äî clignement + glow puls√©)
      const blinkOpen = (f % 120) > 4; // cligne rapidement toutes les 2s
      const eyeH = blinkOpen ? 3 * s : s;
      const eyeY = blinkOpen ? oy + 9 * s : oy + 10 * s;
      // Fond yeux sombres
      ctx.fillStyle = '#1a0000';
      ctx.fillRect(ox + 6 * s, oy + 9 * s, 5 * s, 4 * s);
      ctx.fillRect(ox + 13 * s, oy + 9 * s, 5 * s, 4 * s);
      // Iris
      const eyeColor = rageMode ? `rgb(255,${60 + Math.floor(80 * pulse)},0)` : `rgb(220,${30 + Math.floor(40 * pulse)},0)`;
      ctx.fillStyle = eyeColor;
      ctx.fillRect(ox + 7 * s, eyeY, 4 * s, eyeH);
      ctx.fillRect(ox + 14 * s, eyeY, 4 * s, eyeH);
      // Pupilles
      if (blinkOpen) {
        ctx.fillStyle = '#000';
        ctx.fillRect(ox + 8 * s, eyeY + s, 2 * s, s);
        ctx.fillRect(ox + 15 * s, eyeY + s, 2 * s, s);
      }
      // Brillance
      ctx.fillStyle = '#fff';
      ctx.fillRect(ox + 7 * s, eyeY, s, s);
      ctx.fillRect(ox + 14 * s, eyeY, s, s);
      // Glow yeux
      const glowA = blinkOpen ? 0.35 + 0.25 * pulse : 0.1;
      ctx.fillStyle = `rgba(255,${rageMode ? 60 : 30},0,${glowA})`;
      ctx.fillRect(ox + 5 * s, oy + 8 * s, 7 * s, 6 * s);
      ctx.fillRect(ox + 12 * s, oy + 8 * s, 7 * s, 6 * s);

      // BOUCHE avec crocs
      ctx.fillStyle = '#2a0000';
      ctx.fillRect(ox + 7 * s, oy + 14 * s, 10 * s, 3 * s);
      // Lueur bouche (int√©rieur ardent)
      ctx.fillStyle = `rgba(255,${80 + 40 * pulse},0,${0.5 + 0.3 * pulse})`;
      ctx.fillRect(ox + 8 * s, oy + 15 * s, 8 * s, s);
      // Crocs
      ctx.fillStyle = '#e0d8cc';
      ctx.fillRect(ox + 7 * s, oy + 14 * s, 2 * s, 3 * s);
      ctx.fillRect(ox + 10 * s, oy + 14 * s, 2 * s, 2 * s);
      ctx.fillRect(ox + 14 * s, oy + 14 * s, 2 * s, 3 * s);
      ctx.fillRect(ox + 12 * s, oy + 14 * s, 2 * s, 2 * s);

      // Flammes bouche (rage)
      if (rageMode) {
        for (let i = 0; i < 4; i++) {
          const fh2 = (4 + Math.sin(f * 0.3 + i * 0.9) * 2 + fireFlick) * s;
          ctx.fillStyle = `rgba(255,${80 + i * 30},0,${0.7 + 0.2 * Math.sin(f * 0.4 + i)})`;
          ctx.beginPath();
          ctx.moveTo(ox + (8 + i * 2) * s, oy + 17 * s);
          ctx.lineTo(ox + (9 + i * 2) * s, oy + 17 * s - fh2);
          ctx.lineTo(ox + (10 + i * 2) * s, oy + 17 * s);
          ctx.closePath(); ctx.fill();
        }
      }

      ctx.restore(); // fin bodyBob
      ctx.restore(); // fin global
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ‚îÄ‚îÄ‚îÄ NYTHERION LE REVENANT ‚Äî Roi Fant√¥me ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function drawKingDoubt(ctx, cx, cy, dir, frame, scale = 2.2, alpha = 1, rageMode = false) {
      const s = scale;
      const f = GS.frame;
      ctx.save();
      ctx.translate(cx, cy);
      ctx.globalAlpha *= alpha;
      if (dir === 1) ctx.scale(-1, 1);

      const ox = -12 * s, oy = -18 * s;

      // Timings
      const breathe   = Math.sin(f * 0.05);
      const pulse     = (Math.sin(f * 0.14) + 1) / 2;
      const fastPulse = (Math.sin(f * 0.28) + 1) / 2;
      const capeWave  = Math.sin(f * 0.08);
      const legPhase  = (f % 36) / 36;
      const legL      = Math.sin(legPhase * Math.PI * 2) * 3 * s;
      const legR      = -legL;
      const armWave   = Math.sin(f * 0.07) * 6 * s;
      const float     = Math.sin(f * 0.055) * 1.5 * s;
      const orbSpin   = f * 0.04;

      // ‚îÄ‚îÄ Orbes orbitaux (avant tout) ‚îÄ‚îÄ
      const orbCount = rageMode ? 5 : 3;
      for (let i = 0; i < orbCount; i++) {
        const angle = orbSpin + i * (Math.PI * 2 / orbCount);
        const orR = (22 + Math.sin(f * 0.06 + i) * 3) * s;
        const orX = Math.cos(angle) * orR;
        const orY = Math.sin(angle) * orR * 0.5 + float;
        const orA = 0.5 + 0.4 * Math.sin(f * 0.15 + i);
        ctx.fillStyle = rageMode ? `rgba(255,0,255,${orA})` : `rgba(160,0,255,${orA})`;
        ctx.beginPath(); ctx.arc(orX, orY, 3 * s, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = `rgba(255,255,255,${orA * 0.6})`;
        ctx.beginPath(); ctx.arc(orX - s, orY - s, s, 0, Math.PI * 2); ctx.fill();
        // Tra√Æne de l'orbe
        for (let t = 1; t <= 3; t++) {
          const ta = angle - t * 0.15;
          const tX = Math.cos(ta) * orR;
          const tY = Math.sin(ta) * orR * 0.5 + float;
          ctx.fillStyle = rageMode ? `rgba(200,0,255,${orA * 0.3 / t})` : `rgba(120,0,220,${orA * 0.25 / t})`;
          ctx.beginPath(); ctx.arc(tX, tY, (2 - t * 0.4) * s, 0, Math.PI * 2); ctx.fill();
        }
      }

      // ‚îÄ‚îÄ Aura fant√¥me ‚îÄ‚îÄ
      const auraGr = ctx.createRadialGradient(0, float, 4 * s, 0, float, 30 * s);
      if (rageMode) {
        auraGr.addColorStop(0, `rgba(200,0,255,${0.3 + 0.2 * pulse})`);
        auraGr.addColorStop(0.5, `rgba(100,0,180,${0.12 + 0.08 * pulse})`);
      } else {
        auraGr.addColorStop(0, `rgba(80,0,160,${0.2 + 0.12 * pulse})`);
        auraGr.addColorStop(0.5, `rgba(40,0,80,${0.08 + 0.05 * pulse})`);
      }
      auraGr.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = auraGr;
      ctx.beginPath(); ctx.ellipse(0, float, 30 * s, 22 * s, 0, 0, Math.PI * 2); ctx.fill();

      ctx.save(); ctx.translate(0, float);

      // ‚îÄ‚îÄ CAPE (derri√®re corps) ‚Äî ondulante ‚îÄ‚îÄ
      const capeL = capeWave * 3 * s;
      const capeR = -capeL;
      ctx.fillStyle = rageMode ? '#5a0090' : '#1e004e';
      ctx.beginPath();
      ctx.moveTo(ox + 1 * s, oy + 16 * s);
      ctx.bezierCurveTo(
        ox - 5 * s, oy + 24 * s + capeL,
        ox - 3 * s + capeL, oy + 34 * s,
        ox + 12 * s, oy + 36 * s + capeWave * s
      );
      ctx.bezierCurveTo(
        ox + 27 * s + capeR, oy + 34 * s,
        ox + 29 * s, oy + 24 * s + capeR,
        ox + 23 * s, oy + 16 * s
      );
      ctx.closePath(); ctx.fill();
      // Bord de cape lumineux
      ctx.strokeStyle = rageMode ? '#cc00ff' : '#7700bb';
      ctx.lineWidth = s * 1.2;
      ctx.stroke();
      // Reflets cape
      ctx.fillStyle = `rgba(${rageMode ? '200,0,255' : '100,0,200'},${0.12 + 0.08 * pulse})`;
      ctx.beginPath();
      ctx.moveTo(ox + 3 * s, oy + 18 * s);
      ctx.bezierCurveTo(ox + 0, oy + 26 * s, ox + 2 * s, oy + 32 * s, ox + 7 * s, oy + 35 * s);
      ctx.bezierCurveTo(ox + 5 * s, oy + 30 * s, ox + 4 * s, oy + 24 * s, ox + 5 * s, oy + 18 * s);
      ctx.closePath(); ctx.fill();

      // JAMBES
      ctx.fillStyle = '#1a0038';
      ctx.fillRect(ox + 5 * s, oy + 28 * s + legL, 5 * s, 7 * s);
      ctx.fillRect(ox + 14 * s, oy + 28 * s + legR, 5 * s, 7 * s);
      // Bottes
      ctx.fillStyle = '#0a0020';
      ctx.fillRect(ox + 4 * s, oy + 34 * s + legL, 7 * s, 2 * s);
      ctx.fillRect(ox + 13 * s, oy + 34 * s + legR, 7 * s, 2 * s);
      // Lueur bottes
      if (rageMode) {
        ctx.fillStyle = `rgba(180,0,255,${0.4 + 0.3 * pulse})`;
        ctx.fillRect(ox + 4 * s, oy + 35 * s + legL, 7 * s, s);
        ctx.fillRect(ox + 13 * s, oy + 35 * s + legR, 7 * s, s);
      }

      // CORPS armure
      ctx.fillStyle = '#1a0a30';
      ctx.fillRect(ox + 3 * s, oy + 18 * s, 18 * s, 11 * s);
      // Plaque centrale
      ctx.fillStyle = '#2e1450';
      ctx.fillRect(ox + 5 * s, oy + 19 * s, 14 * s, 5 * s);
      ctx.fillRect(ox + 5 * s, oy + 24 * s, 14 * s, 4 * s);
      // Nervures armure anim√©es
      for (let i = 0; i < 3; i++) {
        const gv = 0.15 + 0.12 * Math.sin(f * 0.1 + i * 1.4);
        ctx.fillStyle = rageMode ? `rgba(220,0,255,${gv})` : `rgba(140,0,220,${gv})`;
        ctx.fillRect(ox + 6 * s, oy + (19 + i * 2) * s, 12 * s, s);
      }
      // Orbe pectoral central
      const orbR = (3 + Math.sin(f * 0.15) * 0.8) * s;
      const orbGr = ctx.createRadialGradient(ox + 12 * s, oy + 22 * s, 0, ox + 12 * s, oy + 22 * s, orbR);
      if (rageMode) {
        orbGr.addColorStop(0, `rgba(255,200,255,${0.9 + 0.1 * fastPulse})`);
        orbGr.addColorStop(0.4, `rgba(255,0,255,0.85)`);
        orbGr.addColorStop(1, 'rgba(100,0,180,0.4)');
      } else {
        orbGr.addColorStop(0, `rgba(200,150,255,${0.85 + 0.15 * pulse})`);
        orbGr.addColorStop(0.4, `rgba(140,0,220,0.8)`);
        orbGr.addColorStop(1, 'rgba(60,0,120,0.3)');
      }
      ctx.fillStyle = orbGr;
      ctx.beginPath(); ctx.arc(ox + 12 * s, oy + 22 * s, orbR, 0, Math.PI * 2); ctx.fill();

      // BRAS gauche (flotte et se l√®ve en combat)
      ctx.save(); ctx.translate(ox + 3 * s, oy + 18 * s);
      ctx.rotate(-0.15 + armWave * 0.012);
      ctx.fillStyle = '#2a0a40';
      ctx.fillRect(-2 * s, 0, 5 * s, 9 * s);
      // √âpauli√®re
      ctx.fillStyle = '#4a2080';
      ctx.fillRect(-3 * s, -s, 7 * s, 4 * s);
      ctx.fillStyle = rageMode ? '#cc00ff' : '#6600aa';
      ctx.fillRect(-2 * s, -s, 5 * s, 2 * s);
      // Main magique
      ctx.fillStyle = rageMode ? '#ff00ff' : '#9900cc';
      ctx.fillRect(-2 * s, 9 * s, 5 * s, 4 * s);
      // Particules mains
      if (rageMode || pulse > 0.5) {
        for (let i = 0; i < 3; i++) {
          ctx.fillStyle = `rgba(${rageMode ? '255,0,255' : '180,0,255'},${(0.4 + 0.4 * Math.sin(f * 0.2 + i)) * (rageMode ? 1 : 0.5)})`;
          const mx = (Math.sin(f * 0.15 + i * 2.1)) * 3 * s;
          const my = (Math.cos(f * 0.12 + i * 1.5)) * 2 * s;
          ctx.fillRect(mx - s, 12 * s + my, 2 * s, 2 * s);
        }
      }
      ctx.restore();

      // BRAS droit
      ctx.save(); ctx.translate(ox + 21 * s, oy + 18 * s);
      ctx.rotate(0.15 - armWave * 0.012);
      ctx.fillStyle = '#2a0a40';
      ctx.fillRect(-3 * s, 0, 5 * s, 9 * s);
      ctx.fillStyle = '#4a2080';
      ctx.fillRect(-4 * s, -s, 7 * s, 4 * s);
      ctx.fillStyle = rageMode ? '#cc00ff' : '#6600aa';
      ctx.fillRect(-3 * s, -s, 5 * s, 2 * s);
      ctx.fillStyle = rageMode ? '#ff00ff' : '#9900cc';
      ctx.fillRect(-3 * s, 9 * s, 5 * s, 4 * s);
      if (rageMode || pulse > 0.5) {
        for (let i = 0; i < 3; i++) {
          ctx.fillStyle = `rgba(${rageMode ? '255,0,255' : '180,0,255'},${(0.4 + 0.4 * Math.sin(f * 0.2 + i + 1)) * (rageMode ? 1 : 0.5)})`;
          const mx = (Math.sin(f * 0.15 + i * 2.1 + 1)) * 3 * s;
          const my = (Math.cos(f * 0.12 + i * 1.5 + 1)) * 2 * s;
          ctx.fillRect(mx - s, 12 * s + my, 2 * s, 2 * s);
        }
      }
      ctx.restore();

      // T√äTE
      // Ombre t√™te
      ctx.fillStyle = '#1a0030';
      ctx.fillRect(ox + 3 * s, oy + 4 * s, 18 * s, 16 * s);

      // COURONNE (anim√©e ‚Äî gemmes pulsantes)
      ctx.fillStyle = '#d4a800';
      ctx.fillRect(ox + 4 * s, oy + 4 * s, 16 * s, 5 * s);
      // Pointes couronne
      const crownHeights = [3, 5, 7, 5, 3];
      for (let i = 0; i < 5; i++) {
        const h = crownHeights[i] * s;
        const cx2 = ox + (4 + i * 3.2) * s;
        ctx.fillStyle = '#ffd700';
        ctx.fillRect(cx2, oy + 4 * s - h, 2.5 * s, h);
        ctx.fillStyle = '#c8a000';
        ctx.fillRect(cx2, oy + 4 * s - h, s, h * 0.6);
      }
      // Gemme centrale couronne (pulsante)
      const gemR = (2 + Math.sin(f * 0.2) * 0.5) * s;
      ctx.fillStyle = rageMode ? `rgba(255,0,255,${0.8 + 0.2 * fastPulse})` : `rgba(180,0,255,${0.75 + 0.25 * pulse})`;
      ctx.beginPath(); ctx.arc(ox + 12 * s, oy + s, gemR, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = `rgba(255,255,255,${0.6 + 0.4 * fastPulse})`;
      ctx.beginPath(); ctx.arc(ox + 11 * s, oy + 0.5 * s, gemR * 0.4, 0, Math.PI * 2); ctx.fill();
      // Gemmes lat√©rales
      ctx.fillStyle = `rgba(255,60,60,${0.7 + 0.3 * pulse})`;
      ctx.fillRect(ox + 7 * s, oy + 2 * s, 2 * s, 2 * s);
      ctx.fillRect(ox + 15 * s, oy + 2 * s, 2 * s, 2 * s);

      // T√™te principale
      ctx.fillStyle = '#280a35';
      ctx.fillRect(ox + 4 * s, oy + 9 * s, 16 * s, 10 * s);
      // Masque fant√¥me
      ctx.fillStyle = '#1c0028';
      ctx.fillRect(ox + 6 * s, oy + 10 * s, 12 * s, 6 * s);

      // YEUX (portail spectral, anim√©s)
      const blinkKing = (f % 150) > 5;
      const eyeGlowR = rageMode ? `rgba(255,0,255,${0.5 + 0.4 * pulse})` : `rgba(160,0,255,${0.4 + 0.3 * pulse})`;
      // Halo yeux
      ctx.fillStyle = eyeGlowR;
      ctx.fillRect(ox + 6 * s, oy + 10 * s, 5 * s, 5 * s);
      ctx.fillRect(ox + 13 * s, oy + 10 * s, 5 * s, 5 * s);
      // Yeux
      const eyeKingH = blinkKing ? 3 * s : s * 0.8;
      const eyeKingColor = rageMode
        ? `rgb(255,${60 + Math.floor(100 * fastPulse)},255)`
        : `rgb(${160 + Math.floor(60 * pulse)},0,${200 + Math.floor(55 * pulse)})`;
      ctx.fillStyle = eyeKingColor;
      ctx.fillRect(ox + 7 * s, oy + 11 * s, 4 * s, eyeKingH);
      ctx.fillRect(ox + 14 * s, oy + 11 * s, 4 * s, eyeKingH);
      // Pupilles portail
      if (blinkKing) {
        ctx.fillStyle = '#000';
        ctx.fillRect(ox + 8 * s, oy + 12 * s, 2 * s, s);
        ctx.fillRect(ox + 15 * s, oy + 12 * s, 2 * s, s);
        // √âtoile dans l'≈ìil
        ctx.fillStyle = `rgba(255,255,255,${0.8 + 0.2 * fastPulse})`;
        ctx.fillRect(ox + 7 * s, oy + 11 * s, s, s);
        ctx.fillRect(ox + 14 * s, oy + 11 * s, s, s);
      }

      // Bouche royale
      ctx.fillStyle = '#0a0018';
      ctx.fillRect(ox + 7 * s, oy + 16 * s, 10 * s, 2 * s);
      // Lueur bouche magie
      ctx.fillStyle = `rgba(${rageMode ? '255,0,255' : '120,0,200'},${0.4 + 0.3 * pulse})`;
      ctx.fillRect(ox + 8 * s, oy + 16 * s, 8 * s, s);
      // Dents spectrales
      ctx.fillStyle = `rgba(200,150,255,${0.5 + 0.3 * pulse})`;
      ctx.fillRect(ox + 7 * s, oy + 15 * s, 2 * s, 2 * s);
      ctx.fillRect(ox + 10 * s, oy + 15 * s, 2 * s, 2 * s);
      ctx.fillRect(ox + 14 * s, oy + 15 * s, 2 * s, 2 * s);

      // Brume fant√¥me autour de la t√™te
      for (let i = 0; i < 4; i++) {
        const angle2 = f * 0.03 + i * 1.57;
        const bx = Math.cos(angle2) * (14 + i * 2) * s + ox + 12 * s;
        const by = Math.sin(angle2) * 6 * s + oy + 12 * s;
        ctx.fillStyle = `rgba(${rageMode ? '200,0,255' : '80,0,160'},${0.08 + 0.06 * Math.sin(f * 0.1 + i)})`;
        ctx.beginPath(); ctx.arc(bx, by, (3 + i) * s, 0, Math.PI * 2); ctx.fill();
      }

      ctx.restore(); // float
      ctx.restore();
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ‚îÄ‚îÄ‚îÄ THYRAX LE SOUFFLE NOIR ‚Äî Dragon du Temps ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function drawDragon(ctx, cx, cy, dir, frame, scale = 2.5, alpha = 1, rageMode = false, aerialYOff = 0) {
      const s = scale;
      const f = GS.frame;
      ctx.save();
      ctx.translate(cx, cy + (aerialYOff || 0));
      ctx.globalAlpha *= alpha;
      if (dir === 1) ctx.scale(-1, 1);

      const ox = -18 * s, oy = -18 * s;

      // Timings
      const breathe    = Math.sin(f * 0.055);
      const pulse      = (Math.sin(f * 0.13) + 1) / 2;
      const fastPulse  = (Math.sin(f * 0.24) + 1) / 2;
      const legPhase   = (f % 28) / 28;
      const legL       = Math.sin(legPhase * Math.PI * 2) * 5 * s;
      const legR       = -legL;
      const bodyBreath = breathe * 1.5 * s;
      const tailWave   = Math.sin(f * 0.07);
      const tailWave2  = Math.sin(f * 0.07 + 0.8);

      // ‚îÄ‚îÄ Aile : battement ‚îÄ‚îÄ
      const wFlap = (aerialYOff < -20)
        ? Math.sin(f * 0.35) * 12 * s           // vol rapide
        : Math.sin(f * 0.1) * 5 * s;            // aile lente au sol

      // ‚îÄ‚îÄ Particules temporelles (autour du dragon) ‚îÄ‚îÄ
      const partCount = rageMode ? 10 : 6;
      for (let i = 0; i < partCount; i++) {
        const angle = f * 0.035 + i * (Math.PI * 2 / partCount);
        const r2 = (26 + Math.sin(f * 0.07 + i) * 6) * s;
        const px2 = Math.cos(angle) * r2;
        const py2 = Math.sin(angle) * r2 * 0.45 + bodyBreath;
        const pA = 0.4 + 0.35 * Math.sin(f * 0.12 + i * 1.3);
        ctx.fillStyle = rageMode
          ? `rgba(255,${80 + i * 15},0,${pA})`
          : `rgba(${20 + i * 20},${160 + i * 8},255,${pA})`;
        ctx.beginPath(); ctx.arc(px2, py2, (2 + Math.sin(f * 0.1 + i) * 0.8) * s, 0, Math.PI * 2); ctx.fill();
        // Tra√Æne particule
        const ta = angle - 0.2;
        ctx.fillStyle = rageMode ? `rgba(220,60,0,${pA * 0.4})` : `rgba(0,100,255,${pA * 0.35})`;
        ctx.beginPath(); ctx.arc(Math.cos(ta) * r2, Math.sin(ta) * r2 * 0.45 + bodyBreath, s, 0, Math.PI * 2); ctx.fill();
      }

      // ‚îÄ‚îÄ Aura temporelle ‚îÄ‚îÄ
      const auraGr = ctx.createRadialGradient(0, bodyBreath, 5 * s, 0, bodyBreath, 38 * s);
      if (rageMode) {
        auraGr.addColorStop(0, `rgba(255,100,0,${0.28 + 0.18 * pulse})`);
        auraGr.addColorStop(0.5, `rgba(200,40,0,${0.1 + 0.07 * pulse})`);
      } else {
        auraGr.addColorStop(0, `rgba(60,160,255,${0.18 + 0.12 * pulse})`);
        auraGr.addColorStop(0.5, `rgba(20,80,200,${0.07 + 0.05 * pulse})`);
      }
      auraGr.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = auraGr;
      ctx.beginPath(); ctx.ellipse(0, bodyBreath, 38 * s, 24 * s, 0, 0, Math.PI * 2); ctx.fill();

      ctx.save(); ctx.translate(0, bodyBreath);

      // ‚îÄ‚îÄ QUEUE (ondulante) ‚îÄ‚îÄ
      const qCol = rageMode ? '#7a1800' : '#102848';
      ctx.fillStyle = qCol;
      ctx.beginPath();
      ctx.moveTo(ox + 24 * s, oy + 24 * s);
      ctx.bezierCurveTo(
        ox + 32 * s, oy + 28 * s + tailWave * 4 * s,
        ox + 38 * s, oy + 22 * s + tailWave2 * 4 * s,
        ox + 42 * s, oy + 16 * s + tailWave * 6 * s
      );
      ctx.bezierCurveTo(
        ox + 40 * s, oy + 16 * s + tailWave * 6 * s,
        ox + 36 * s, oy + 22 * s + tailWave2 * 3 * s,
        ox + 30 * s, oy + 26 * s + tailWave * 3 * s
      );
      ctx.closePath(); ctx.fill();
      // Pointe queue
      ctx.fillStyle = rageMode ? '#ff4400' : '#4090d0';
      ctx.beginPath();
      ctx.moveTo(ox + 42 * s, oy + 16 * s + tailWave * 6 * s);
      ctx.lineTo(ox + 46 * s, oy + 10 * s + tailWave * 8 * s);
      ctx.lineTo(ox + 43 * s, oy + 16 * s + tailWave * 6 * s);
      ctx.closePath(); ctx.fill();
      // Segments queue
      for (let i = 0; i < 4; i++) {
        const t2 = i / 4;
        const qx = ox + (24 + i * 4.5) * s;
        const qy = oy + (25 + i * 0.5) * s + tailWave * i * 1.5 * s;
        ctx.fillStyle = rageMode ? `rgba(160,30,0,0.6)` : `rgba(30,80,160,0.5)`;
        ctx.fillRect(qx, qy, 3 * s, 2 * s);
      }

      // ‚îÄ‚îÄ AILES (derri√®re le corps) ‚îÄ‚îÄ
      const wingMainCol = rageMode ? '#8b2000' : '#1a3870';
      const wingMemCol  = rageMode ? 'rgba(180,50,0,0.55)' : 'rgba(40,90,160,0.55)';

      // Aile gauche
      ctx.fillStyle = wingMainCol;
      ctx.beginPath();
      ctx.moveTo(ox + 14 * s, oy + 14 * s);
      ctx.lineTo(ox - 8 * s, oy + 8 * s + wFlap);
      ctx.lineTo(ox - 2 * s, oy + 2 * s + wFlap * 1.2);
      ctx.lineTo(ox + 2 * s, oy - 4 * s + wFlap * 0.6);
      ctx.lineTo(ox + 6 * s, oy + 6 * s + wFlap * 0.4);
      ctx.lineTo(ox + 10 * s, oy + 8 * s + wFlap * 0.2);
      ctx.lineTo(ox + 14 * s, oy + 12 * s);
      ctx.closePath(); ctx.fill();
      // Nervures aile gauche
      ctx.strokeStyle = rageMode ? 'rgba(255,80,0,0.5)' : 'rgba(80,140,255,0.45)';
      ctx.lineWidth = s * 0.9;
      for (let i = 0; i < 3; i++) {
        const nx = ox + (14 - i * 4) * s;
        const ny = oy + (14 - i * 2) * s;
        const ex = ox + (-6 + i * 3) * s;
        const ey = oy + (9 + wFlap * (1 - i * 0.3));
        ctx.beginPath(); ctx.moveTo(nx, ny); ctx.lineTo(ex, ey); ctx.stroke();
      }
      // Membrane aile gauche
      ctx.fillStyle = wingMemCol;
      ctx.beginPath();
      ctx.moveTo(ox + 12 * s, oy + 13 * s);
      ctx.lineTo(ox - 6 * s, oy + 9 * s + wFlap);
      ctx.lineTo(ox + 0, oy + 4 * s + wFlap * 1.1);
      ctx.lineTo(ox + 8 * s, oy + 9 * s + wFlap * 0.3);
      ctx.closePath(); ctx.fill();

      // Aile droite
      ctx.fillStyle = wingMainCol;
      ctx.beginPath();
      ctx.moveTo(ox + 22 * s, oy + 14 * s);
      ctx.lineTo(ox + 44 * s, oy + 8 * s + wFlap);
      ctx.lineTo(ox + 38 * s, oy + 2 * s + wFlap * 1.2);
      ctx.lineTo(ox + 34 * s, oy - 4 * s + wFlap * 0.6);
      ctx.lineTo(ox + 30 * s, oy + 6 * s + wFlap * 0.4);
      ctx.lineTo(ox + 26 * s, oy + 8 * s + wFlap * 0.2);
      ctx.lineTo(ox + 22 * s, oy + 12 * s);
      ctx.closePath(); ctx.fill();
      // Nervures aile droite
      for (let i = 0; i < 3; i++) {
        const nx = ox + (22 + i * 4) * s;
        const ny = oy + (14 - i * 2) * s;
        const ex = ox + (42 - i * 3) * s;
        const ey = oy + (9 + wFlap * (1 - i * 0.3));
        ctx.beginPath(); ctx.moveTo(nx, ny); ctx.lineTo(ex, ey); ctx.stroke();
      }
      ctx.fillStyle = wingMemCol;
      ctx.beginPath();
      ctx.moveTo(ox + 24 * s, oy + 13 * s);
      ctx.lineTo(ox + 42 * s, oy + 9 * s + wFlap);
      ctx.lineTo(ox + 36 * s, oy + 4 * s + wFlap * 1.1);
      ctx.lineTo(ox + 28 * s, oy + 9 * s + wFlap * 0.3);
      ctx.closePath(); ctx.fill();

      // ‚îÄ‚îÄ CORPS principal ‚îÄ‚îÄ
      ctx.fillStyle = rageMode ? '#6a0000' : '#0d2848';
      ctx.fillRect(ox + 8 * s, oy + 12 * s, 20 * s, 16 * s);
      // Dos / √©cailles
      ctx.fillStyle = rageMode ? '#8b1000' : '#1a4070';
      ctx.fillRect(ox + 9 * s, oy + 12 * s, 18 * s, 5 * s);
      // Ventre
      ctx.fillStyle = rageMode ? '#cc3300' : '#1a5090';
      ctx.fillRect(ox + 10 * s, oy + 19 * s, 16 * s, 7 * s);
      // Plaques ventre anim√©es
      for (let i = 0; i < 4; i++) {
        const gv = 0.3 + 0.2 * Math.sin(f * 0.1 + i * 1.1);
        ctx.fillStyle = rageMode ? `rgba(40,0,0,${gv})` : `rgba(0,30,60,${gv})`;
        ctx.fillRect(ox + (10 + i * 4) * s, oy + 20 * s, 3 * s, 5 * s);
      }
      // Cr√™te dorsale (√©pines anim√©es)
      const creteCol = rageMode ? '#ff4400' : '#40a0ff';
      for (let i = 0; i < 5; i++) {
        const h = (4 + Math.sin(f * 0.08 + i * 0.8) * 1.5) * s;
        const bx2 = ox + (10 + i * 3.5) * s;
        ctx.fillStyle = creteCol;
        ctx.beginPath();
        ctx.moveTo(bx2, oy + 12 * s);
        ctx.lineTo(bx2 + 1.5 * s, oy + 12 * s - h);
        ctx.lineTo(bx2 + 3 * s, oy + 12 * s);
        ctx.closePath(); ctx.fill();
        ctx.fillStyle = `rgba(255,255,255,${0.3 + 0.2 * Math.sin(f * 0.12 + i)})`;
        ctx.fillRect(bx2 + 0.5 * s, oy + 12 * s - h, s, h * 0.4);
      }

      // PATTES avant
      ctx.fillStyle = rageMode ? '#6a0000' : '#0d2848';
      ctx.fillRect(ox + 8 * s, oy + 24 * s + legL, 6 * s, 8 * s);
      ctx.fillRect(ox + 18 * s, oy + 24 * s + legR, 6 * s, 8 * s);
      // Griffes
      const clawCol = rageMode ? '#cc3300' : '#4080c0';
      for (let i = 0; i < 3; i++) {
        ctx.fillStyle = '#aaa';
        ctx.fillRect(ox + (8 + i * 2) * s, oy + 31 * s + legL, 2 * s, 4 * s);
        ctx.fillRect(ox + (18 + i * 2) * s, oy + 31 * s + legR, 2 * s, 4 * s);
        // Base griffes color√©e
        ctx.fillStyle = clawCol;
        ctx.fillRect(ox + (8 + i * 2) * s, oy + 31 * s + legL, 2 * s, s);
        ctx.fillRect(ox + (18 + i * 2) * s, oy + 31 * s + legR, 2 * s, s);
      }

      // ‚îÄ‚îÄ COU ‚îÄ‚îÄ
      ctx.fillStyle = rageMode ? '#7a0000' : '#0f2a50';
      ctx.fillRect(ox + 4 * s, oy + 8 * s, 12 * s, 8 * s);
      // √âcailles cou
      ctx.fillStyle = rageMode ? '#9b1000' : '#1a3a60';
      for (let i = 0; i < 3; i++) {
        ctx.fillRect(ox + (4 + i * 3.5) * s, oy + 8 * s, 3 * s, 3 * s);
      }

      // ‚îÄ‚îÄ T√äTE ‚îÄ‚îÄ
      ctx.fillStyle = rageMode ? '#9b0000' : '#152840';
      ctx.fillRect(ox - 2 * s, oy + 2 * s, 18 * s, 12 * s);
      // Cr√¢ne
      ctx.fillStyle = rageMode ? '#7a0000' : '#0d2030';
      ctx.fillRect(ox - 2 * s, oy + 2 * s, 18 * s, 6 * s);

      // CORNES de t√™te (anim√©es)
      const hornAng = Math.sin(f * 0.04) * 0.06;
      ctx.save(); ctx.translate(ox + 0, oy + 2 * s);
      ctx.rotate(-hornAng);
      ctx.fillStyle = rageMode ? '#cc3300' : '#2060a0';
      ctx.beginPath();
      ctx.moveTo(0, 0); ctx.lineTo(-3 * s, -10 * s); ctx.lineTo(3 * s, 0);
      ctx.closePath(); ctx.fill();
      ctx.fillStyle = rageMode ? '#ff6600' : '#60b0ff';
      ctx.fillRect(-s, -10 * s, 2 * s, 2 * s);
      ctx.restore();
      ctx.save(); ctx.translate(ox + 14 * s, oy + 2 * s);
      ctx.rotate(hornAng);
      ctx.fillStyle = rageMode ? '#cc3300' : '#2060a0';
      ctx.beginPath();
      ctx.moveTo(0, 0); ctx.lineTo(3 * s, -10 * s); ctx.lineTo(-3 * s, 0);
      ctx.closePath(); ctx.fill();
      ctx.fillStyle = rageMode ? '#ff6600' : '#60b0ff';
      ctx.fillRect(-s, -10 * s, 2 * s, 2 * s);
      ctx.restore();

      // YEUX dragon (fendus, pulsants)
      const blinkDragon = (f % 110) > 4;
      // Halo
      ctx.fillStyle = rageMode ? `rgba(255,120,0,${0.5 + 0.4 * pulse})` : `rgba(0,180,255,${0.45 + 0.35 * pulse})`;
      ctx.fillRect(ox + 0, oy + 4 * s, 6 * s, 5 * s);
      ctx.fillRect(ox + 8 * s, oy + 4 * s, 6 * s, 5 * s);
      // Iris
      const dragonEyeH = blinkDragon ? 4 * s : s;
      ctx.fillStyle = rageMode ? `rgb(255,${80 + Math.floor(80 * fastPulse)},0)` : `rgb(0,${180 + Math.floor(75 * pulse)},255)`;
      ctx.fillRect(ox + s, oy + 5 * s, 4 * s, dragonEyeH);
      ctx.fillRect(ox + 9 * s, oy + 5 * s, 4 * s, dragonEyeH);
      // Pupille verticale
      if (blinkDragon) {
        ctx.fillStyle = '#000';
        ctx.fillRect(ox + 2 * s, oy + 5 * s, 2 * s, 4 * s);
        ctx.fillRect(ox + 10 * s, oy + 5 * s, 2 * s, 4 * s);
        // Reflet
        ctx.fillStyle = 'rgba(255,255,255,0.7)';
        ctx.fillRect(ox + s, oy + 5 * s, s, s);
        ctx.fillRect(ox + 9 * s, oy + 5 * s, s, s);
      }

      // GUEULE (m√¢choire anim√©e l√©g√®rement)
      const mawOpen = rageMode ? 2 + Math.sin(f * 0.15) * 1.5 : 1;
      ctx.fillStyle = rageMode ? '#7a0000' : '#0d2030';
      ctx.fillRect(ox - 2 * s, oy + (11 + mawOpen) * s, 14 * s, 4 * s);
      // Lueur gueule
      ctx.fillStyle = rageMode
        ? `rgba(255,${80 + 60 * pulse},0,${0.6 + 0.3 * pulse})`
        : `rgba(0,150,255,${0.35 + 0.2 * pulse})`;
      ctx.fillRect(ox - s, oy + (12 + mawOpen) * s, 12 * s, 2 * s);
      // Crocs
      ctx.fillStyle = '#e8e4d8';
      for (let i = 0; i < 5; i++) {
        ctx.fillRect(ox + (i * 2.5 - 1) * s, oy + (11 + mawOpen) * s, 2 * s, 3 * s);
      }

      // Flamme / souffle (rage)
      if (rageMode) {
        for (let i = 0; i < 6; i++) {
          const fh3 = (5 + Math.sin(f * 0.35 + i * 0.9) * 3) * s;
          const fw3 = (3 + Math.sin(f * 0.2 + i * 1.1)) * s;
          const fx3 = ox + (i * 2.2 - 2) * s;
          ctx.fillStyle = `rgba(255,${50 + i * 30},0,${0.7 + 0.2 * Math.sin(f * 0.4 + i)})`;
          ctx.beginPath();
          ctx.moveTo(fx3, oy + (12 + mawOpen) * s);
          ctx.lineTo(fx3 + fw3 * 0.5, oy + (12 + mawOpen) * s - fh3);
          ctx.lineTo(fx3 + fw3, oy + (12 + mawOpen) * s);
          ctx.closePath(); ctx.fill();
        }
      }

      // Narines
      ctx.fillStyle = rageMode ? '#ff3300' : '#003060';
      ctx.fillRect(ox + s, oy + 9 * s, 2 * s, 2 * s);
      ctx.fillRect(ox + 5 * s, oy + 9 * s, 2 * s, 2 * s);

      ctx.restore(); // bodyBreath
      ctx.restore();
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ‚îÄ‚îÄ‚îÄ ARAKHNE LA TISSEUSE ‚Äî Grande Araign√©e D√©moniaque ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function drawSpider(ctx, cx, cy, frame, scale = 2.6, alpha = 1, rageMode = false) {
      const s = scale; ctx.save(); ctx.translate(cx, cy); ctx.globalAlpha *= alpha;
      const f = GS.frame;
      const pulse = (Math.sin(f * 0.1) + 1) / 2;
      const fastPulse = (Math.sin(f * 0.22) + 1) / 2;
      const bodyBob = Math.sin(f * 0.07) * 2 * s;
      const legWave = f * 0.12;

      ctx.save(); ctx.translate(0, bodyBob);

      // Aura venin
      const venom = ctx.createRadialGradient(0, 0, 3*s, 0, 0, 32*s);
      venom.addColorStop(0, rageMode ? `rgba(200,0,30,${0.3+0.15*pulse})` : `rgba(80,0,120,${0.22+0.12*pulse})`);
      venom.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = venom;
      ctx.beginPath(); ctx.arc(0, 0, 32*s, 0, Math.PI*2); ctx.fill();

      // 8 pattes (4 de chaque c√¥t√©)
      const legColors = rageMode ? ['#5a0015','#8a0025','#4a0012'] : ['#1a0030','#2a0048','#180028'];
      for (let side = -1; side <= 1; side += 2) {
        for (let li = 0; li < 4; li++) {
          const baseY = (li - 1.5) * 5 * s;
          const wave = Math.sin(legWave + li * 0.8 + (side > 0 ? 0.4 : 0)) * 8 * s;
          const kx = side * (12 + li * 3) * s;
          const ex = side * (30 + li * 4) * s;
          const ey = baseY + wave;
          ctx.strokeStyle = legColors[li % 3]; ctx.lineWidth = 2.5 * s; ctx.lineCap = 'round';
          ctx.beginPath();
          ctx.moveTo(side * 10 * s, baseY);
          ctx.quadraticCurveTo(kx, baseY - 8*s, ex, ey);
          ctx.stroke();
          ctx.fillStyle = rageMode ? '#ff0030' : '#6600aa';
          ctx.beginPath(); ctx.arc(ex, ey, 2 * s, 0, Math.PI*2); ctx.fill();
        }
      }

      // Abdomen
      const abdGrad = ctx.createRadialGradient(0, 8*s, 2*s, 0, 8*s, 12*s);
      abdGrad.addColorStop(0, rageMode ? '#3a0010' : '#1a0040');
      abdGrad.addColorStop(1, '#000');
      ctx.fillStyle = abdGrad;
      ctx.beginPath(); ctx.ellipse(0, 8*s, 12*s, 9*s, 0, 0, Math.PI*2); ctx.fill();
      // Motif sablier venimeux
      ctx.fillStyle = rageMode ? `rgba(255,0,40,${0.7+0.3*pulse})` : `rgba(160,0,255,${0.6+0.25*pulse})`;
      ctx.beginPath();
      ctx.moveTo(-4*s, 5*s); ctx.lineTo(4*s, 5*s); ctx.lineTo(2*s, 8*s); ctx.lineTo(4*s, 11*s); ctx.lineTo(-4*s, 11*s); ctx.lineTo(-2*s, 8*s);
      ctx.closePath(); ctx.fill();
      ctx.strokeStyle = rageMode ? '#ff0044' : '#8800cc'; ctx.lineWidth = s;
      ctx.beginPath(); ctx.ellipse(0, 8*s, 12*s, 9*s, 0, 0, Math.PI*2); ctx.stroke();

      // Corps central
      const bodyGrad = ctx.createRadialGradient(-2*s, -4*s, s, 0, 0, 10*s);
      bodyGrad.addColorStop(0, rageMode ? '#4a0018' : '#1e0038');
      bodyGrad.addColorStop(1, '#000');
      ctx.fillStyle = bodyGrad;
      ctx.beginPath(); ctx.ellipse(0, 0, 10*s, 8*s, 0, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = rageMode ? '#cc0030' : '#4400aa'; ctx.lineWidth = s*0.8;
      ctx.beginPath(); ctx.ellipse(0, 0, 10*s, 8*s, 0, 0, Math.PI*2); ctx.stroke();

      // 8 yeux (arrangement 2-4-2)
      const eyeRows = [[-8, [-3.5, 3.5]], [-5, [-6, -2, 2, 6]], [-3, [-4, 4]]];
      for (const [ey2, exs] of eyeRows) {
        for (const ex2 of exs) {
          ctx.fillStyle = '#000';
          ctx.beginPath(); ctx.arc(ex2*s, ey2*s, 2*s, 0, Math.PI*2); ctx.fill();
          ctx.fillStyle = rageMode ? `rgba(255,0,50,${0.8+0.2*fastPulse})` : `rgba(200,0,255,${0.7+0.25*pulse})`;
          ctx.beginPath(); ctx.arc(ex2*s, ey2*s, 1.5*s, 0, Math.PI*2); ctx.fill();
          ctx.fillStyle = `rgba(255,255,255,0.65)`;
          ctx.beginPath(); ctx.arc(ex2*s-0.4*s, ey2*s-0.4*s, 0.5*s, 0, Math.PI*2); ctx.fill();
        }
      }

      // Crochets venimeux
      ctx.strokeStyle = rageMode ? '#ffaa00' : '#88ddaa'; ctx.lineWidth = 2*s; ctx.lineCap = 'round';
      const fangDrip = Math.sin(f * 0.15) * 1.5 * s;
      ctx.beginPath(); ctx.moveTo(-5*s, -2*s); ctx.quadraticCurveTo(-8*s, 1*s, -6*s, 5*s + fangDrip); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(5*s, -2*s); ctx.quadraticCurveTo(8*s, 1*s, 6*s, 5*s + fangDrip); ctx.stroke();
      ctx.fillStyle = rageMode ? `rgba(255,120,0,${0.7+0.2*pulse})` : `rgba(80,255,100,${0.6+0.3*pulse})`;
      if (pulse > 0.5) {
        ctx.beginPath(); ctx.arc(-6*s, 5*s+fangDrip+s, s, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(6*s, 5*s+fangDrip+s, s, 0, Math.PI*2); ctx.fill();
      }

      // Fils orbitaux (rage)
      if (rageMode) {
        ctx.strokeStyle = `rgba(200,0,80,${0.4+0.2*pulse})`; ctx.lineWidth = s * 0.6;
        for (let w = 0; w < 3; w++) {
          const wa = f * 0.04 + w * 2.1, wr = (24 + w * 6) * s;
          ctx.beginPath(); ctx.arc(0, 0, wr, wa, wa + Math.PI * 0.8); ctx.stroke();
        }
      }

      ctx.restore();
      ctx.restore();
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ‚îÄ‚îÄ‚îÄ ZARVETH LE COLOSSE PRISMATIQUE ‚Äî Titan de Cristal ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function drawCrystal(ctx, cx, cy, dir, frame, scale = 2.7, alpha = 1, rageMode = false) {
      const s = scale; ctx.save(); ctx.translate(cx, cy); ctx.globalAlpha *= alpha;
      if (dir === 1) ctx.scale(-1, 1);
      const f = GS.frame;
      const ox = -16 * s, oy = -22 * s;
      const pulse = (Math.sin(f * 0.09) + 1) / 2;
      const fastPulse = (Math.sin(f * 0.21) + 1) / 2;
      const breathe = Math.sin(f * 0.06) * 1.5 * s;
      const float = Math.sin(f * 0.045) * 2 * s;

      ctx.save(); ctx.translate(0, float);

      // Aura cristalline
      const aura = ctx.createRadialGradient(0, 0, 5*s, 0, 0, 38*s);
      aura.addColorStop(0, rageMode ? `rgba(255,100,0,${0.3+0.2*pulse})` : `rgba(0,180,255,${0.25+0.15*pulse})`);
      aura.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = aura;
      ctx.beginPath(); ctx.arc(0, 0, 38*s, 0, Math.PI*2); ctx.fill();

      // Cristaux d'√©paule
      const crownC = rageMode ? ['#cc3300','#ee5500','#ff8800'] : ['#004488','#0066cc','#0088ff'];
      for (let i = 0; i < 3; i++) {
        ctx.fillStyle = crownC[i];
        ctx.save(); ctx.translate(ox + (-2+i*2)*s, oy + (10-i*3)*s); ctx.rotate(-0.5-i*0.2);
        const h=(8+i*3)*s, w=(4-i)*s;
        ctx.beginPath(); ctx.moveTo(-w,h); ctx.lineTo(0,0); ctx.lineTo(w,h); ctx.closePath(); ctx.fill();
        ctx.restore();
        ctx.save(); ctx.translate(ox + (30+i*2)*s, oy + (10-i*3)*s); ctx.rotate(0.5+i*0.2);
        ctx.fillStyle = crownC[i];
        ctx.beginPath(); ctx.moveTo(-w,h); ctx.lineTo(0,0); ctx.lineTo(w,h); ctx.closePath(); ctx.fill();
        ctx.restore();
      }

      // Corps hexagonal
      const hx = ox + 16*s, hy = oy + 22*s, hr = 16*s;
      const bodyGrad = ctx.createLinearGradient(ox, oy+10*s, ox+32*s, oy+35*s);
      bodyGrad.addColorStop(0, rageMode ? '#3a1000' : '#001a40');
      bodyGrad.addColorStop(1, rageMode ? '#100400' : '#00040e');
      ctx.fillStyle = bodyGrad;
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const a = i * Math.PI/3 - Math.PI/6;
        const px = hx + Math.cos(a) * hr, py = hy + Math.sin(a) * hr * (1 + breathe/(16*s));
        i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
      }
      ctx.closePath(); ctx.fill();
      // Facettes
      ctx.strokeStyle = rageMode ? `rgba(255,120,0,${0.4+0.3*pulse})` : `rgba(0,220,255,${0.35+0.25*pulse})`; ctx.lineWidth = s * 0.8;
      for (let i = 0; i < 6; i++) {
        const a = i * Math.PI/3 - Math.PI/6;
        ctx.beginPath(); ctx.moveTo(hx, hy); ctx.lineTo(hx+Math.cos(a)*hr*0.7, hy+Math.sin(a)*hr*0.7); ctx.stroke();
      }
      ctx.strokeStyle = rageMode ? `rgba(255,80,0,${0.6+0.3*pulse})` : `rgba(0,180,255,${0.5+0.3*pulse})`; ctx.lineWidth = s * 1.5;
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const a = i * Math.PI/3 - Math.PI/6;
        const px = hx+Math.cos(a)*hr, py = hy+Math.sin(a)*hr;
        i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
      }
      ctx.closePath(); ctx.stroke();

      // Gemme centrale
      ctx.shadowColor = rageMode ? '#ff4400' : '#00ccff'; ctx.shadowBlur = 18 + pulse * 14;
      ctx.fillStyle = rageMode ? `rgba(255,${60+80*fastPulse|0},0,0.95)` : `rgba(0,${160+80*fastPulse|0},255,0.95)`;
      ctx.beginPath(); ctx.arc(hx, hy, (5+pulse*2)*s, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = `rgba(255,255,255,${0.7+0.3*fastPulse})`;
      ctx.beginPath(); ctx.arc(hx-s, hy-s, 2*s, 0, Math.PI*2); ctx.fill();
      ctx.shadowBlur = 0;

      // Bras gauche
      ctx.save(); ctx.translate(ox, oy+14*s);
      const armL = Math.sin(f*0.07)*3*s;
      ctx.fillStyle = rageMode ? '#1a0800' : '#001230';
      ctx.fillRect(-3*s, 0, 7*s, 14*s);
      ctx.fillStyle = rageMode ? '#ff5500' : '#0088ff';
      ctx.beginPath(); ctx.moveTo(-3*s,2*s+armL); ctx.lineTo(-5*s,-3*s+armL); ctx.lineTo(-1*s,2*s+armL); ctx.closePath(); ctx.fill();
      ctx.fillStyle = rageMode ? '#2a0c00' : '#001838'; ctx.fillRect(-4*s,14*s,9*s,6*s);
      ctx.restore();

      // Bras droit
      ctx.save(); ctx.translate(ox+32*s, oy+14*s);
      const armR = -armL;
      ctx.fillStyle = rageMode ? '#1a0800' : '#001230';
      ctx.fillRect(-4*s, 0, 7*s, 14*s);
      ctx.fillStyle = rageMode ? '#ff5500' : '#0088ff';
      ctx.beginPath(); ctx.moveTo(3*s,2*s+armR); ctx.lineTo(5*s,-3*s+armR); ctx.lineTo(1*s,2*s+armR); ctx.closePath(); ctx.fill();
      ctx.fillStyle = rageMode ? '#2a0c00' : '#001838'; ctx.fillRect(-5*s,14*s,9*s,6*s);
      ctx.restore();

      // T√™te
      ctx.fillStyle = rageMode ? '#1a0600' : '#000e20';
      ctx.fillRect(ox+8*s, oy, 16*s, 12*s);
      for (let i = 0; i < 5; i++) {
        const h = (5+(i%2)*4)*s;
        ctx.fillStyle = crownC[i%3];
        ctx.beginPath(); ctx.moveTo(ox+(8+i*3.5)*s, oy); ctx.lineTo(ox+(9.75+i*3.5)*s, oy-h); ctx.lineTo(ox+(11.5+i*3.5)*s, oy); ctx.closePath(); ctx.fill();
      }
      // 3 yeux en triangle
      const eyeDat = [[-4,3],[0,0],[4,3]];
      for (const [ex2, ey2] of eyeDat) {
        const eB = (f%90)>3;
        ctx.fillStyle = '#000'; ctx.fillRect(ox+(12+ex2)*s, oy+(4+ey2)*s, 5*s, eB?4*s:s);
        ctx.fillStyle = rageMode ? `rgba(255,${80+60*fastPulse|0},0,0.95)` : `rgba(0,${180+70*fastPulse|0},255,0.95)`;
        ctx.fillRect(ox+(13+ex2)*s, oy+(4+ey2)*s, 4*s, eB?3*s:s*0.8);
        if (eB) { ctx.fillStyle='rgba(255,255,255,0.7)'; ctx.fillRect(ox+(13+ex2)*s, oy+(4+ey2)*s, s, s); }
      }
      ctx.fillStyle='#000'; ctx.fillRect(ox+10*s, oy+9*s, 12*s, 3*s);
      ctx.fillStyle = rageMode?`rgba(255,60,0,${0.5+0.3*pulse})`:`rgba(0,200,255,${0.4+0.3*pulse})`;
      for (let i=0;i<4;i++) ctx.fillRect(ox+(10+i*3)*s, oy+9*s, 2*s, 3*s);

      // Jambes
      const legPh = (f%32)/32, legL2 = Math.sin(legPh*Math.PI*2)*4*s;
      ctx.fillStyle = rageMode?'#200800':'#001228';
      ctx.fillRect(ox+6*s, oy+38*s+legL2, 7*s, 8*s);
      ctx.fillRect(ox+19*s, oy+38*s-legL2, 7*s, 8*s);
      ctx.fillStyle = rageMode?'#cc3300':'#0055aa';
      ctx.fillRect(ox+4*s, oy+45*s+legL2, 10*s, 3*s);
      ctx.fillRect(ox+17*s, oy+45*s-legL2, 10*s, 3*s);

      // Particules (rage)
      if (rageMode) {
        for (let i=0;i<6;i++) {
          const pa=f*0.05+i*1.05, pr=(20+Math.sin(f*0.12+i)*6)*s;
          ctx.fillStyle=`rgba(255,${80+30*i},0,${0.5+0.3*Math.sin(f*0.18+i)})`;
          ctx.beginPath(); ctx.arc(Math.cos(pa)*pr, Math.sin(pa)*pr*0.5, (1.5+Math.sin(f*0.15+i))*s, 0, Math.PI*2); ctx.fill();
        }
      }

      ctx.restore(); // float
      ctx.restore();
    }

        // ‚îÄ‚îÄ‚îÄ ZOMBIE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawZombie(ctx, cx, cy, dir, frame, scale = 1.8, alpha = 1) {
      const s = scale; ctx.save(); ctx.translate(cx, cy); ctx.globalAlpha *= alpha;
      if (dir < 0) { ctx.scale(-1, 1); }
      const ox = -8 * s, oy = -13 * s;
      const legOff = frame === 1 ? -s : frame === 2 ? s : 0;
      // Corps
      ctx.fillStyle = '#3a6a2a';
      ctx.fillRect(ox + 2 * s, oy + 9 * s, 12 * s, 10 * s);
      // D√©chirures
      ctx.fillStyle = '#2a5020';
      ctx.fillRect(ox + 4 * s, oy + 10 * s, 2 * s, 5 * s);
      ctx.fillRect(ox + 10 * s, oy + 12 * s, 2 * s, 4 * s);
      // T√™te
      ctx.fillStyle = '#4a7a38';
      ctx.fillRect(ox + 3 * s, oy + 1 * s, 10 * s, 9 * s);
      // Plaie
      ctx.fillStyle = '#8b0000';
      ctx.fillRect(ox + 5 * s, oy + 4 * s, 6 * s, 2 * s);
      // Yeux jaunes
      ctx.fillStyle = '#aaff00';
      ctx.fillRect(ox + 4 * s, oy + 2 * s, 3 * s, 3 * s);
      ctx.fillRect(ox + 9 * s, oy + 2 * s, 3 * s, 3 * s);
      ctx.fillStyle = '#000';
      ctx.fillRect(ox + 5 * s, oy + 3 * s, s, s);
      ctx.fillRect(ox + 10 * s, oy + 3 * s, s, s);
      // Bouche
      ctx.fillStyle = '#1a0000';
      ctx.fillRect(ox + 4 * s, oy + 7 * s, 8 * s, 2 * s);
      ctx.fillStyle = '#cc2200'; ctx.fillRect(ox + 6 * s, oy + 7 * s, 4 * s, s);
      // Bras tendus (zombie!)
      ctx.fillStyle = '#3a6a2a';
      ctx.fillRect(ox - 2 * s, oy + 9 * s, 4 * s, 3 * s); // bras gauche tendu
      ctx.fillRect(ox + 14 * s, oy + 8 * s, 4 * s, 3 * s);// bras droit tendu
      ctx.fillRect(ox - 4 * s, oy + 10 * s, 3 * s, s);   // main g
      ctx.fillRect(ox + 16 * s, oy + 9 * s, 3 * s, s);   // main d
      // Jambes lentes
      ctx.fillStyle = '#2a5020';
      ctx.fillRect(ox + 3 * s, oy + 19 * s + legOff, 4 * s, 4 * s);
      ctx.fillRect(ox + 9 * s, oy + 19 * s - legOff, 4 * s, 4 * s);
      ctx.fillStyle = '#1a3010';
      ctx.fillRect(ox + 2 * s, oy + 22 * s + legOff, 5 * s, 2 * s);
      ctx.fillRect(ox + 8 * s, oy + 22 * s - legOff, 5 * s, 2 * s);
      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ SQUELETTE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawSkeleton(ctx, cx, cy, dir, frame, scale = 1.8, alpha = 1) {
      const s = scale; ctx.save(); ctx.translate(cx, cy); ctx.globalAlpha *= alpha;
      if (dir < 0) ctx.scale(-1, 1);
      const ox = -7 * s, oy = -14 * s;
      const legOff = frame === 1 ? -s * 1.5 : frame === 2 ? s * 1.5 : 0;
      const armOff = frame === 1 ? s : frame === 2 ? -s : 0;
      // Jambes
      ctx.fillStyle = '#d4ccb0';
      ctx.fillRect(ox + 2 * s, oy + 19 * s + legOff,  3 * s, 6 * s);
      ctx.fillRect(ox + 9 * s, oy + 19 * s - legOff,  3 * s, 6 * s);
      // Pieds
      ctx.fillStyle = '#bfb89a';
      ctx.fillRect(ox + 1 * s, oy + 24 * s + legOff,  4 * s, 2 * s);
      ctx.fillRect(ox + 8 * s, oy + 24 * s - legOff,  4 * s, 2 * s);
      // Bassin
      ctx.fillStyle = '#c8c0a0';
      ctx.fillRect(ox + 1 * s, oy + 17 * s, 12 * s, 3 * s);
      // Colonne vert√©brale
      ctx.fillStyle = '#d4ccb0';
      for (let i = 0; i < 4; i++) ctx.fillRect(ox + 5 * s, oy + (9 + i * 2) * s, 4 * s, s);
      // Cage thoracique
      ctx.fillStyle = '#bfb89a';
      ctx.fillRect(ox + 2 * s, oy + 8 * s, 10 * s, 9 * s);
      ctx.fillStyle = '#0a0a08'; // ombre int√©rieure
      for (let i = 0; i < 3; i++) {
        ctx.fillRect(ox + 3 * s, oy + (9 + i * 2) * s, 3 * s, s);
        ctx.fillRect(ox + 8 * s, oy + (9 + i * 2) * s, 3 * s, s);
      }
      // √âpaules + bras
      ctx.fillStyle = '#d4ccb0';
      ctx.fillRect(ox - 1 * s, oy + 8 * s, 3 * s, 2 * s);  // √©paule G
      ctx.fillRect(ox + 12 * s, oy + 8 * s, 3 * s, 2 * s); // √©paule D
      // Avant-bras avec animation
      ctx.fillRect(ox - 2 * s, oy + (10 + armOff) * s, 3 * s, 6 * s);
      ctx.fillRect(ox + 13 * s, oy + (10 - armOff) * s, 3 * s, 6 * s);
      // Mains
      ctx.fillStyle = '#c8c0a0';
      ctx.fillRect(ox - 3 * s, oy + (15 + armOff) * s, 4 * s, 2 * s);
      ctx.fillRect(ox + 13 * s, oy + (15 - armOff) * s, 4 * s, 2 * s);
      // Cr√¢ne
      ctx.fillStyle = '#e0d8c0';
      ctx.fillRect(ox + 2 * s, oy + 1 * s, 10 * s, 8 * s);
      ctx.fillStyle = '#d4ccb0';
      ctx.fillRect(ox + 1 * s, oy + 3 * s, 12 * s, 5 * s); // √©largissement
      // M√¢choire
      ctx.fillStyle = '#c8c0a0';
      ctx.fillRect(ox + 3 * s, oy + 7 * s, 8 * s, 3 * s);
      // Dents
      ctx.fillStyle = '#fff';
      for (let i = 0; i < 4; i++) ctx.fillRect(ox + (3 + i * 2) * s, oy + 9 * s, s, s);
      // Yeux creux
      ctx.fillStyle = '#000';
      ctx.fillRect(ox + 2 * s, oy + 2 * s, 3 * s, 3 * s);
      ctx.fillRect(ox + 9 * s, oy + 2 * s, 3 * s, 3 * s);
      // Lueur yeux
      const glowPulse = (Math.sin(GS.frame * 0.09) + 1) / 2;
      ctx.fillStyle = `rgba(0,220,100,${0.55 + 0.35 * glowPulse})`;
      ctx.fillRect(ox + 3 * s, oy + 3 * s, s, s);
      ctx.fillRect(ox + 10 * s, oy + 3 * s, s, s);
      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ FANT√îME ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawGhost(ctx, cx, cy, frame, scale = 1.7, alpha = 1) {
      const s = scale; ctx.save(); ctx.translate(cx, cy); ctx.globalAlpha *= alpha;
      const ox = -7 * s, oy = -11 * s;
      const float = Math.sin(GS.frame * 0.08) * 3;
      const pulse = (Math.sin(GS.frame * 0.12) + 1) / 2;
      // Corps translucide
      ctx.fillStyle = `rgba(180,200,255,${0.65 + 0.15 * pulse})`;
      ctx.beginPath();
      ctx.arc(ox + 7 * s, oy + 6 * s + float, 7 * s, Math.PI, 0);
      ctx.lineTo(ox + 14 * s, oy + 14 * s + float);
      // bord ondul√© bas
      for (let i = 0; i < 3; i++) {
        ctx.lineTo(ox + (12 - i * 4) * s, oy + (12 + i % 2 * 3) * s + float);
      }
      ctx.lineTo(ox + 0 * s, oy + 14 * s + float);
      ctx.closePath(); ctx.fill();
      // Yeux
      ctx.fillStyle = `rgba(40,0,120,${0.9})`;
      ctx.fillRect(ox + 3 * s, oy + 4 * s + float, 3 * s, 4 * s);
      ctx.fillRect(ox + 8 * s, oy + 4 * s + float, 3 * s, 4 * s);
      // reflet yeux
      ctx.fillStyle = `rgba(150,150,255,0.8)`;
      ctx.fillRect(ox + 3 * s, oy + 4 * s + float, s, s);
      ctx.fillRect(ox + 8 * s, oy + 4 * s + float, s, s);
      // Bouche
      ctx.fillStyle = `rgba(40,0,120,0.7)`;
      ctx.fillRect(ox + 4 * s, oy + 9 * s + float, 6 * s, 2 * s);
      // tra√Æn√© fant√¥me
      ctx.fillStyle = `rgba(180,200,255,${0.12 * pulse})`;
      ctx.fillRect(ox + 2 * s, oy + 14 * s + float, 10 * s, 4 * s);
      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ CHEVALIER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawKnight(ctx, cx, cy, dir, frame, scale = 1.8, alpha = 1) {
      const s = scale; ctx.save(); ctx.translate(cx, cy); ctx.globalAlpha *= alpha;
      if (dir < 0) ctx.scale(-1, 1);
      const ox = -8 * s, oy = -14 * s;
      const legOff = frame === 1 ? -s : frame === 2 ? s : 0;
      // Bouclier
      ctx.fillStyle = '#c8a020';
      ctx.fillRect(ox - 2 * s, oy + 9 * s, 5 * s, 8 * s);
      ctx.fillStyle = '#8b5e00'; ctx.fillRect(ox - s, oy + 10 * s, 3 * s, 6 * s);
      ctx.fillStyle = '#ffd700'; ctx.fillRect(ox, oy + 12 * s, s, 2 * s);
      // Corps armure
      ctx.fillStyle = '#888888';
      ctx.fillRect(ox + 3 * s, oy + 8 * s, 12 * s, 12 * s);
      ctx.fillStyle = '#aaaaaa'; ctx.fillRect(ox + 4 * s, oy + 9 * s, 10 * s, 5 * s);
      // D√©tails armure
      ctx.fillStyle = '#666'; ctx.fillRect(ox + 4 * s, oy + 13 * s, 10 * s, s);
      ctx.fillStyle = '#c8a020'; ctx.fillRect(ox + 8 * s, oy + 10 * s, 2 * s, 3 * s);
      // Casque
      ctx.fillStyle = '#777';
      ctx.fillRect(ox + 3 * s, oy + 1 * s, 12 * s, 8 * s);
      ctx.fillStyle = '#999'; ctx.fillRect(ox + 4 * s, oy + 2 * s, 10 * s, 4 * s);
      // Visi√®re
      ctx.fillStyle = '#333'; ctx.fillRect(ox + 5 * s, oy + 5 * s, 8 * s, 3 * s);
      // Yeux (fente)
      ctx.fillStyle = '#ff6600';
      ctx.fillRect(ox + 5 * s, oy + 5 * s, 3 * s, s);
      ctx.fillRect(ox + 10 * s, oy + 5 * s, 3 * s, s);
      // Plumet
      ctx.fillStyle = '#cc0000';
      ctx.fillRect(ox + 7 * s, oy - 2 * s, 4 * s, 4 * s);
      ctx.fillRect(ox + 8 * s, oy - 4 * s, 2 * s, 3 * s);
      // Bras + √©p√©e
      ctx.fillStyle = '#777';
      ctx.fillRect(ox + 15 * s, oy + 8 * s, 3 * s, 6 * s);
      // √âp√©e
      ctx.fillStyle = '#ccc'; ctx.fillRect(ox + 17 * s, oy + 2 * s, 2 * s, 10 * s);
      ctx.fillStyle = '#c8a020'; ctx.fillRect(ox + 15 * s, oy + 8 * s, 6 * s, 2 * s);
      ctx.fillStyle = '#888'; ctx.fillRect(ox + 17 * s, oy + 11 * s, 2 * s, s);
      // Jambes
      ctx.fillStyle = '#666';
      ctx.fillRect(ox + 4 * s, oy + 20 * s + legOff, 4 * s, 5 * s);
      ctx.fillRect(ox + 10 * s, oy + 20 * s - legOff, 4 * s, 5 * s);
      ctx.fillStyle = '#444';
      ctx.fillRect(ox + 3 * s, oy + 24 * s + legOff, 5 * s, 2 * s);
      ctx.fillRect(ox + 9 * s, oy + 24 * s - legOff, 5 * s, 2 * s);
      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ G√âANT DE GLACE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawIceGiant(ctx, cx, cy, dir, frame, scale = 2.0, alpha = 1) {
      const s = scale; ctx.save(); ctx.translate(cx, cy); ctx.globalAlpha *= alpha;
      if (dir < 0) ctx.scale(-1, 1);
      const ox = -11 * s, oy = -16 * s;
      const legOff = frame === 1 ? -s * 1.5 : frame === 2 ? s * 1.5 : 0;
      const pulse = (Math.sin(GS.frame * 0.08) + 1) / 2;
      // Aura glace
      ctx.fillStyle = `rgba(100,200,255,${0.1 + 0.08 * pulse})`;
      ctx.beginPath(); ctx.ellipse(0, 4 * s, 18 * s, 10 * s, 0, 0, Math.PI * 2); ctx.fill();
      // Corps massif glace
      ctx.fillStyle = '#4488cc';
      ctx.fillRect(ox + 3 * s, oy + 10 * s, 16 * s, 16 * s);
      // Cristaux dos
      ctx.fillStyle = '#88ccff';
      ctx.fillRect(ox + 5 * s, oy + 10 * s, 12 * s, 3 * s);
      // Ventre
      ctx.fillStyle = '#66aaee';
      ctx.fillRect(ox + 5 * s, oy + 16 * s, 12 * s, 7 * s);
      // Craquelures glace
      ctx.strokeStyle = '#aaddff'; ctx.lineWidth = s * 0.5;
      ctx.beginPath(); ctx.moveTo(ox + 6 * s, oy + 14 * s); ctx.lineTo(ox + 10 * s, oy + 20 * s); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(ox + 14 * s, oy + 13 * s); ctx.lineTo(ox + 11 * s, oy + 19 * s); ctx.stroke();
      // Cristaux √©paules
      ctx.fillStyle = '#aaddff';
      ctx.beginPath(); ctx.moveTo(ox + 2 * s, oy + 10 * s); ctx.lineTo(ox, oy + 6 * s); ctx.lineTo(ox + 4 * s, oy + 10 * s); ctx.closePath(); ctx.fill();
      ctx.beginPath(); ctx.moveTo(ox + 18 * s, oy + 10 * s); ctx.lineTo(ox + 22 * s, oy + 6 * s); ctx.lineTo(ox + 20 * s, oy + 10 * s); ctx.closePath(); ctx.fill();
      // Bras
      ctx.fillStyle = '#3377bb';
      ctx.fillRect(ox + 0 * s, oy + 10 * s, 4 * s, 10 * s);
      ctx.fillRect(ox + 18 * s, oy + 10 * s, 4 * s, 10 * s);
      // Poings
      ctx.fillStyle = '#4488cc'; ctx.fillRect(ox - s, oy + 19 * s, 5 * s, 4 * s);
      ctx.fillStyle = '#4488cc'; ctx.fillRect(ox + 18 * s, oy + 19 * s, 5 * s, 4 * s);
      // Cristaux poings
      ctx.fillStyle = '#88ddff'; ctx.fillRect(ox - 2 * s, oy + 18 * s, 2 * s, 3 * s); ctx.fillRect(ox + 22 * s, oy + 18 * s, 2 * s, 3 * s);
      // T√™te
      ctx.fillStyle = '#3377bb';
      ctx.fillRect(ox + 4 * s, oy + 3 * s, 14 * s, 8 * s);
      // Cr√™te cristaux
      ctx.fillStyle = '#aaddff';
      for (let i = 0; i < 3; i++) { ctx.beginPath(); ctx.moveTo(ox + (5 + i * 4) * s, oy + 3 * s); ctx.lineTo(ox + (6 + i * 4) * s, oy, oy + 0 * s); ctx.lineTo(ox + (7 + i * 4) * s, oy + 3 * s); ctx.closePath(); ctx.fill(); }
      // Yeux
      ctx.fillStyle = '#00ccff';
      ctx.fillRect(ox + 5 * s, oy + 5 * s, 4 * s, 3 * s);
      ctx.fillRect(ox + 13 * s, oy + 5 * s, 4 * s, 3 * s);
      ctx.fillStyle = `rgba(0,200,255,${0.5 * pulse})`;
      ctx.fillRect(ox + 4 * s, oy + 4 * s, 6 * s, 5 * s); ctx.fillRect(ox + 12 * s, oy + 4 * s, 6 * s, 5 * s);
      // Bouche
      ctx.fillStyle = '#002244';
      ctx.fillRect(ox + 6 * s, oy + 9 * s, 10 * s, 2 * s);
      ctx.fillStyle = '#aaddff'; for (let i = 0; i < 3; i++) ctx.fillRect(ox + (7 + i * 3) * s, oy + 9 * s, 2 * s, 2 * s);
      // Jambes
      ctx.fillStyle = '#3377bb';
      ctx.fillRect(ox + 4 * s, oy + 26 * s + legOff, 5 * s, 6 * s);
      ctx.fillRect(ox + 13 * s, oy + 26 * s - legOff, 5 * s, 6 * s);
      ctx.fillStyle = '#2266aa';
      ctx.fillRect(ox + 3 * s, oy + 31 * s + legOff, 6 * s, 2 * s); ctx.fillRect(ox + 12 * s, oy + 31 * s - legOff, 6 * s, 2 * s);
      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ GRIFFON (montagne) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawGriffon(ctx, cx, cy, dir, frame, scale = 1.7, alpha = 1) {
      const s = scale; ctx.save(); ctx.translate(cx, cy); ctx.globalAlpha *= alpha;
      if (dir < 0) ctx.scale(-1, 1);
      const ox = -10 * s, oy = -10 * s;
      const wingOff = frame === 1 ? -2 * s : frame === 2 ? 2 * s : 0;
      const legOff = frame === 1 ? -s : frame === 2 ? s : 0;
      // Ailes
      ctx.fillStyle = '#8b6a10';
      ctx.beginPath(); ctx.moveTo(ox + 10 * s, oy + 5 * s); ctx.lineTo(ox - 4 * s, oy + 0 * s + wingOff); ctx.lineTo(ox + 0 * s, oy + 5 * s + wingOff); ctx.lineTo(ox + 6 * s, oy + 8 * s); ctx.closePath(); ctx.fill();
      ctx.beginPath(); ctx.moveTo(ox + 12 * s, oy + 5 * s); ctx.lineTo(ox + 24 * s, oy + 0 * s + wingOff); ctx.lineTo(ox + 20 * s, oy + 5 * s + wingOff); ctx.lineTo(ox + 16 * s, oy + 8 * s); ctx.closePath(); ctx.fill();
      ctx.fillStyle = '#c8a020';
      ctx.fillRect(ox - 3 * s, oy + s + wingOff, 4 * s, s); ctx.fillRect(ox + 21 * s, oy + s + wingOff, 4 * s, s);
      // Corps
      ctx.fillStyle = '#c8a020';
      ctx.fillRect(ox + 4 * s, oy + 5 * s, 14 * s, 9 * s);
      ctx.fillStyle = '#eecc44';
      ctx.fillRect(ox + 6 * s, oy + 6 * s, 10 * s, 4 * s);
      // T√™te d'aigle
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(ox + 1 * s, oy + 1 * s, 10 * s, 8 * s);
      ctx.fillStyle = '#dddddd'; ctx.fillRect(ox + 2 * s, oy + 2 * s, 7 * s, 5 * s);
      // Bec
      ctx.fillStyle = '#cc8800'; ctx.fillRect(ox, oy + 5 * s, 3 * s, 3 * s); ctx.fillRect(ox - s, oy + 7 * s, 3 * s, s);
      // Oeil
      ctx.fillStyle = '#ffcc00'; ctx.fillRect(ox + 5 * s, oy + 3 * s, 3 * s, 3 * s);
      ctx.fillStyle = '#000'; ctx.fillRect(ox + 6 * s, oy + 3 * s, 2 * s, 2 * s);
      // Oreilles/huppe
      ctx.fillStyle = '#c8a020'; ctx.fillRect(ox + 7 * s, oy, 3 * s, 2 * s); ctx.fillRect(ox + 6 * s, oy - 2 * s, s, 3 * s); ctx.fillRect(ox + 10 * s, oy - 2 * s, s, 3 * s);
      // Queue
      ctx.fillStyle = '#c8a020';
      ctx.fillRect(ox + 18 * s, oy + 5 * s, 4 * s, 4 * s);
      ctx.fillRect(ox + 20 * s, oy + 3 * s + legOff, 2 * s, 4 * s);
      ctx.fillRect(ox + 21 * s, oy + 1 * s + legOff, s, 3 * s);
      // Pattes avec griffes
      ctx.fillStyle = '#aa8810';
      ctx.fillRect(ox + 5 * s, oy + 13 * s + legOff, 3 * s, 4 * s);
      ctx.fillRect(ox + 13 * s, oy + 13 * s - legOff, 3 * s, 4 * s);
      ctx.fillStyle = '#888';
      ctx.fillRect(ox + 4 * s, oy + 16 * s + legOff, s, 2 * s); ctx.fillRect(ox + 6 * s, oy + 17 * s + legOff, s, 2 * s); ctx.fillRect(ox + 8 * s, oy + 16 * s + legOff, s, 2 * s);
      ctx.fillRect(ox + 12 * s, oy + 16 * s - legOff, s, 2 * s); ctx.fillRect(ox + 14 * s, oy + 17 * s - legOff, s, 2 * s); ctx.fillRect(ox + 16 * s, oy + 16 * s - legOff, s, 2 * s);
      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ GOLEM (montagne) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawGolem(ctx, cx, cy, dir, frame, scale = 2.0, alpha = 1) {
      const s = scale; ctx.save(); ctx.translate(cx, cy); ctx.globalAlpha *= alpha;
      if (dir < 0) ctx.scale(-1, 1);
      const ox = -12 * s, oy = -16 * s;
      const legOff = frame === 1 ? -s : frame === 2 ? s : 0;
      const pulse = (Math.sin(GS.frame * 0.06) + 1) / 2;
      // Corps massif
      ctx.fillStyle = '#5a5a5a';
      ctx.fillRect(ox + 2 * s, oy + 8 * s, 20 * s, 18 * s);
      ctx.fillStyle = '#707070'; ctx.fillRect(ox + 3 * s, oy + 9 * s, 18 * s, 8 * s);
      // Fissures lumineuses
      ctx.strokeStyle = `rgba(255,${100 + Math.floor(100 * pulse)},0,${0.6 + 0.3 * pulse})`; ctx.lineWidth = s;
      ctx.beginPath(); ctx.moveTo(ox + 8 * s, oy + 12 * s); ctx.lineTo(ox + 12 * s, oy + 20 * s); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(ox + 15 * s, oy + 11 * s); ctx.lineTo(ox + 13 * s, oy + 18 * s); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(ox + 6 * s, oy + 18 * s); ctx.lineTo(ox + 10 * s, oy + 24 * s); ctx.stroke();
      // √âpauli√®res rocheuses
      ctx.fillStyle = '#444';
      ctx.fillRect(ox, oy + 8 * s, 4 * s, 6 * s); ctx.fillRect(ox + 20 * s, oy + 8 * s, 4 * s, 6 * s);
      ctx.fillRect(ox - 2 * s, oy + 6 * s, 4 * s, 4 * s); ctx.fillRect(ox + 22 * s, oy + 6 * s, 4 * s, 4 * s);
      // Bras
      ctx.fillStyle = '#5a5a5a';
      ctx.fillRect(ox - 2 * s, oy + 9 * s, 4 * s, 12 * s); ctx.fillRect(ox + 22 * s, oy + 9 * s, 4 * s, 12 * s);
      // Poings
      ctx.fillStyle = '#444';
      ctx.fillRect(ox - 3 * s, oy + 20 * s, 5 * s, 5 * s); ctx.fillRect(ox + 22 * s, oy + 20 * s, 5 * s, 5 * s);
      // T√™te
      ctx.fillStyle = '#4a4a4a';
      ctx.fillRect(ox + 4 * s, oy + 0 * s, 16 * s, 9 * s);
      ctx.fillStyle = '#606060'; ctx.fillRect(ox + 5 * s, oy + s, 14 * s, 4 * s);
      // Yeux de magma
      ctx.fillStyle = `rgba(255,${80 + Math.floor(120 * pulse)},0,1)`;
      ctx.fillRect(ox + 5 * s, oy + 2 * s, 5 * s, 4 * s); ctx.fillRect(ox + 14 * s, oy + 2 * s, 5 * s, 4 * s);
      ctx.fillStyle = '#fff'; ctx.fillRect(ox + 5 * s, oy + 2 * s, 2 * s, s); ctx.fillRect(ox + 14 * s, oy + 2 * s, 2 * s, s);
      // Bouche
      ctx.fillStyle = `rgba(255,60,0,${0.7 + 0.2 * pulse})`;
      ctx.fillRect(ox + 6 * s, oy + 7 * s, 12 * s, 2 * s);
      for (let i = 0; i < 3; i++) { ctx.fillStyle = '#333'; ctx.fillRect(ox + (7 + i * 3) * s, oy + 7 * s, 2 * s, 2 * s); }
      // Jambes
      ctx.fillStyle = '#4a4a4a';
      ctx.fillRect(ox + 4 * s, oy + 26 * s + legOff, 6 * s, 6 * s); ctx.fillRect(ox + 14 * s, oy + 26 * s - legOff, 6 * s, 6 * s);
      ctx.fillStyle = '#333'; ctx.fillRect(ox + 3 * s, oy + 31 * s + legOff, 7 * s, 2 * s); ctx.fillRect(ox + 13 * s, oy + 31 * s - legOff, 7 * s, 2 * s);
      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ √âL√âMENTAL DE NEIGE (montagne) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawElemental(ctx, cx, cy, frame, scale = 1.7, alpha = 1) {
      const s = scale; ctx.save(); ctx.translate(cx, cy); ctx.globalAlpha *= alpha;
      const ox = -8 * s, oy = -12 * s;
      const pulse = (Math.sin(GS.frame * 0.1) + 1) / 2;
      const spin = GS.frame * 0.05;
      // Tourbillon neige ext√©rieur
      ctx.strokeStyle = `rgba(180,220,255,${0.3 + 0.2 * pulse})`; ctx.lineWidth = s;
      for (let i = 0; i < 3; i++) {
        ctx.beginPath(); ctx.arc(0, 0, (8 + i * 4) * s, spin + i * Math.PI * 0.6, spin + i * Math.PI * 0.6 + Math.PI * 1.4); ctx.stroke();
      }
      // Corps neige/glace
      ctx.fillStyle = `rgba(180,220,255,${0.75 + 0.15 * pulse})`;
      ctx.beginPath(); ctx.arc(ox + 8 * s, oy + 8 * s, 8 * s, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = `rgba(220,240,255,${0.5 + 0.2 * pulse})`;
      ctx.beginPath(); ctx.arc(ox + 8 * s, oy + 6 * s, 6 * s, 0, Math.PI * 2); ctx.fill();
      // Cristaux internes
      ctx.fillStyle = '#aaddff';
      for (let i = 0; i < 4; i++) {
        const a2 = spin * 2 + i * Math.PI / 2;
        ctx.fillRect(ox + 8 * s + Math.cos(a2) * 4 * s - s, oy + 8 * s + Math.sin(a2) * 4 * s - s, 2 * s, 2 * s);
      }
      // Yeux
      ctx.fillStyle = '#0044aa';
      ctx.fillRect(ox + 4 * s, oy + 5 * s, 3 * s, 4 * s); ctx.fillRect(ox + 9 * s, oy + 5 * s, 3 * s, 4 * s);
      ctx.fillStyle = '#00aaff'; ctx.fillRect(ox + 4 * s, oy + 5 * s, s, s); ctx.fillRect(ox + 9 * s, oy + 5 * s, s, s);
      // Bouche
      ctx.fillStyle = '#0044aa';
      ctx.fillRect(ox + 5 * s, oy + 10 * s, 6 * s, s);
      for (let i = 0; i < 3; i++) { ctx.fillStyle = '#88ccff'; ctx.fillRect(ox + (5 + i * 2) * s, oy + 10 * s, s, s); }
      // Bras cristaux flottants
      ctx.fillStyle = `rgba(140,200,255,${0.7 + 0.2 * pulse})`;
      ctx.fillRect(ox - 2 * s, oy + 6 * s, 3 * s, 6 * s); ctx.fillRect(ox + 15 * s, oy + 6 * s, 3 * s, 6 * s);
      ctx.fillStyle = '#aaddff'; ctx.fillRect(ox - 3 * s, oy + 5 * s, 2 * s, 2 * s); ctx.fillRect(ox + 17 * s, oy + 5 * s, 2 * s, 2 * s);
      // Bas du corps (fondu en particules)
      for (let i = 0; i < 5; i++) {
        ctx.fillStyle = `rgba(180,220,255,${(0.5 - i * 0.08) * pulse})`;
        ctx.fillRect(ox + (3 + i * 2) * s, oy + (14 + i) * s, 2 * s, 2 * s);
      }
      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ √âCLAT VIVANT (crystal) ‚Äî fragment de cristal anim√© ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawEclatVivant(ctx, cx, cy, dir, frame, scale = 1.6, alpha = 1) {
      const s = scale; ctx.save(); ctx.translate(cx, cy); ctx.globalAlpha *= alpha;
      if (dir < 0) ctx.scale(-1, 1);
      const pulse = (Math.sin(GS.frame * 0.12) + 1) / 2;
      const bob2 = Math.sin(GS.frame * 0.09) * 2 * s;
      // Lueur de fond
      ctx.fillStyle = `rgba(100,200,255,${0.15 + 0.1 * pulse})`;
      ctx.beginPath(); ctx.ellipse(0, 4 * s, 12 * s, 7 * s, 0, 0, Math.PI * 2); ctx.fill();
      // Corps cristal ‚Äî forme diamant pixelis√©e
      const cy2 = bob2 - 10 * s;
      ctx.fillStyle = '#55aaee';
      // Losange central
      ctx.beginPath();
      ctx.moveTo(0, cy2 - 10 * s);
      ctx.lineTo(8 * s, cy2 - 2 * s);
      ctx.lineTo(0, cy2 + 8 * s);
      ctx.lineTo(-8 * s, cy2 - 2 * s);
      ctx.closePath(); ctx.fill();
      // Face claire
      ctx.fillStyle = `rgba(150,220,255,${0.6 + 0.3 * pulse})`;
      ctx.beginPath();
      ctx.moveTo(0, cy2 - 10 * s);
      ctx.lineTo(8 * s, cy2 - 2 * s);
      ctx.lineTo(0, cy2 - 1 * s);
      ctx.closePath(); ctx.fill();
      // Facette sombre
      ctx.fillStyle = '#2266aa';
      ctx.beginPath();
      ctx.moveTo(-8 * s, cy2 - 2 * s);
      ctx.lineTo(0, cy2 - 1 * s);
      ctx.lineTo(0, cy2 + 8 * s);
      ctx.closePath(); ctx.fill();
      // Yeux lumineux
      ctx.fillStyle = `rgba(0,220,255,${0.8 + 0.2 * pulse})`;
      ctx.fillRect(-4 * s, cy2 - 5 * s, 2 * s, 2 * s);
      ctx.fillRect(2 * s, cy2 - 5 * s, 2 * s, 2 * s);
      // √âclats orbitaux (petits fragments tournants)
      const spin = GS.frame * 0.04 + (frame * Math.PI * 0.6);
      ctx.fillStyle = `rgba(170,230,255,${0.7 + 0.3 * pulse})`;
      for (let i = 0; i < 3; i++) {
        const a = spin + i * Math.PI * 2 / 3;
        const ex = Math.cos(a) * 11 * s, ey = Math.sin(a) * 8 * s + bob2 - 2 * s;
        ctx.fillRect(ex - s, ey - s, 2 * s, 2 * s);
      }
      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ GOLEM DE CRISTAL (crystal) ‚Äî colosse de verre taill√© ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawGolemCristal(ctx, cx, cy, dir, frame, scale = 1.8, alpha = 1) {
      const s = scale; ctx.save(); ctx.translate(cx, cy); ctx.globalAlpha *= alpha;
      if (dir < 0) ctx.scale(-1, 1);
      const ox = -11 * s, oy = -18 * s;
      const legOff = frame === 1 ? -s : frame === 2 ? s : 0;
      const pulse = (Math.sin(GS.frame * 0.07) + 1) / 2;
      // Aura prismatique
      ctx.fillStyle = `rgba(80,180,255,${0.12 + 0.08 * pulse})`;
      ctx.beginPath(); ctx.ellipse(0, 5 * s, 20 * s, 10 * s, 0, 0, Math.PI * 2); ctx.fill();
      // Jambes blocs cristal
      ctx.fillStyle = '#2255aa';
      ctx.fillRect(ox + 2 * s, oy + 28 * s + legOff, 7 * s, 8 * s);
      ctx.fillRect(ox + 13 * s, oy + 28 * s - legOff, 7 * s, 8 * s);
      ctx.fillStyle = '#3377cc';
      ctx.fillRect(ox + 2 * s, oy + 27 * s + legOff, 7 * s, 2 * s);
      ctx.fillRect(ox + 13 * s, oy + 27 * s - legOff, 7 * s, 2 * s);
      // Corps massif
      ctx.fillStyle = '#2266bb';
      ctx.fillRect(ox + 1 * s, oy + 12 * s, 20 * s, 17 * s);
      // Reflets prismatiques sur le torse
      ctx.fillStyle = `rgba(120,200,255,${0.35 + 0.2 * pulse})`;
      ctx.fillRect(ox + 3 * s, oy + 14 * s, 6 * s, 9 * s);
      ctx.fillStyle = `rgba(80,160,255,${0.25 + 0.15 * pulse})`;
      ctx.fillRect(ox + 12 * s, oy + 15 * s, 7 * s, 7 * s);
      // Lignes de fracture
      ctx.strokeStyle = `rgba(200,240,255,${0.5 + 0.3 * pulse})`; ctx.lineWidth = s * 0.6;
      ctx.beginPath(); ctx.moveTo(ox + 5 * s, oy + 13 * s); ctx.lineTo(ox + 9 * s, oy + 22 * s); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(ox + 15 * s, oy + 14 * s); ctx.lineTo(ox + 12 * s, oy + 21 * s); ctx.stroke();
      // √âpaules cristal avec pointes
      ctx.fillStyle = '#4488dd';
      ctx.fillRect(ox - 3 * s, oy + 12 * s, 5 * s, 12 * s);
      ctx.fillRect(ox + 20 * s, oy + 12 * s, 5 * s, 12 * s);
      // Pointes d'√©paule
      ctx.fillStyle = '#aaddff';
      ctx.beginPath(); ctx.moveTo(ox - 3 * s, oy + 12 * s); ctx.lineTo(ox - 1 * s, oy + 7 * s); ctx.lineTo(ox + 2 * s, oy + 12 * s); ctx.closePath(); ctx.fill();
      ctx.beginPath(); ctx.moveTo(ox + 20 * s, oy + 12 * s); ctx.lineTo(ox + 22 * s, oy + 7 * s); ctx.lineTo(ox + 25 * s, oy + 12 * s); ctx.closePath(); ctx.fill();
      // T√™te hexagonale
      ctx.fillStyle = '#1a4488';
      ctx.fillRect(ox + 4 * s, oy + 3 * s, 14 * s, 10 * s);
      ctx.fillRect(ox + 2 * s, oy + 5 * s, 18 * s, 6 * s);
      // Cr√™te de cristaux
      ctx.fillStyle = '#88ccff';
      for (let i = 0; i < 4; i++) {
        ctx.beginPath();
        ctx.moveTo(ox + (4 + i * 3.5) * s, oy + 3 * s);
        ctx.lineTo(ox + (5.5 + i * 3.5) * s, oy - 2 * s);
        ctx.lineTo(ox + (7 + i * 3.5) * s, oy + 3 * s);
        ctx.closePath(); ctx.fill();
      }
      // Yeux prismatiques
      ctx.fillStyle = `rgba(0,200,255,${0.9 + 0.1 * pulse})`;
      ctx.fillRect(ox + 5 * s, oy + 5 * s, 5 * s, 4 * s);
      ctx.fillRect(ox + 12 * s, oy + 5 * s, 5 * s, 4 * s);
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(ox + 6 * s, oy + 5 * s, 2 * s, 2 * s);
      ctx.fillRect(ox + 13 * s, oy + 5 * s, 2 * s, 2 * s);
      // Bouche s√©v√®re
      ctx.fillStyle = '#001133';
      ctx.fillRect(ox + 5 * s, oy + 10 * s, 12 * s, 2 * s);
      ctx.fillStyle = '#44aaff'; for (let i = 0; i < 4; i++) ctx.fillRect(ox + (6 + i * 3) * s, oy + 10 * s, 2 * s, 2 * s);
      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ LUEUR PRISMATIQUE (crystal) ‚Äî orbe lumineuse flottante ‚îÄ‚îÄ
    function drawLueurPrismatique(ctx, cx, cy, frame, scale = 1.5, alpha = 1) {
      const s = scale; ctx.save(); ctx.translate(cx, cy); ctx.globalAlpha *= alpha;
      const pulse = (Math.sin(GS.frame * 0.14) + 1) / 2;
      const spin = GS.frame * 0.06;
      const colors = ['#ff88ff', '#88ffff', '#ffff88', '#88ff88'];
      const bob2 = Math.sin(GS.frame * 0.1) * 3 * s;
      // Halo ext√©rieur
      const hg = ctx.createRadialGradient(0, bob2, 0, 0, bob2, 16 * s);
      hg.addColorStop(0, `rgba(200,160,255,${0.4 + 0.2 * pulse})`);
      hg.addColorStop(0.5, `rgba(150,100,255,${0.2 + 0.1 * pulse})`);
      hg.addColorStop(1, 'transparent');
      ctx.fillStyle = hg; ctx.beginPath(); ctx.arc(0, bob2, 16 * s, 0, Math.PI * 2); ctx.fill();
      // Rayons prismatiques tournants
      for (let i = 0; i < 6; i++) {
        const a = spin + i * Math.PI / 3;
        ctx.strokeStyle = colors[i % 4].replace(')', `,${0.5 + 0.3 * pulse})`).replace('rgb', 'rgba').replace('#ff88ff', `rgba(255,136,255,${0.5 + 0.3 * pulse})`).replace('#88ffff', `rgba(136,255,255,${0.4 + 0.3 * pulse})`).replace('#ffff88', `rgba(255,255,136,${0.45 + 0.3 * pulse})`).replace('#88ff88', `rgba(136,255,136,${0.4 + 0.3 * pulse})`);
        ctx.strokeStyle = ['rgba(255,136,255,0.6)', 'rgba(136,255,255,0.6)', 'rgba(255,255,136,0.6)', 'rgba(136,255,136,0.6)', 'rgba(255,160,100,0.5)', 'rgba(160,136,255,0.6)'][i];
        ctx.lineWidth = s * 0.8;
        ctx.beginPath(); ctx.moveTo(Math.cos(a) * 5 * s, bob2 + Math.sin(a) * 5 * s);
        ctx.lineTo(Math.cos(a) * 13 * s, bob2 + Math.sin(a) * 13 * s); ctx.stroke();
      }
      // Noyau central
      ctx.fillStyle = `rgba(230,200,255,${0.85 + 0.1 * pulse})`;
      ctx.beginPath(); ctx.arc(0, bob2, 5 * s, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#ffffff';
      ctx.beginPath(); ctx.arc(-s, bob2 - s, 2 * s, 0, Math.PI * 2); ctx.fill();
      // Cristaux flottants en orbite (pixelis√©s)
      for (let i = 0; i < 4; i++) {
        const a2 = spin * 1.5 + i * Math.PI / 2 + (frame * Math.PI * 0.4);
        const r = (9 + Math.sin(GS.frame * 0.08 + i) * 2) * s;
        const px = Math.cos(a2) * r, py = bob2 + Math.sin(a2) * r * 0.6;
        ctx.fillStyle = colors[i];
        ctx.fillRect(px - s, py - s, 2 * s, 3 * s);
      }
      // Yeux (petits points dans la lueur)
      ctx.fillStyle = '#3300aa';
      ctx.fillRect(-2 * s, bob2 - 2 * s, 2 * s, 2 * s);
      ctx.fillRect(0 * s, bob2 - 2 * s, 2 * s, 2 * s);
      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ VORTEX DE VERRE (crystal) ‚Äî tourbillon de fragments ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawVortexVerre(ctx, cx, cy, frame, scale = 1.6, alpha = 1) {
      const s = scale; ctx.save(); ctx.translate(cx, cy); ctx.globalAlpha *= alpha;
      const pulse = (Math.sin(GS.frame * 0.1) + 1) / 2;
      const spin = GS.frame * 0.07;
      const bob2 = Math.sin(GS.frame * 0.08) * 2 * s;
      // Ombre sol
      ctx.fillStyle = `rgba(50,80,150,${0.15 + 0.05 * pulse})`;
      ctx.beginPath(); ctx.ellipse(0, 8 * s, 14 * s, 5 * s, 0, 0, Math.PI * 2); ctx.fill();
      // Anneau tourbillonnant ext√©rieur
      ctx.strokeStyle = `rgba(100,180,255,${0.4 + 0.2 * pulse})`; ctx.lineWidth = 2 * s;
      ctx.beginPath(); ctx.arc(0, bob2, 13 * s, spin, spin + Math.PI * 1.6); ctx.stroke();
      ctx.strokeStyle = `rgba(200,230,255,${0.3 + 0.2 * pulse})`; ctx.lineWidth = s;
      ctx.beginPath(); ctx.arc(0, bob2, 10 * s, spin + Math.PI, spin + Math.PI * 2.6); ctx.stroke();
      // Corps central ‚Äî noyau sombre avec facettes
      ctx.fillStyle = '#112244';
      ctx.beginPath(); ctx.arc(0, bob2, 7 * s, 0, Math.PI * 2); ctx.fill();
      // Facettes color√©es du noyau
      const nColors = ['#4499cc', '#2266aa', '#66bbee', '#336699'];
      for (let i = 0; i < 4; i++) {
        const a = spin * 0.5 + i * Math.PI / 2;
        ctx.fillStyle = nColors[i];
        ctx.beginPath();
        ctx.moveTo(0, bob2);
        ctx.arc(0, bob2, 7 * s, a, a + Math.PI * 0.5);
        ctx.closePath(); ctx.fill();
      }
      // Reflet brillant
      ctx.fillStyle = `rgba(180,230,255,${0.5 + 0.3 * pulse})`;
      ctx.beginPath(); ctx.arc(-2 * s, bob2 - 2 * s, 3 * s, 0, Math.PI * 2); ctx.fill();
      // Fragments de verre orbitaux
      for (let i = 0; i < 6; i++) {
        const a = spin * (i % 2 === 0 ? 1.2 : -0.8) + i * Math.PI / 3 + (frame * 0.3);
        const r = (9 + i * 0.5) * s;
        const px = Math.cos(a) * r, py = bob2 + Math.sin(a) * r * 0.7;
        const sz = (1 + (i % 3)) * s;
        ctx.fillStyle = i % 3 === 0 ? `rgba(150,220,255,${0.8 + 0.2 * pulse})` : i % 3 === 1 ? `rgba(200,240,255,${0.7 + 0.2 * pulse})` : `rgba(100,170,255,${0.75 + 0.2 * pulse})`;
        // Pixel carr√© pour l'aspect pixelart
        ctx.save(); ctx.translate(px, py); ctx.rotate(spin * 2 + i);
        ctx.fillRect(-sz / 2, -sz / 2, sz, sz * 1.5);
        ctx.restore();
      }
      // Yeux dans le vortex
      ctx.fillStyle = `rgba(0,200,255,${0.9 + 0.1 * pulse})`;
      ctx.fillRect(-3 * s, bob2 - 2 * s, 2 * s, 2 * s);
      ctx.fillRect(1 * s, bob2 - 2 * s, 2 * s, 2 * s);
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(-3 * s, bob2 - 2 * s, s, s);
      ctx.fillRect(s, bob2 - 2 * s, s, s);
      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ Fonctions utilitaires pour obtenir frame/dir par monstre ‚îÄ
    function getMonFrame(m) {
      if (!m._animFrame) { m._animFrame = 0; m._animTimer = 0; }
      m._animTimer++;
      const spd = m.spd > 1.5 ? 6 : m.spd > 0.8 ? 10 : 14;
      if (m._animTimer >= spd) { m._animFrame = (m._animFrame + 1) % 3; m._animTimer = 0; }
      return (m.state === 'idle' || m.state === 'wander') && m.spd < 0.5 ? 0 : m._animFrame;
    }
    function getMonDir(m) {
      // -1=gauche, 1=droite  (pour flip)
      if (!m._dir) m._dir = 1;
      if (m.vx < -0.1) m._dir = -1;
      else if (m.vx > 0.1) m._dir = 1;
      return m._dir;
    }
    function getPlayerDir(p) {
      // 0=bas 1=haut 2=gauche 3=droite
      if (p.fy > 0.3) return 0;
      if (p.fy < -0.3) return 1;
      if (p.fx < 0) return 2;
      return 3;
    }

    // ‚îÄ‚îÄ‚îÄ Sprite picking par type de monstre ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function getMonsterType(m) {
      const n = m.name;
      if (n === 'Loup') return 'wolf';
      if (n === 'Chauve-souris') return 'bat';
      if (n === 'Araign√©e') return 'spider';
      if (n === 'Entit√©') return 'leaf';
      if (n === 'Squelette') return 'skeleton';
      if (n === 'Zombie') return 'zombie';
      if (n === 'Fant√¥me') return 'ghost';
      if (n === 'Chevalier') return 'knight';
      if (n === 'G√©ant de Glace') return 'iceGiant';
      if (n === 'Griffon') return 'griffon';
      if (n === 'Golem') return 'golem';
      if (n === '√âl√©mental') return 'elemental';
      // webs biome monsters
      if (n === 'Araign√©e V√©n√©neuse') return 'spiderVenom';
      if (n === 'Scorpion G√©ant') return 'scorpion';
      if (n === 'Col√©opt√®re Sombre') return 'beetle';
      if (n === 'Chasseur Silencieux') return 'cricket';
      // crystal biome monsters
      if (n === '√âclat Vivant') return 'eclatVivant';
      if (n === 'Golem de Cristal') return 'golemCristal';
      if (n === 'Lueur Prismatique') return 'lueurPrismatique';
      if (n === 'Vortex de Verre') return 'vortexVerre';
      return null;
    }
    function getBossType(lvl) {
      if (lvl === 0) return 'demon';
      if (lvl === 1) return 'king';
      if (lvl === 2) return 'spider';
      if (lvl === 3) return 'crystal';
      return 'dragon';
    }

    // ============================================================
    // TITLE ANIMATION
    // ============================================================
    let titleFrame = 0;
    function animateTitle() {
      if (document.getElementById('title').style.display === 'none') return;
      TC.fillStyle = 'rgba(0,0,0,0.03)'; TC.fillRect(0, 0, tc.width, tc.height); titleFrame++;
      for (let i = 0; i < 3; i++) {
        const x = Math.random() * tc.width, y = Math.random() * tc.height;
        TC.fillStyle = `rgba(255,215,0,${0.2 + Math.random() * 0.4})`; TC.fillRect(x, y, 1 + Math.random() * 2, 1 + Math.random() * 2);
      }
      requestAnimationFrame(animateTitle);
    }
    animateTitle();

    // ============================================================
    // FIREWORKS
    // ============================================================
    function fireworks() {
      const em = ['üéÜ', 'üéá', '‚≠ê', '‚ú®', 'üåü', 'üí´', 'üéâ', '‚ù§Ô∏è', 'üèÜ', 'üéä', 'üí•'];
      for (let i = 0; i < 36; i++)setTimeout(() => {
        const p = document.createElement('div'); p.className = 'particle';
        p.textContent = em[Math.floor(Math.random() * em.length)];
        p.style.left = Math.random() * 100 + 'vw'; p.style.top = Math.random() * 100 + 'vh';
        p.style.setProperty('--dx', (Math.random() - 0.5) * 400 + 'px');
        p.style.setProperty('--dy', (Math.random() - 0.5) * 400 + 'px');
        p.style.setProperty('--rot', (Math.random() * 720 - 360) + 'deg');
        p.style.setProperty('--dur', (1 + Math.random() * 1.2) + 's');
        document.body.appendChild(p); setTimeout(() => p.remove(), 2500);
      }, i * 70);
    }

    // ============================================================
    // MAIN LOOP
    // ============================================================
    function loop() {
      if (!gRun) { requestAnimationFrame(loop); return; }
      GS.frame++;
      let shkX = 0, shkY = 0;
      if (GS.shake > 0) { shkX = (Math.random() - 0.5) * GS.shake; shkY = (Math.random() - 0.5) * GS.shake; GS.shake *= 0.75; if (GS.shake < 0.1) GS.shake = 0; }
      C.fillStyle = LEVELS[curLvl].bgA; C.fillRect(0, 0, canvas.width, canvas.height);
      C.save(); C.translate(Math.round(shkX), Math.round(shkY));
      updPlayer(); updMons(); updProjectiles();
      renderMap(); renderAmbient(); renderDecos(); renderQItems();
      renderBossWarnings();
      renderProjectiles(); renderMons(); renderPlayer(); renderAtks();
      renderBossBeam();
      renderLighting();
      C.restore();
      renderMinimap();
      updSkillBar();
      requestAnimationFrame(loop);
    }

    // ============================================================
    // DETECT MOBILE
    // ============================================================
    function isMobile() { return ('ontouchstart' in window) || navigator.maxTouchPoints > 0 || window.innerWidth < 900; }

    // ============================================================
    // GAME START
    // ============================================================
    function startGame() {
      document.getElementById('title').style.display = 'none';

      const loadScreen = document.getElementById('loadscreen');
      loadScreen.style.display = 'flex';
      const loadBar = document.getElementById('load-bar-fill');
      const loadMsg = document.getElementById('load-msg');

      BossMusic.init();

      let rendered = 0;
      const tracks = ['b0-0', 'b0-1', 'b0-2'];
      const msgMap = {'b0-0':'üéµ Ambiance...', 'b0-1':'‚öîÔ∏è Musique combat...', 'b0-2':'üî• Musique rage...'};

      function launchGame() {
        loadScreen.style.display = 'none';
        document.getElementById('game').style.display = 'block';
        document.getElementById('hud').style.display = 'flex';
        document.getElementById('minimap-wrap').style.display = 'block';
        document.getElementById('mobilecontrols').style.display = 'block';
        gRun = true; isDead = false; curLvl = 0;
        const p = GS.p; p.hp = 6; p.maxHp = 6; p.xp = 0; p.lvl = 1; p.wPow = 1;
        p.weapon = '‚öîÔ∏è √âp√©e Rouill√©e'; p.atkCDs = [0,0,0,0];
        p.dashCD = 0; p.invincible = false; p.invincibleTimer = 0;
        loadLevel(0); loop();
        setTimeout(() => BossMusic.preloadLevel(1), 2000);
        setTimeout(() => BossMusic.preloadLevel(2), 6000);
        setTimeout(() => BossMusic.preloadLevel(3), 11000);
        setTimeout(() => BossMusic.preloadLevel(4), 16000);
        setupDevHelpers();
      }

      // Rendre chaque track s√©quentiellement avec mise √† jour visuelle
      async function renderAll() {
        for (let i = 0; i < tracks.length; i++) {
          loadMsg.textContent = msgMap[tracks[i]];
          loadBar.style.width = (i / tracks.length * 90) + '%';
          try {
            await BossMusic.renderOne(tracks[i]);
          } catch(e) {
            console.warn('Rendu √©chou√© pour', tracks[i], e);
          }
          rendered++;
        }
        loadBar.style.width = '100%';
        loadMsg.textContent = '‚úÖ Pr√™t !';
        await new Promise(r => setTimeout(r, 400));
        launchGame();
      }

      renderAll();
    }

    function setupDevHelpers() {
      window.devGoto = (n) => {
        n = Math.max(0, Math.min(n, LEVELS.length - 1));
        isDead = false; gRun = true;
        const p = GS.p; p.hp = p.maxHp; p.invincible = false;
        if (n > 0) { p.weapon = LEVELS[n-1].weapon; p.wPow = LEVELS[n-1].wPow; }
        curLvl = n; loadLevel(n);
        console.log(`%cüéÆ Niveau ${n+1} ‚Äî ${Array.isArray(LEVELS[n].name) ? LEVELS[n].name[0] : LEVELS[n].name}`, 'color:#ffd700;font-weight:bold');
      };
      window.devKillBoss = () => {
        if (GS.boss && GS.boss.state !== 'dead') { GS.boss.hp = 1; console.log('%cüíÄ Boss √† 1 HP !', 'color:#ff4444'); }
        else console.log('Pas de boss actif.');
      };
      window.devGodMode = (on=true) => {
        GS.p.invincible = on; GS.p.invincibleTimer = on ? 999999 : 0;
        console.log(`%c${on ? 'üõ° God mode ON' : 'üõ° God mode OFF'}`, 'color:#00ffcc');
      };
      window.devHelp = () => console.log(
        '%cCommandes dev disponibles :\n' +
        '  devGoto(n)      ‚Üí aller directement au niveau n (0 √† 4)\n' +
        '  devKillBoss()   ‚Üí met le boss actif √† 1 HP\n' +
        '  devGodMode()    ‚Üí invincibilit√© ON\n' +
        '  devGodMode(false) ‚Üí invincibilit√© OFF',
        'color:#aaffaa;font-size:13px;font-family:monospace'
      );
      console.log('%cüõ† DEV MODE actif ‚Äî tape devHelp() pour les commandes', 'color:#ffd700;font-weight:bold;font-size:14px');
    }

  </script>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
     BOSS MUSIC ENGINE ‚Äî Synth√®se proc√©durale int√©gr√©e
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<script>
'use strict';
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// CONSTANTES
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const MUSIC_SR = 22050;
const MAX_FREQ = MUSIC_SR / 2 - 50; // limite de Nyquist avec marge

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// PRIMITIVES AUDIO ‚Äî volumes assainis, anti-saturation
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function m_osc(oc, type, freq, t0, dur, peak, opts={}) {
  let { atk=0.01, dec=0.04, sus=0.75, rel=0.1, detune=0, lp=null, lpQ=1, pan=0 } = opts;
  peak = Math.min(peak, 0.65); // cap global
  const minDur = atk + dec + rel;
  if (minDur > dur) { const s = dur / minDur; atk *= s; dec *= s; rel *= s; }
  atk = Math.max(atk, 0.002); dec = Math.max(dec, 0.002); rel = Math.max(rel, 0.002);
  const o=oc.createOscillator(), g=oc.createGain();
  o.type=type; o.frequency.value=freq; o.detune.value=detune;
  let node=o;
  if (lp) { const f=oc.createBiquadFilter(); f.type='lowpass'; f.frequency.value=lp; f.Q.value=lpQ; o.connect(f); node=f; }
  if (pan!==0) { const p=oc.createStereoPanner(); p.pan.value=pan; node.connect(p); node=p; }
  node.connect(g); g.connect(oc.destination);
  const t1=t0+atk, t2=t1+dec, t3=t0+dur-rel, t4=t0+dur;
  g.gain.setValueAtTime(0, Math.max(0, t0-0.001));
  g.gain.linearRampToValueAtTime(peak, t1);
  g.gain.linearRampToValueAtTime(peak*sus, t2);
  g.gain.setValueAtTime(peak*sus, Math.max(t2, t3));
  g.gain.linearRampToValueAtTime(0, t4);
  o.start(t0); o.stop(t4+0.05);
}

function m_distOsc(oc, freq, t0, dur, peak, drive=120, opts={}) {
  // Drive plafonn√© √† 160 max pour √©viter la saturation excessive
  drive = Math.min(drive, 160);
  peak = Math.min(peak, 0.35);
  const { lp=700, pan=0, type='sawtooth' } = opts;
  let { atk=0.008, rel=0.06 } = opts;
  const total = atk + rel;
  if (total > dur) { const s = dur / total; atk *= s; rel *= s; }
  atk = Math.max(atk, 0.003); rel = Math.max(rel, 0.003);
  const o=oc.createOscillator(); o.type=type; o.frequency.value=freq;
  const ws=oc.createWaveShaper();
  const k=drive, n=512, curve=new Float32Array(n);
  for (let i=0;i<n;i++) { const x=(2*i/n-1); curve[i]=((Math.PI+k)*x)/(Math.PI+k*Math.abs(x)); }
  ws.curve=curve; ws.oversample='4x';
  const f=oc.createBiquadFilter(); f.type='lowpass'; f.frequency.value=lp;
  const g=oc.createGain();
  let node=g;
  if (pan!==0) { const p=oc.createStereoPanner(); p.pan.value=pan; g.connect(p); node=p; }
  node.connect(oc.destination);
  o.connect(ws); ws.connect(f); f.connect(g);
  g.gain.setValueAtTime(0, Math.max(0, t0-0.001));
  g.gain.linearRampToValueAtTime(peak, t0+atk);
  g.gain.setValueAtTime(peak, t0+dur-rel);
  g.gain.linearRampToValueAtTime(0, t0+dur);
  o.start(t0); o.stop(t0+dur+0.05);
}

function m_noise(oc, t0, dur, peak, opts={}) {
  peak = Math.min(peak, 0.40);
  const { atk=0.002, rel=0.15, ftype='bandpass', freq=600, Q=1.5, pan=0, pink=false } = opts;
  const len=Math.ceil(MUSIC_SR*(dur+0.1));
  const buf=oc.createBuffer(1,len,MUSIC_SR);
  const d=buf.getChannelData(0);
  if (pink) {
    let b0=0,b1=0,b2=0,b3=0,b4=0,b5=0;
    for (let i=0;i<len;i++) {
      const w=Math.random()*2-1;
      b0=0.99886*b0+w*0.0555179; b1=0.99332*b1+w*0.0750759;
      b2=0.96900*b2+w*0.1538520; b3=0.86650*b3+w*0.3104856;
      b4=0.55000*b4+w*0.5329522; b5=-0.7616*b5-w*0.0168980;
      d[i]=(b0+b1+b2+b3+b4+b5+w*0.5362)*0.11;
    }
  } else { for (let i=0;i<len;i++) d[i]=Math.random()*2-1; }
  const src=oc.createBufferSource(); src.buffer=buf;
  const flt=oc.createBiquadFilter(); flt.type=ftype; flt.frequency.value=freq; flt.Q.value=Q;
  const g=oc.createGain();
  let node=g;
  if (pan!==0) { const p=oc.createStereoPanner(); p.pan.value=pan; g.connect(p); node=p; }
  node.connect(oc.destination); src.connect(flt); flt.connect(g);
  g.gain.setValueAtTime(0, Math.max(0, t0-0.001));
  g.gain.linearRampToValueAtTime(peak, t0+atk);
  g.gain.setValueAtTime(peak, t0+dur*0.25);
  g.gain.exponentialRampToValueAtTime(0.0001, t0+dur);
  src.start(t0); src.stop(t0+dur+0.1);
}

function m_kick(oc, t0, peak=0.7, p0=110, p1=38, opts={}) {
  peak = Math.min(peak, 0.80);
  const { dec=0.38, pan=0 } = opts;
  const o=oc.createOscillator(); o.type='sine';
  const g=oc.createGain();
  let node=g;
  if (pan!==0) { const p=oc.createStereoPanner(); p.pan.value=pan; g.connect(p); node=p; }
  node.connect(oc.destination); o.connect(g);
  o.frequency.setValueAtTime(p0, t0);
  o.frequency.exponentialRampToValueAtTime(Math.max(p1,0.01), t0+dec*0.5);
  g.gain.setValueAtTime(0, Math.max(0,t0-0.001));
  g.gain.linearRampToValueAtTime(peak, t0+0.004);
  g.gain.exponentialRampToValueAtTime(0.0001, t0+dec);
  o.start(t0); o.stop(t0+dec+0.05);
  m_noise(oc,t0,0.007,peak*0.3,{atk:0.002,ftype:'highpass',freq:2800,Q:1,pan});
}

function m_taiko(oc, t0, peak=0.75, opts={}) {
  peak = Math.min(peak, 0.85);
  const { p0=85, p1=28, dec=0.6, pan=0 } = opts;
  const o=oc.createOscillator(); o.type='sine';
  const comp=oc.createDynamicsCompressor();
  comp.threshold.value=-18; comp.ratio.value=10; comp.attack.value=0.003; comp.release.value=0.1;
  const g=oc.createGain();
  let node=g;
  if (pan!==0) { const p=oc.createStereoPanner(); p.pan.value=pan; g.connect(p); node=p; }
  node.connect(oc.destination);
  o.connect(comp); comp.connect(g);
  o.frequency.setValueAtTime(p0, t0);
  o.frequency.exponentialRampToValueAtTime(Math.max(p1,0.01), t0+dec*0.55);
  g.gain.setValueAtTime(0, Math.max(0,t0-0.001));
  g.gain.linearRampToValueAtTime(peak, t0+0.005);
  g.gain.exponentialRampToValueAtTime(0.0001, t0+dec);
  o.start(t0); o.stop(t0+dec+0.05);
  m_noise(oc,t0,0.016,peak*0.18,{atk:0.001,ftype:'lowpass',freq:90,Q:0.5,pan});
}

function m_snare(oc, t0, peak=0.45, opts={}) {
  peak = Math.min(peak, 0.55);
  const { bf=200, bd=0.14, nd=0.18, ng=0.65, pan=0 } = opts;
  const o=oc.createOscillator(); o.type='triangle'; o.frequency.value=bf;
  const gb=oc.createGain(); gb.connect(oc.destination); o.connect(gb);
  gb.gain.setValueAtTime(0, Math.max(0,t0-0.001));
  gb.gain.linearRampToValueAtTime(peak*0.35, t0+0.003);
  gb.gain.exponentialRampToValueAtTime(0.0001, t0+bd);
  o.start(t0); o.stop(t0+bd+0.05);
  m_noise(oc,t0,nd,peak*ng,{atk:0.001,ftype:'bandpass',freq:2000,Q:0.7,pan});
}

function m_hihat(oc, t0, peak=0.14, open=false, pan=0) {
  peak = Math.min(peak, 0.20);
  const dur=open?0.28:0.055;
  m_noise(oc,t0,dur,peak,{atk:0.001,ftype:'highpass',freq:6500,Q:0.9,pan});
}

function m_bell(oc, freq, t0, peak=0.18, dec=2.0, pan=0) {
  peak = Math.min(peak, 0.22);
  const ptls=[[1,1],[2.756,0.38],[5.404,0.16],[8.931,0.08]];
  for (const [r,a] of ptls) {
    const f = freq*r;
    if (f > MAX_FREQ) continue;
    const o=oc.createOscillator(); o.type='sine'; o.frequency.value=f;
    const g=oc.createGain();
    let node=g;
    if (pan!==0) { const p=oc.createStereoPanner(); p.pan.value=pan; g.connect(p); node=p; }
    node.connect(oc.destination); o.connect(g);
    g.gain.setValueAtTime(0, Math.max(0, t0-0.001));
    g.gain.linearRampToValueAtTime(peak*a, t0+0.004);
    g.gain.exponentialRampToValueAtTime(0.0001, t0+Math.max(0.05, dec*(1-r*0.04)));
    o.start(t0); o.stop(t0+dec+0.1);
  }
}

function m_strings(oc, freq, t0, dur, peak=0.10, opts={}) {
  peak = Math.min(peak, 0.12);
  let { atk=0.25, rel=0.5, lp=900, pan=0, vRate=4, vDepth=3 } = opts;
  lp = Math.min(lp, MAX_FREQ); // jamais au-dessus de Nyquist
  if (atk + rel > dur) { const s = dur / (atk + rel); atk *= s; rel *= s; }
  atk = Math.max(atk, 0.005); rel = Math.max(rel, 0.005);
  for (let v=0;v<3;v++) {
    const o=oc.createOscillator(); o.type='sawtooth';
    o.frequency.value=freq; o.detune.value=(v-1)*6;
    const lfo=oc.createOscillator(); lfo.frequency.value=vRate+v*0.3;
    const lg=oc.createGain(); lg.gain.value=vDepth;
    lfo.connect(lg); lg.connect(o.frequency);
    const f=oc.createBiquadFilter(); f.type='lowpass'; f.frequency.value=lp;
    const g=oc.createGain();
    let node=g;
    if (pan!==0) { const p=oc.createStereoPanner(); p.pan.value=pan; g.connect(p); node=p; }
    node.connect(oc.destination); o.connect(f); f.connect(g);
    g.gain.setValueAtTime(0, Math.max(0, t0-0.001));
    g.gain.linearRampToValueAtTime(peak/3, t0+atk);
    g.gain.setValueAtTime(peak/3, t0+dur-rel);
    g.gain.linearRampToValueAtTime(0, t0+dur);
    lfo.start(t0); lfo.stop(t0+dur+0.1);
    o.start(t0); o.stop(t0+dur+0.1);
  }
}

function m_drone(oc, freq, t0, dur, peak=0.35, opts={}) {
  peak = Math.min(peak, 0.50);
  let { atk=2.0, rel=2.0, lp=180, harm=2 } = opts;
  if (atk + rel > dur) { const s = dur / (atk + rel) * 0.95; atk *= s; rel *= s; }
  for (let h=0;h<=harm;h++) {
    const f = freq*(h===0?1:h+1);
    if (f > MAX_FREQ) continue;
    const o=oc.createOscillator();
    o.type=h===0?'sine':'sawtooth'; o.frequency.value=f;
    const flt=oc.createBiquadFilter(); flt.type='lowpass'; flt.frequency.value=lp/(h+1)*1.2;
    const g=oc.createGain(); g.connect(oc.destination); o.connect(flt); flt.connect(g);
    const lvl=peak/(h*1.8+1);
    g.gain.setValueAtTime(0, Math.max(0, t0-0.001));
    g.gain.linearRampToValueAtTime(lvl, t0+atk);
    g.gain.setValueAtTime(lvl, t0+dur-rel);
    g.gain.linearRampToValueAtTime(0, t0+dur);
    o.start(t0); o.stop(t0+dur+0.1);
  }
}

function m_choir(oc, freq, t0, dur, peak=0.10, opts={}) {
  peak = Math.min(peak, 0.12);
  let { atk=1.0, rel=1.5, dets=[-10,-5,0,5,10], lp=1200 } = opts;
  if (atk + rel > dur) { const s = dur / (atk + rel) * 0.95; atk *= s; rel *= s; }
  for (const dt of dets) {
    const o=oc.createOscillator(); o.type='sine'; o.frequency.value=freq; o.detune.value=dt;
    const f=oc.createBiquadFilter(); f.type='lowpass'; f.frequency.value=lp;
    const g=oc.createGain(); g.connect(oc.destination);
    o.connect(f); f.connect(g);
    g.gain.setValueAtTime(0, Math.max(0, t0-0.001));
    g.gain.linearRampToValueAtTime(peak/dets.length, t0+atk);
    g.gain.setValueAtTime(peak/dets.length, t0+dur-rel);
    g.gain.linearRampToValueAtTime(0, t0+dur);
    o.start(t0); o.stop(t0+dur+0.1);
  }
}

function m_flute(oc, freq, t0, dur, peak=0.15, opts={}) {
  peak = Math.min(peak, 0.18);
  const { vRate=5, vDepth=4, pan=0, breath=0.04 } = opts;
  dur = Math.max(dur, 0.06);
  const o=oc.createOscillator(); o.type='triangle'; o.frequency.value=freq;
  const lfo=oc.createOscillator(); lfo.frequency.value=vRate;
  const lg=oc.createGain(); lg.gain.value=vDepth;
  lfo.connect(lg); lg.connect(o.frequency);
  const nlen=Math.ceil(MUSIC_SR*(dur+0.1));
  const nbuf=oc.createBuffer(1,nlen,MUSIC_SR);
  const nd=nbuf.getChannelData(0);
  for (let i=0;i<nlen;i++) nd[i]=Math.random()*2-1;
  const ns=oc.createBufferSource(); ns.buffer=nbuf;
  const nhp=oc.createBiquadFilter(); nhp.type='highpass'; nhp.frequency.value=1800;
  const ng=oc.createGain(); ng.gain.value=breath;
  const mg=oc.createGain();
  let node=mg;
  if (pan!==0) { const p=oc.createStereoPanner(); p.pan.value=pan; mg.connect(p); node=p; }
  node.connect(oc.destination);
  o.connect(mg); ns.connect(nhp); nhp.connect(ng); ng.connect(mg);
  mg.gain.setValueAtTime(0, Math.max(0, t0-0.001));
  mg.gain.linearRampToValueAtTime(peak, t0+0.06);
  mg.gain.setValueAtTime(peak, t0+dur-0.10);
  mg.gain.linearRampToValueAtTime(0, t0+dur);
  lfo.start(t0); lfo.stop(t0+dur+0.1);
  ns.start(t0); ns.stop(t0+dur+0.1);
  o.start(t0); o.stop(t0+dur+0.1);
}

function m_wind(oc, t0, dur, peak=0.07) {
  peak = Math.min(peak, 0.10);
  const len=Math.ceil(MUSIC_SR*(dur+0.1));
  const buf=oc.createBuffer(2,len,MUSIC_SR);
  for (let ch=0;ch<2;ch++) {
    const d=buf.getChannelData(ch); let b0=0,b1=0,b2=0;
    for (let i=0;i<len;i++) {
      const w=Math.random()*2-1;
      b0=0.99*b0+w*0.01; b1=0.88*b1+w*0.12; b2=0.55*b2+w*0.45;
      const t=i/MUSIC_SR;
      const mod=0.5+0.5*Math.sin(t*0.35)*Math.sin(t*0.11+ch);
      d[i]=(b0*0.5+b1*0.35+b2*0.15)*peak*mod;
    }
  }
  const src=oc.createBufferSource(); src.buffer=buf;
  const bp=oc.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=650; bp.Q.value=0.5;
  const g=oc.createGain(); g.gain.value=1; g.connect(oc.destination);
  src.connect(bp); bp.connect(g); src.start(t0); src.stop(t0+dur+0.1);
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// COMPOSITEURS DE TRACKS
// b0 = Vorgath (For√™t), b1 = Nytherion (Ch√¢teau)
// b2 = Arakhne (Toile), b3 = Zarveth (Cristal), b4 = Thyrax (Sommet)
// Phases: 0=ambiant pr√©-boss, 1=combat, 2=rage
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const MUSIC_TRACKS = {

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // BOSS 0 ‚Äî VORGATH LE BR√õL√â  ¬∑  For√™t des Souvenirs  ¬∑  D mineur
  // Calibre : l√©ger ‚Äî boss introductif, percussions tribales moder√©es
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  'b0-0': { dur: 16.0, compose: async (oc, D) => {
    // Pr√©-boss : battement de c≈ìur + braises + drone forestier grave
    m_drone(oc, 36.71, 0, D, 0.28, {atk:3.0, rel:3.0, lp:130, harm:1});
    m_choir(oc, 73.42, 2.0, D-2.0, 0.05, {atk:5.0, rel:5.0, lp:260, dets:[-12,-6,0,6,12]});
    // Battement de c≈ìur (60 BPM)
    const BEAT = 60/54;
    for (let b = 0; b < Math.floor(D/BEAT); b++) {
      const t = b * BEAT;
      // Frappe 1
      const o1 = oc.createOscillator(), g1 = oc.createGain();
      o1.type = 'sine'; g1.connect(oc.destination); o1.connect(g1);
      o1.frequency.setValueAtTime(60, t); o1.frequency.exponentialRampToValueAtTime(26, t + 0.28);
      g1.gain.setValueAtTime(0, Math.max(0, t - 0.001));
      g1.gain.linearRampToValueAtTime(0.28, t + 0.006);
      g1.gain.exponentialRampToValueAtTime(0.0001, t + 0.32);
      o1.start(t); o1.stop(t + 0.36);
      // √âcho
      const o2 = oc.createOscillator(), g2 = oc.createGain();
      o2.type = 'sine'; g2.connect(oc.destination); o2.connect(g2);
      o2.frequency.setValueAtTime(48, t + 0.18); o2.frequency.exponentialRampToValueAtTime(22, t + 0.40);
      g2.gain.setValueAtTime(0, t + 0.18);
      g2.gain.linearRampToValueAtTime(0.11, t + 0.186);
      g2.gain.exponentialRampToValueAtTime(0.0001, t + 0.44);
      o2.start(t + 0.18); o2.stop(t + 0.48);
    }
    // Braises ‚Äî noise basse fr√©quence sporadique
    for (let i = 0; i < 4; i++) {
      const t = i * (D / 4) + 2.0;
      if (t < D - 1) m_noise(oc, t, 2.8, 0.012, {atk:0.8, ftype:'bandpass', freq:240+i*25, Q:1.1, pan:(i%2===0?-0.28:0.28)});
    }
  }},

  'b0-1': { dur: 16.0, compose: async (oc, D) => {
    // Combat Vorgath ‚Äî 98 BPM, tribal mod√©r√©
    const BEAT = 60/98, BAR = BEAT*4, BARS = Math.floor(D/BAR);
    m_drone(oc, 36.71, 0, D, 0.26, {atk:0.1, rel:0.3, lp:175, harm:2});
    // Basse D mineur
    const BP = [[0,0.17,73.42],[0.5,0.11,73.42],[1,0.20,87.31],[1.5,0.09,98.0],[2,0.17,65.41],[2.5,0.11,73.42],[3,0.24,55.0],[3.75,0.09,73.42]];
    for (let b = 0; b < BARS; b++) {
      const tB = b*BAR;
      for (const [bt, d, f] of BP) { const t0=tB+bt*BEAT; if (t0+d<D) m_distOsc(oc, f, t0, d, 0.20, 85, {lp:350, pan:0}); }
    }
    // Cordes sombres (pas trop charg√©es)
    const SP = [[0,73.42,BAR*1.4],[BAR*2,87.31,BAR*0.8],[BAR*4,73.42,BAR*1.6],[BAR*6,65.41,BAR*1.0]];
    for (let r = 0; r < Math.floor(BARS/8); r++) {
      for (const [b, f, d] of SP) {
        const t0 = r*BAR*8+b; if (t0+d<D) m_strings(oc, f, t0, d, 0.06, {atk:0.09, rel:0.22, lp:540, pan:-0.22});
      }
    }
    // Percussions tribales (l√©g√®res)
    for (let b = 0; b < BARS; b++) {
      const t = b*BAR;
      m_kick(oc, t, 0.62, 115, 33, {dec:0.40});
      m_kick(oc, t+0.5*BEAT, 0.24, 80, 27, {dec:0.26});
      m_kick(oc, t+2*BEAT, 0.57, 108, 31, {dec:0.37});
      if (b%2===1) m_kick(oc, t+3.5*BEAT, 0.30, 80, 25, {dec:0.22});
      m_taiko(oc, t, 0.44, {p0:70, p1:21, dec:0.48, pan:-0.28});
      m_taiko(oc, t+2*BEAT, 0.36, {p0:64, p1:19, dec:0.42, pan:0.28});
      m_snare(oc, t+BEAT, 0.30, {bf:168, bd:0.10, nd:0.13, ng:0.58, pan:0});
      m_snare(oc, t+3*BEAT, 0.32, {bf:173, bd:0.11, nd:0.14, ng:0.60, pan:0});
      for (let h = 0; h < 8; h++) m_hihat(oc, t+h*BEAT*0.5, (h%2===0?0.09:0.04), false, (h%2===0?-0.18:0.18));
    }
  }},

  'b0-2': { dur: 14.0, compose: async (oc, D) => {
    // Rage Vorgath ‚Äî 115 BPM, un cran au-dessus
    const BEAT = 60/115, BAR = BEAT*4, BARS = Math.floor(D/BAR);
    m_drone(oc, 36.71, 0, D, 0.30, {atk:0.05, rel:0.18, lp:195, harm:2});
    const BP2 = [[0,0.11,73.42],[0.25,0.06,73.42],[0.5,0.11,87.31],[0.75,0.06,98.0],[1,0.11,65.41],[1.25,0.06,73.42],[1.5,0.12,55.0],[2,0.11,73.42],[2.5,0.11,98.0],[3,0.11,65.41],[3.5,0.12,73.42]];
    for (let b = 0; b < BARS; b++) {
      const tB = b*BAR;
      for (const [bt, d, f] of BP2) { const t0=tB+bt*BEAT; if (t0+d<D) m_distOsc(oc, f, t0, d, 0.21, 108, {lp:330}); }
    }
    const HP = [[0,293.66,0.10],[0.5,329.63,0.08],[1.0,392.0,0.13],[2.0,440.0,0.15],[3.0,392.0,0.20]];
    for (let b = 0; b < BARS; b++) {
      const tB = b*BAR;
      for (const [bt, f, d] of HP) { const t0=tB+bt*BEAT; if (t0+d<D) m_distOsc(oc, f, t0, d, 0.09, 115, {lp:1150, pan:(b%2===0?-0.35:0.35), type:'sawtooth'}); }
    }
    for (let b = 0; b < BARS; b++) {
      const t = b*BAR;
      m_kick(oc, t, 0.65, 120, 36, {dec:0.29});
      m_kick(oc, t+0.5*BEAT, 0.33, 88, 29, {dec:0.19});
      m_kick(oc, t+2*BEAT, 0.65, 116, 34, {dec:0.29});
      m_kick(oc, t+2.5*BEAT, 0.35, 88, 27, {dec:0.19});
      m_snare(oc, t+BEAT, 0.40, {bf:228, bd:0.08, nd:0.17, ng:0.70, pan:0});
      m_snare(oc, t+3*BEAT, 0.42, {bf:235, bd:0.08, nd:0.18, ng:0.72, pan:0});
      m_taiko(oc, t, 0.40, {p0:70, p1:21, dec:0.33, pan:-0.32});
      m_taiko(oc, t+2*BEAT, 0.34, {p0:64, p1:19, dec:0.31, pan:0.32});
      for (let h = 0; h < 8; h++) m_hihat(oc, t+h*BEAT*0.5, (h%2===0?0.09:0.04), false, (h%3===0?-0.26:0.22));
    }
  }},

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // BOSS 1 ‚Äî NYTHERION LE REVENANT  ¬∑  Ch√¢teau des √âpreuves  ¬∑  A mineur
  // Calibre : spectral, √©labor√© ‚Äî l√©g√®rement plus riche et intense que b0
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  'b1-0': { dur: 14.0, compose: async (oc, D) => {
    m_wind(oc, 0, D, 0.065);
    m_drone(oc, 55.0, 0, D, 0.18, {atk:3.5, rel:3.5, lp:200, harm:1});
    m_choir(oc, 110.0, 0, D, 0.07, {atk:4.5, rel:4.5, lp:290, dets:[-13,-6,0,6,13]});
    const bells = [[2.2,220,0.085,3.2,-0.44],[7.0,196,0.072,2.8,0.44],[12.0,261.63,0.060,2.6,-0.28],[16.5,220,0.072,3.0,0.28],[20.5,174.61,0.055,2.3,0]];
    for (const [t, f, pk, d, pan] of bells) {
      if (t < D-0.5) { m_bell(oc, f, t, pk, d, pan); if (t+1.4<D-0.5) m_bell(oc, f, t+1.4, pk*0.30, d*0.75, pan*0.45); }
    }
  }},

  'b1-1': { dur: 16.0, compose: async (oc, D) => {
    // Combat Nytherion ‚Äî 90 BPM, ch≈ìurs fant√¥mes + piano spectral
    const BEAT = 60/90, BAR = BEAT*4, BARS = Math.floor(D/BAR);
    m_drone(oc, 55.0, 0, D, 0.22, {atk:2.0, rel:2.0, lp:182, harm:1});
    // Blocs d'accords de ch≈ìur (A mineur)
    const CHORDS = [[55,65.41,82.41],[49,61.74,73.42],[43.65,55,65.41],[55,73.42,98]];
    for (let i = 0; i < Math.floor(D/(BAR*4)); i++) {
      const ch = CHORDS[i%CHORDS.length], t0 = i*BAR*4, dur = Math.min(BAR*4.2, D-t0);
      for (const f of ch) if (t0 < D) m_choir(oc, f*4, t0, dur, 0.045, {atk:1.4, rel:2.6, lp:880, dets:[-7,-3,0,3,7]});
    }
    // Piano fant√¥me
    const PM = [[0,440,1.0],[BEAT,392,0.8],[BEAT*2,349.23,1.3],[BEAT*3,293.66,1.7],[BAR*2,329.63,0.8],[BAR*2+BEAT*2,261.63,1.5],[BAR*3+BEAT,220,1.9]];
    for (let r = 0; r < Math.floor(BARS/8); r++) {
      for (const [b, f, d] of PM) {
        const t0 = r*BAR*8+b; if (t0+d<D) m_osc(oc, 'sine', f, t0, d+0.7, 0.058, {atk:0.012, dec:0.07, sus:0.36, rel:d*0.44+0.22, pan:(r%2===0?0.10:-0.10)});
      }
    }
    // Cordes spectrales
    const SM = [[0,220,BAR*1.9],[BAR*2,196,BAR*1.6],[BAR*4,246.94,BAR*1.8],[BAR*6,220,BAR*1.6]];
    for (let r = 0; r < Math.floor(BARS/8); r++) {
      for (const [b, f, d] of SM) {
        const t0 = r*BAR*8+b; if (t0+d<D) m_strings(oc, f, t0, d, 0.055, {atk:0.4, rel:0.9, lp:650, pan:-0.30, vRate:3.6, vDepth:2.2});
      }
    }
    // Percussions l√©g√®res
    for (let b = 0; b < BARS; b++) {
      const t = b*BAR;
      m_kick(oc, t, 0.34, 80, 35, {dec:0.50});
      if (b%2===0) m_kick(oc, t+2*BEAT, 0.26, 70, 29, {dec:0.40});
      m_snare(oc, t+BEAT, 0.16, {bf:296, bd:0.06, nd:0.08, ng:0.26, pan:0});
      m_snare(oc, t+3*BEAT, 0.18, {bf:290, bd:0.06, nd:0.08, ng:0.26, pan:0});
      if (b%4===0) m_bell(oc, 880, t+BEAT*2, 0.048, 1.9, 0.46);
    }
  }},

  'b1-2': { dur: 14.0, compose: async (oc, D) => {
    // Rage Nytherion ‚Äî cordes + ch≈ìurs d√©cha√Æn√©s, percussions plus denses
    const BEAT = 60/90, BAR = BEAT*4, BARS = Math.floor(D/BAR);
    m_drone(oc, 55.0, 0, D, 0.28, {atk:0.5, rel:0.8, lp:198, harm:2});
    const SR = [[0,220,BAR*1.5],[BAR*0.5,261.63,BAR*1.2],[BAR*2,246.94,BAR*1.5],[BAR*2.5,293.66,BAR*1.2],[BAR*4,329.63,BAR*1.6],[BAR*5,349.23,BAR*1.5],[BAR*6,392,BAR*1.2],[BAR*7,440,BAR*1.6]];
    for (let r = 0; r < Math.floor(BARS/8); r++) {
      for (const [b, f, d] of SR) {
        const t0 = r*BAR*8+b; if (t0+d<D) {
          m_strings(oc, f, t0, d, 0.085, {atk:0.18, rel:0.38, lp:870, pan:-0.26, vRate:4.0, vDepth:2.4});
          m_strings(oc, f*2, t0+0.14, d*0.82, 0.050, {atk:0.13, rel:0.32, lp:1280, pan:0.26, vRate:4.3, vDepth:2.4});
        }
      }
    }
    const CH2 = [[220,440,330],[196,392,293],[246.94,493.88,370],[261.63,523.25,392]];
    for (let i = 0; i < Math.floor(D/(BAR*4)); i++) {
      const t0 = i*BAR*4, dur = Math.min(BAR*4.2, D-t0);
      for (const f of CH2[i%CH2.length]) if (t0<D) m_choir(oc, f, t0, dur, 0.050, {atk:1.0, rel:2.0, lp:1380, dets:[-9,-4,0,4,9]});
    }
    for (let b = 0; b < BARS; b++) {
      const t = b*BAR;
      m_kick(oc, t, 0.50, 92, 37, {dec:0.37});
      m_kick(oc, t+2*BEAT, 0.43, 86, 33, {dec:0.32});
      if (b%2===1) m_kick(oc, t+1.5*BEAT, 0.22, 68, 27, {dec:0.22});
      m_snare(oc, t+BEAT, 0.34, {bf:190, bd:0.11, nd:0.16, ng:0.56, pan:0});
      m_snare(oc, t+3*BEAT, 0.36, {bf:194, bd:0.12, nd:0.17, ng:0.58, pan:0});
      if (b%2===0) for (let h = 0; h < 4; h++) m_hihat(oc, t+h*BEAT, 0.08, (h===2), h%2===0?-0.25:0.25);
      if (b%4===0) m_bell(oc, 1318.51, t, 0.064, 1.2, 0.52);
      if (b%4===2) m_bell(oc, 987.77, t+BEAT*2, 0.050, 0.95, -0.42);
    }
  }},

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // BOSS 2 ‚Äî ARAKHNE LA TISSEUSE  ¬∑  La Toile de l'Abomination  ¬∑  E phrygien
  // Calibre : plus sombre, organique, cliquetis chitineux ‚Äî nettement plus intense que b1
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  'b2-0': { dur: 14.0, compose: async (oc, D) => {
    m_drone(oc, 41.2, 0, D, 0.30, {atk:2.5, rel:2.5, lp:78, harm:1});
    m_drone(oc, 82.41, 1.0, D-1.0, 0.09, {atk:3.0, rel:2.0, lp:62, harm:0});
    // Cliquetis de pattes arachniennes
    for (let i = 0; i < 22; i++) {
      const t = i*(D/22) + (Math.sin(i*1.7)*0.20);
      if (t < D-0.08) m_noise(oc, t, 0.028, 0.076, {atk:0.001, ftype:'highpass', freq:3500+i*100, Q:7, pan:(i%2===0?-0.60:0.60)});
    }
    // Vibrations de toile
    for (let i = 0; i < 5; i++) {
      const t = i*4.4+1.5; if (t < D-1.2) m_noise(oc, t, 1.5, 0.092, {atk:0.012, ftype:'lowpass', freq:72, Q:0.8, pink:true});
    }
    m_wind(oc, 0, D, 0.042);
    // Bourdonnement de soie grave
    for (let i = 0; i < 3; i++) {
      const t = i*7.2+2.2; if (t < D-2) m_osc(oc, 'sine', 102+i*16, t, 2.0, 0.046, {atk:0.9, dec:0.3, sus:0.38, rel:0.9, lp:270});
    }
  }},

  'b2-1': { dur: 16.0, compose: async (oc, D) => {
    // Combat Arakhne ‚Äî 104 BPM, rythme organique irr√©gulier
    const BEAT = 60/104, BAR = BEAT*4, BARS = Math.floor(D/BAR);
    m_drone(oc, 41.2, 0, D, 0.27, {atk:0.14, rel:0.36, lp:142, harm:2});
    // Basse E phrygien
    const BPW = [[0,0.16,82.41],[0.5,0.10,82.41],[1,0.18,98.0],[1.5,0.09,92.5],[2,0.16,82.41],[3,0.18,73.42],[3.5,0.11,87.31]];
    for (let b = 0; b < BARS; b++) {
      const tB = b*BAR;
      for (const [bt, d, f] of BPW) { const t0=tB+bt*BEAT; if (t0+d<D) m_distOsc(oc, f, t0, d, 0.22, 90, {lp:260, type:'sine'}); }
    }
    // Cordes arachniennes dissonantes
    const CW = [[0,164.81,0.58,0.068],[BEAT,185.0,0.44,0.058],[BEAT*2,174.61,0.68,0.068],[BEAT*3,155.56,0.50,0.058]];
    for (let b = 0; b < BARS; b++) {
      const tB = b*BAR;
      for (const [bt, fr, d, g] of CW) {
        const t0 = tB+bt; if (t0+d<D) {
          m_strings(oc, fr, t0, d, g, {atk:0.04, rel:0.15, lp:640, pan:(b%2===0?-0.38:0.38), vRate:6, vDepth:3.0});
          if (b%3===0) m_flute(oc, fr*2, t0+0.08, d*0.52, 0.036, {vRate:7, vDepth:4.8, pan:(b%2===0?0.30:-0.30)});
        }
      }
    }
    // Percussions organiques irr√©guli√®res
    for (let b = 0; b < BARS; b++) {
      const t = b*BAR;
      m_taiko(oc, t, 0.56, {p0:86, p1:27, dec:0.31, pan:-0.26});
      m_taiko(oc, t+0.5*BEAT, 0.22, {p0:98, p1:33, dec:0.16, pan:0.46});
      m_taiko(oc, t+1.5*BEAT, 0.42, {p0:80, p1:25, dec:0.26, pan:0.26});
      m_taiko(oc, t+2*BEAT, 0.56, {p0:86, p1:27, dec:0.31, pan:0.26});
      m_taiko(oc, t+2.75*BEAT, 0.20, {p0:94, p1:35, dec:0.15, pan:-0.46});
      m_taiko(oc, t+3*BEAT, 0.46, {p0:82, p1:25, dec:0.23, pan:-0.26});
      // Cliquetis haute fr√©quence
      for (let h = 0; h < 8; h++) m_noise(oc, t+h*BEAT*0.5, 0.018, 0.046, {atk:0.001, ftype:'highpass', freq:3900+h*145, Q:5, pan:(h%2===0?-0.36:0.36)});
      if (b%3===0) m_bell(oc, 880, t+BEAT*0.25, 0.036, 0.70, 0.42);
      if (b%3===1) m_bell(oc, 659.25, t+BEAT*2.25, 0.030, 0.60, -0.42);
    }
  }},

  'b2-2': { dur: 14.0, compose: async (oc, D) => {
    // Rage Arakhne ‚Äî 126 BPM, fren√©tique acide
    const BEAT = 60/126, BAR = BEAT*4, BARS = Math.floor(D/BAR);
    m_drone(oc, 41.2, 0, D, 0.34, {atk:0.08, rel:0.17, lp:162, harm:3});
    const BRW = [[0,0.09,82.41],[0.25,0.06,82.41],[0.5,0.08,98.0],[0.75,0.06,82.41],[1,0.09,73.42],[1.5,0.08,82.41],[2,0.09,92.5],[2.5,0.07,110.0],[3,0.09,82.41],[3.5,0.07,61.74]];
    for (let b = 0; b < BARS; b++) {
      const tB = b*BAR;
      for (const [bt, d, fr] of BRW) { const t0=tB+bt*BEAT; if (t0+d<D) m_distOsc(oc, fr, t0, d, 0.24, 118, {lp:298, type:'sawtooth'}); }
    }
    const SW2 = [[0,329.63,0.13],[BEAT*0.5,311.13,0.10],[BEAT,349.23,0.17],[BEAT*1.5,329.63,0.11],[BEAT*2,311.13,0.15],[BEAT*2.5,369.99,0.21],[BEAT*3,349.23,0.13]];
    for (let b = 0; b < BARS; b++) {
      const tB = b*BAR;
      for (const [bt, fr, d] of SW2) {
        const t0 = tB+bt; if (t0+d<D) m_strings(oc, fr, t0, d, 0.048, {atk:0.020, rel:0.042, lp:1680, pan:(b%2===0?-0.40:0.40), vRate:7, vDepth:3.0});
      }
    }
    for (let b = 0; b < BARS; b++) {
      const t = b*BAR;
      m_taiko(oc, t, 0.70, {p0:94, p1:29, dec:0.25, pan:-0.26});
      m_taiko(oc, t+0.25*BEAT, 0.26, {p0:84, p1:35, dec:0.16, pan:0.46});
      m_taiko(oc, t+0.75*BEAT, 0.32, {p0:98, p1:33, dec:0.17, pan:0.26});
      m_taiko(oc, t+BEAT, 0.44, {p0:90, p1:29, dec:0.23, pan:0.18});
      m_taiko(oc, t+1.5*BEAT, 0.25, {p0:84, p1:27, dec:0.17, pan:-0.36});
      m_taiko(oc, t+2*BEAT, 0.70, {p0:94, p1:29, dec:0.25, pan:0.26});
      m_taiko(oc, t+3*BEAT, 0.48, {p0:90, p1:29, dec:0.20, pan:0.18});
      m_snare(oc, t+BEAT, 0.40, {bf:222, bd:0.06, nd:0.13, ng:0.68, pan:0});
      m_snare(oc, t+3*BEAT, 0.42, {bf:229, bd:0.07, nd:0.14, ng:0.70, pan:0});
      for (let h = 0; h < 8; h++) m_noise(oc, t+h*BEAT*0.5, 0.013, (h%2===0?0.068:0.032), {atk:0.001, ftype:'highpass', freq:3600+h*190, Q:4, pan:(h%3===0?-0.46:0.36)});
    }
  }},

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // BOSS 3 ‚Äî ZARVETH LE COLOSSE PRISMATIQUE  ¬∑  D√©sert de Cristal  ¬∑  C# mineur
  // Calibre : froid + tranchant + puissant ‚Äî encore plus intense que b2
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  'b3-0': { dur: 14.0, compose: async (oc, D) => {
    m_drone(oc, 34.65, 0, D, 0.33, {atk:3.5, rel:3.5, lp:116, harm:1});
    m_drone(oc, 51.91, 1.5, D-1.5, 0.10, {atk:4.0, rel:3.0, lp:88, harm:0});
    // Tintements cristallins nets
    const bt = [1.0,3.6,6.5,9.4,12.8,16.2,20.0,23.5];
    for (let i = 0; i < bt.length; i++) {
      const t = bt[i]; if (t < D-1) {
        m_bell(oc, 1396.91, t, 0.040, 2.6, i%2===0?-0.46:0.46);
        m_bell(oc, 1661.22, t+0.07, 0.024, 2.0, i%2===0?0.28:-0.28);
        if (i%3===0 && t+0.20<D-1) m_bell(oc, 2093.0, t+0.17, 0.015, 1.5, 0);
      }
    }
    // Craquements cristallins
    for (let i = 0; i < 6; i++) {
      const tt = i*3.8+2.2; if (tt < D-1.5) {
        m_noise(oc, tt, 0.40, 0.068, {atk:0.003, ftype:'bandpass', freq:2400+i*200, Q:9, pan:(i%2===0?-0.38:0.38)});
        if (tt+0.10<D-1) m_noise(oc, tt+0.09, 0.26, 0.034, {atk:0.002, ftype:'bandpass', freq:3800+i*160, Q:12, pan:(i%2===0?0.26:-0.26)});
      }
    }
    m_wind(oc, 0, D, 0.038);
    m_osc(oc, 'sine', 523.25, 3.0, D-3.5, 0.020, {atk:2.0, dec:0.5, sus:0.58, rel:2.0, lp:1550});
  }},

  'b3-1': { dur: 16.0, compose: async (oc, D) => {
    // Combat Zarveth ‚Äî 96 BPM, g√©om√©trique, martel√©
    const BEAT = 60/96, BAR = BEAT*4, BARS = Math.floor(D/BAR);
    m_drone(oc, 34.65, 0, D, 0.30, {atk:0.12, rel:0.30, lp:154, harm:2});
    // Basse C# mineur (triangle = froid)
    const BPC = [[0,0.18,69.30],[0.5,0.11,69.30],[1,0.16,87.31],[1.5,0.09,82.41],[2,0.18,69.30],[3,0.18,61.74],[3.5,0.11,77.78]];
    for (let b = 0; b < BARS; b++) {
      const tB = b*BAR;
      for (const [bt, d, f] of BPC) { const t0=tB+bt*BEAT; if (t0+d<D) m_distOsc(oc, f, t0, d, 0.24, 84, {lp:244, type:'triangle'}); }
    }
    // M√©lodie cristalline
    const MC = [[0,554.37,0.48,0.064],[BEAT,493.88,0.38,0.056],[BEAT*2,587.33,0.80,0.070],[BEAT*3,554.37,0.48,0.058]];
    for (let b = 0; b < BARS; b += 2) {
      const tB = b*BAR;
      for (const [bt, fr, d, g] of MC) {
        const t0 = tB+bt; if (t0+d<D) {
          m_bell(oc, fr, t0, g, d+0.2, 0.28);
          m_flute(oc, fr*0.5, t0+0.05, d*0.70, 0.054, {vRate:3.5, vDepth:2.6, pan:(b%4===0?-0.28:0.28)});
        }
      }
    }
    // Cordes de verre froides
    const CC = [[0,138.59,1.2,0.062],[BAR,164.81,1.2,0.058],[BAR*2,155.56,1.2,0.062],[BAR*3,138.59,1.5,0.068]];
    for (let r = 0; r < Math.floor(BARS/4); r++) {
      for (const [b, fr, d, g] of CC) {
        const t0 = r*BAR*4+b; if (t0+d<D) m_strings(oc, fr, t0, d, g, {atk:0.20, rel:0.48, lp:690, pan:-0.18, vRate:3.4, vDepth:1.9});
      }
    }
    // Percussions cristallines
    for (let b = 0; b < BARS; b++) {
      const t = b*BAR;
      m_kick(oc, t, 0.62, 98, 37, {dec:0.34});
      m_kick(oc, t+2*BEAT, 0.56, 94, 33, {dec:0.30});
      if (b%2===1) m_kick(oc, t+BEAT*1.5, 0.24, 78, 29, {dec:0.22});
      m_snare(oc, t+BEAT, 0.34, {bf:302, bd:0.09, nd:0.15, ng:0.58, pan:0});
      m_snare(oc, t+3*BEAT, 0.36, {bf:310, bd:0.10, nd:0.16, ng:0.60, pan:0});
      for (let h = 0; h < 4; h++) m_noise(oc, t+h*BEAT, 0.050, 0.070, {atk:0.003, ftype:'bandpass', freq:3200+h*260, Q:11, pan:(h%2===0?-0.30:0.30)});
      if (b%4===0) m_bell(oc, 1046.5, t+BEAT, 0.052, 0.95, 0.40);
      if (b%4===2) m_bell(oc, 830.61, t+BEAT*3, 0.044, 0.75, -0.40);
    }
  }},

  'b3-2': { dur: 14.0, compose: async (oc, D) => {
    // Rage Zarveth ‚Äî 120 BPM, √©blouissant, prismatique
    const BEAT = 60/120, BAR = BEAT*4, BARS = Math.floor(D/BAR);
    m_drone(oc, 34.65, 0, D, 0.36, {atk:0.08, rel:0.19, lp:188, harm:3});
    // Basse rapide C# mineur
    const BRC = [[0,0.10,69.30],[0.25,0.06,69.30],[0.5,0.09,87.31],[0.75,0.06,69.30],[1,0.10,61.74],[1.5,0.10,69.30],[2,0.10,82.41],[2.5,0.08,98.0],[3,0.10,69.30],[3.5,0.08,51.91]];
    for (let b = 0; b < BARS; b++) {
      const tB = b*BAR;
      for (const [bt, d, fr] of BRC) { const t0=tB+bt*BEAT; if (t0+d<D) m_distOsc(oc, fr, t0, d, 0.26, 128, {lp:290, type:'sawtooth'}); }
    }
    // Cordes hautes prismatiques
    const SC = [[0,1108.73,0.15],[BEAT*0.5,987.77,0.11],[BEAT,1046.5,0.17],[BEAT*2,1108.73,0.13],[BEAT*2.5,1174.66,0.17],[BEAT*3,1108.73,0.24]];
    for (let b = 0; b < BARS; b++) {
      const tB = b*BAR;
      for (const [bt, fr, d] of SC) {
        const t0 = tB+bt; if (t0+d<D) m_strings(oc, fr, t0, d, 0.050, {atk:0.024, rel:0.048, lp:2650, pan:(b%2===0?-0.40:0.40), vRate:7, vDepth:2.9});
      }
    }
    // Eclats cristallins
    for (let b = 0; b < BARS; b++) {
      if (b%2===0) {
        const t = b*BAR;
        if (t+0.08<D) m_bell(oc, 1760.0, t, 0.076, 0.44, 0.48);
        if (t+2*BEAT+0.07<D) m_bell(oc, 1396.91, t+2*BEAT, 0.063, 0.39, -0.48);
      }
      if (b%4===1 && b*BAR+BEAT<D) m_bell(oc, 2093.0, b*BAR+BEAT, 0.052, 0.31, 0);
    }
    // Taiko+snare martel√©s
    for (let b = 0; b < BARS; b++) {
      const t = b*BAR;
      m_taiko(oc, t, 0.74, {p0:86, p1:25, dec:0.31, pan:-0.26});
      m_taiko(oc, t+0.5*BEAT, 0.28, {p0:72, p1:29, dec:0.19, pan:0.40});
      m_taiko(oc, t+BEAT, 0.44, {p0:90, p1:27, dec:0.25, pan:0.16});
      m_taiko(oc, t+1.5*BEAT, 0.22, {p0:66, p1:23, dec:0.17, pan:-0.40});
      m_taiko(oc, t+2*BEAT, 0.74, {p0:86, p1:25, dec:0.31, pan:0.26});
      m_taiko(oc, t+3*BEAT, 0.44, {p0:80, p1:23, dec:0.25, pan:-0.16});
      m_snare(oc, t+BEAT, 0.44, {bf:258, bd:0.07, nd:0.15, ng:0.72, pan:0});
      m_snare(oc, t+3*BEAT, 0.48, {bf:266, bd:0.08, nd:0.16, ng:0.74, pan:0});
      for (let h = 0; h < 8; h++) m_noise(oc, t+h*BEAT*0.5, 0.024, (h%2===0?0.088:0.042), {atk:0.002, ftype:'bandpass', freq:2700+h*230, Q:8, pan:(h%3===0?-0.40:0.32)});
    }
  }},

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // BOSS 4 ‚Äî THYRAX SUPR√äME  ¬∑  Sommet de la Sagesse  ¬∑  E mineur √©pique
  // Calibre : MAXIMUM ‚Äî boss final, taiko massif, orchestre complet, rage totale
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  'b4-0': { dur: 14.0, compose: async (oc, D) => {
    // Silence du sommet ‚Äî vent glacial + grondements draconiennes
    m_wind(oc, 0, D, 0.080);
    m_drone(oc, 41.2, 0, D, 0.38, {atk:3.0, rel:3.0, lp:125, harm:1});
    m_drone(oc, 55.0, 1.5, D-1.5, 0.11, {atk:3.5, rel:2.5, lp:88, harm:0});
    // Grondements de dragon (sub-bass boomers)
    const gt = [1.5, 10.2, 18.0];
    for (const tt of gt) {
      if (tt < D-2) {
        m_noise(oc, tt, 2.8, 0.20, {atk:0.014, ftype:'lowpass', freq:68, Q:0.6, pink:true});
        m_noise(oc, tt+0.3, 3.5, 0.09, {atk:0.06, ftype:'bandpass', freq:170, Q:0.5});
      }
    }
    // Cloches solennelles
    if (D > 8) { m_bell(oc, 329.63, 6.5, 0.072, 4.2, 0); m_bell(oc, 246.94, 6.7, 0.045, 3.8, 0.28); }
  }},

  'b4-1': { dur: 16.0, compose: async (oc, D) => {
    // Combat Thyrax ‚Äî 100 BPM, taiko massif + fl√ªte orientale + cordes √©piques
    const BEAT = 60/100, BAR = BEAT*4, BARS = Math.floor(D/BAR);
    m_drone(oc, 41.2, 0, D, 0.34, {atk:0.15, rel:0.38, lp:182, harm:2});
    m_drone(oc, 61.74, 0, D, 0.10, {atk:0.50, rel:0.38, lp:162, harm:0});
    // Basse modale E phrygien
    const BP3 = [[0,0.19,82.41],[1,0.19,82.41],[1.5,0.13,98.0],[2,0.21,73.42],[3,0.19,82.41],[3.5,0.11,87.31]];
    for (let b = 0; b < BARS; b++) {
      const tB = b*BAR;
      for (const [bt, d, f] of BP3) { const t0=tB+bt*BEAT; if (t0+d<D) m_distOsc(oc, f, t0, d, 0.23, 94, {lp:262, type:'sine'}); }
    }
    // Fl√ªte bambou ‚Äî E mineur pentatonique (le joyau m√©lodique du jeu)
    const FPH = [
      [[0,164.81,0.60,0.115],[BEAT*1.5,196.0,0.44,0.100],[BEAT*3,220.0,1.10,0.108]],
      [[0,246.94,0.54,0.105],[BEAT,220.0,0.72,0.092],[BEAT*2.5,196.0,1.38,0.100]],
      [[0,164.81,0.38,0.088],[BEAT*2,185.0,0.78,0.098],[BEAT*3.5,164.81,0.45,0.080]],
      [[0,220.0,0.42,0.105],[BEAT*1.5,246.94,0.35,0.088],[BEAT*2.5,220.0,0.52,0.080],[BEAT*3.5,196.0,1.65,0.098]]
    ];
    for (let r = 0; r < Math.floor(BARS/8); r++) {
      for (let pi = 0; pi < FPH.length; pi++) {
        const t0 = r*BAR*8+pi*BAR*2;
        for (const [b, f, d, g] of FPH[pi]) { if (t0+b+d<D) m_flute(oc, f, t0+b, d, g, {vRate:4.5, vDepth:4, pan:(pi%2===0?-0.20:0.20)}); }
      }
    }
    // Cordes √©piques amples
    const SE = [[0,164.81,BAR*2.4,0.080],[BAR*2,196.0,BAR*2.1,0.075],[BAR*4,220.0,BAR*2.4,0.080],[BAR*6,196.0,BAR*2.1,0.075]];
    for (let r = 0; r < Math.floor(BARS/8); r++) {
      for (const [b, f, d, g] of SE) {
        const t0 = r*BAR*8+b; if (t0+d<D) m_strings(oc, f, t0, d, g, {atk:0.30, rel:0.68, lp:940, pan:-0.22, vRate:3.7, vDepth:2.7});
      }
    }
    // TAIKO massif ‚Äî le plus lourd du jeu
    for (let b = 0; b < BARS; b++) {
      const t = b*BAR;
      m_taiko(oc, t, 0.80, {p0:90, p1:27, dec:0.56, pan:-0.24});
      m_taiko(oc, t+2*BEAT, 0.68, {p0:84, p1:25, dec:0.50, pan:0.24});
      m_taiko(oc, t+BEAT*0.75, 0.30, {p0:108, p1:48, dec:0.29, pan:0.46});
      m_taiko(oc, t+BEAT*2.5, 0.27, {p0:102, p1:46, dec:0.25, pan:-0.46});
      if (b%2===1) m_taiko(oc, t+BEAT*3.5, 0.36, {p0:92, p1:37, dec:0.31, pan:0});
      // Snare l√©ger (pour ne pas √©craser la fl√ªte)
      m_snare(oc, t+BEAT, 0.16, {bf:400, bd:0.05, nd:0.08, ng:0.40, pan:-0.26});
      m_snare(oc, t+BEAT*3, 0.18, {bf:386, bd:0.05, nd:0.08, ng:0.40, pan:0.26});
      if (b%4===0) m_bell(oc, 784, t+BEAT, 0.068, 1.0, 0.36);
      if (b%4===2) m_bell(oc, 659.25, t+BEAT*3, 0.056, 0.88, -0.36);
    }
  }},

  'b4-2': { dur: 14.0, compose: async (oc, D) => {
    // RAGE THYRAX ‚Äî 130 BPM, apog√©e total ‚Äî le plus intense de tout le jeu
    const BEAT = 60/130, BAR = BEAT*4, BARS = Math.floor(D/BAR);
    m_drone(oc, 41.2, 0, D, 0.38, {atk:0.08, rel:0.20, lp:205, harm:3});
    // Basse ultra-agressive sawtooth
    const BF = [[0,0.11,82.41],[0.25,0.06,82.41],[0.5,0.10,98.0],[0.75,0.06,82.41],[1,0.11,73.42],[1.5,0.11,82.41],[2,0.11,82.41],[2.5,0.10,110.0],[2.75,0.07,98.0],[3,0.11,82.41],[3.25,0.07,73.42],[3.5,0.12,82.41],[3.75,0.08,61.74]];
    for (let b = 0; b < BARS; b++) {
      const tB = b*BAR;
      for (const [bt, d, f] of BF) { const t0=tB+bt*BEAT; if (t0+d<D) m_distOsc(oc, f, t0, d, 0.26, 138, {lp:318, type:'sawtooth'}); }
    }
    // Cordes de rage hautes ‚Äî la m√©lodie de h√©ros bris√©e
    const SH = [[0,659.25,0.21],[BEAT*0.5,587.33,0.16],[BEAT,659.25,0.25],[BEAT*2,740.0,0.19],[BEAT*2.5,698.46,0.21],[BEAT*3,659.25,0.32],[BEAT*3.5,587.33,0.14]];
    for (let b = 0; b < BARS; b++) {
      const tB = b*BAR;
      for (const [bt, f, d] of SH) {
        const t0 = tB+bt*BEAT; if (t0+d<D) m_strings(oc, f, t0, d, 0.066, {atk:0.036, rel:0.072, lp:2080, pan:(b%2===0?-0.40:0.40), vRate:6, vDepth:3.1});
      }
    }
    // Brass stabs de victoire/d√©faite (distorsion carr√©e)
    for (let b = 0; b < BARS; b++) {
      if (b%2===0) {
        const t = b*BAR;
        if (t+0.10<D) m_distOsc(oc, 164.81*4, t, 0.072, 0.12, 70, {lp:1850, type:'square'});
        if (t+2*BEAT+0.08<D) m_distOsc(oc, 196.0*4, t+2*BEAT, 0.062, 0.10, 70, {lp:1650, type:'square'});
      }
    }
    // TAIKO FINAL ‚Äî densit√© maximale
    for (let b = 0; b < BARS; b++) {
      const t = b*BAR;
      m_taiko(oc, t, 0.82, {p0:92, p1:27, dec:0.38, pan:-0.26});
      m_taiko(oc, t+0.5*BEAT, 0.28, {p0:76, p1:32, dec:0.23, pan:0.38});
      m_taiko(oc, t+BEAT, 0.40, {p0:96, p1:35, dec:0.31, pan:0.16});
      m_taiko(oc, t+1.5*BEAT, 0.24, {p0:72, p1:27, dec:0.21, pan:-0.38});
      m_taiko(oc, t+2*BEAT, 0.82, {p0:92, p1:27, dec:0.38, pan:0.26});
      m_taiko(oc, t+2.5*BEAT, 0.28, {p0:76, p1:32, dec:0.23, pan:-0.26});
      m_taiko(oc, t+3*BEAT, 0.44, {p0:86, p1:29, dec:0.31, pan:-0.16});
      if (b%2===0) m_taiko(oc, t+3.5*BEAT, 0.33, {p0:82, p1:27, dec:0.25, pan:0.36});
      m_snare(oc, t+BEAT, 0.46, {bf:282, bd:0.08, nd:0.16, ng:0.76, pan:0});
      m_snare(oc, t+BEAT*3, 0.50, {bf:289, bd:0.08, nd:0.17, ng:0.78, pan:0});
      for (let h = 0; h < 8; h++) m_hihat(oc, t+h*BEAT*0.5, (h%2===0?0.11:0.054), false, (h%3===0?-0.36:0.27));
      if (b%2===0) m_bell(oc, 1046.5, t, 0.088, 0.46, 0.56);
      if (b%2===1) m_bell(oc, 880, t+2*BEAT, 0.072, 0.42, -0.56);
    }
  }}

}; // fin MUSIC_TRACKS

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// MOTEUR DE LECTURE ‚Äî BossMusic (rendu offline + cache)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const BossMusic = (() => {
  let actx = null, masterGain = null, limiter = null;
  let currentSrc = null;
  const bufCache = {};
  let _engaged = false;

  function getCtx() {
    if (!actx) {
      actx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: MUSIC_SR });
      masterGain = actx.createGain(); masterGain.gain.value = 0.58;
      limiter = actx.createDynamicsCompressor();
      limiter.threshold.value = -4; limiter.knee.value = 4;
      limiter.ratio.value = 20; limiter.attack.value = 0.001; limiter.release.value = 0.08;
      masterGain.connect(limiter); limiter.connect(actx.destination);
    }
    if (actx.state === 'suspended') actx.resume();
    return actx;
  }

  async function renderTrack(key) {
    if (bufCache[key]) return bufCache[key];
    const def = MUSIC_TRACKS[key];
    if (!def) throw new Error('Unknown track: ' + key);
    const D = def.dur;
    // Pas de silence final ‚Äî on boucle exactement sur D secondes
    const oc = new OfflineAudioContext(2, Math.ceil(MUSIC_SR * D), MUSIC_SR);
    await def.compose(oc, D);
    const buf = await oc.startRendering();
    // Soft clip
    for (let ch = 0; ch < buf.numberOfChannels; ch++) {
      const d = buf.getChannelData(ch);
      for (let i = 0; i < d.length; i++) {
        if (Math.abs(d[i]) > 0.7) d[i] = d[i] > 0 ? 0.7 + 0.2*Math.tanh((d[i]-0.7)*3) : -(0.7+0.2*Math.tanh((-d[i]-0.7)*3));
      }
      // Fade out les 50 derni√®res ms pour √©viter le clic au loop
      const fadeLen = Math.min(Math.floor(MUSIC_SR * 0.05), d.length);
      for (let i = 0; i < fadeLen; i++) d[d.length - fadeLen + i] *= (1 - i / fadeLen);
    }
    bufCache[key] = buf;
    return buf;
  }

  function _playBuffer(buf, vol=0.75, fadein=0.8) {
    const c = getCtx();
    if (currentSrc) { try { currentSrc.stop(); } catch(e){} currentSrc = null; }
    const src = c.createBufferSource();
    src.buffer = buf;
    src.loop = true;
    src.loopStart = 0;
    src.loopEnd = buf.duration; // exactement D secondes, pas de silence
    const g = c.createGain();
    g.gain.setValueAtTime(0, c.currentTime);
    g.gain.linearRampToValueAtTime(vol, c.currentTime + fadein);
    src.connect(g); g.connect(masterGain); src.start();
    currentSrc = src; currentSrc._gainNode = g;
  }

  async function _crossfade(key, vol=0.75) {
    const c = getCtx();
    // Si le buffer n'est pas encore pr√™t, on joue quand m√™me d√®s qu'il est l√†
    // mais on garde la musique courante en attendant (pas de silence)
    const buf = await renderTrack(key);
    if (currentSrc?._gainNode) {
      const og = currentSrc._gainNode;
      og.gain.setValueAtTime(og.gain.value, c.currentTime);
      og.gain.linearRampToValueAtTime(0, c.currentTime + 0.4);
      const old = currentSrc; currentSrc = null;
      setTimeout(() => { try { old.stop(); } catch(e){} }, 500);
    }
    // D√©marrer la nouvelle piste imm√©diatement apr√®s le fade (pas de silence)
    setTimeout(() => _playBuffer(buf, vol, 0.4), 420);
  }

  return {
    // Pr√©-rend toutes les tracks d'un niveau, retourne une Promise
    async preloadLevel(idx) {
      const keys = [`b${idx}-0`, `b${idx}-1`, `b${idx}-2`];
      await Promise.all(keys.map(k => renderTrack(k).catch(e => console.warn('Preload failed', k, e))));
    },
    // Rend une seule track (pour le chargement initial avec progression)
    async renderOne(key) {
      return renderTrack(key);
    },
    init() { getCtx(); },
    onLoadLevel(idx) {
      _engaged = false;
      renderTrack(`b${idx}-0`).then(buf => _playBuffer(buf, 0.52, 2.0)).catch(console.error);
    },
    onSpawnBoss() {},
    onCombatStart(lvlIdx) {
      if (_engaged) return; _engaged = true;
      _crossfade(`b${lvlIdx}-1`, 0.75);
    },
    onRageMode(lvlIdx) { _crossfade(`b${lvlIdx}-2`, 0.84); },
    stop(fadeDur=1.5) {
      if (!actx || !currentSrc) return;
      if (currentSrc._gainNode) {
        const g = currentSrc._gainNode;
        g.gain.setValueAtTime(g.gain.value, actx.currentTime);
        g.gain.linearRampToValueAtTime(0, actx.currentTime + fadeDur);
      }
      const s = currentSrc; currentSrc = null;
      setTimeout(() => { try { s.stop(); } catch(e){} }, fadeDur*1000+200);
    },
    get engaged() { return _engaged; }
  };
})();
</script>
</body>

</html>
