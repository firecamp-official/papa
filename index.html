<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
  <title>Anniversaire Papa ‚öîÔ∏è ULTIMATE</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323:wght@400&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      image-rendering: pixelated;
      -webkit-tap-highlight-color: transparent;
    }

    html,
    body {
      background: #000;
      overflow: hidden;
      font-family: 'Press Start 2P', monospace;
      touch-action: none;
      width: 100%;
      height: 100%;
    }

    /* ====== TITLE ====== */
    #title {
      position: fixed;
      inset: 0;
      z-index: 300;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: radial-gradient(ellipse at 50% 60%, #0d1a0a 0%, #050a03 100%);
    }

    #title-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
    }

    .title-content {
      position: relative;
      z-index: 2;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding: 0 20px;
      width: 100%;
    }

    .title-logo {
      font-size: clamp(13px, 3.5vw, 26px);
      color: #ffd700;
      text-align: center;
      line-height: 2.2;
      text-shadow: 0 0 20px #ffd700aa, 4px 4px 0 #8b5e00, 8px 8px 0 #3a2500;
      animation: logoPulse 3s ease-in-out infinite;
      letter-spacing: 2px;
    }

    .title-tagline {
      font-family: 'VT323', monospace;
      font-size: clamp(18px, 4vw, 32px);
      color: #e8d890;
      text-shadow: 2px 2px 0 #553300;
      letter-spacing: 3px;
    }

    .title-sword {
      font-size: clamp(50px, 10vw, 80px);
      animation: swordFloat 2.5s ease-in-out infinite;
      filter: drop-shadow(0 0 20px #ffd700);
    }

    .start-btn {
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(9px, 2vw, 13px);
      background: linear-gradient(180deg, #c8a020 0%, #8b5e00 100%);
      color: #000;
      border: none;
      padding: 14px 32px;
      cursor: pointer;
      box-shadow: 0 0 0 3px #ffd700, 0 0 0 5px #000, 4px 4px 0 #000;
      margin-top: 6px;
      letter-spacing: 1px;
    }

    .start-btn:active {
      transform: translate(3px, 3px);
      box-shadow: 0 0 0 3px #ffd700, 0 0 0 5px #000, 1px 1px 0 #000;
    }

    .title-features {
      font-family: 'VT323', monospace;
      font-size: clamp(13px, 3vw, 19px);
      color: #9a8a60;
      text-align: center;
      line-height: 1.9;
      margin-top: 4px;
    }

    @keyframes logoPulse {

      0%,
      100% {
        text-shadow: 0 0 20px #ffd700aa, 4px 4px 0 #8b5e00, 8px 8px 0 #3a2500;
      }

      50% {
        text-shadow: 0 0 40px #ffd700, 4px 4px 0 #ffd700, 8px 8px 0 #8b5e00, 0 0 80px #ffd70066;
      }
    }

    @keyframes swordFloat {

      0%,
      100% {
        transform: translateY(0) rotate(-30deg);
      }

      50% {
        transform: translateY(-12px) rotate(-38deg);
      }
    }

    @keyframes blinkAnim {
      50% {
        opacity: 0;
      }
    }

    /* ====== GAME ====== */
    #game {
      position: fixed;
      inset: 0;
      display: none;
    }

    #gc {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* ====== HUD ====== */
    #hud {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 64px;
      z-index: 100;
      pointer-events: none;
      background: linear-gradient(180deg, rgba(2, 2, 10, 0.99) 0%, rgba(3, 3, 14, 0.92) 100%);
      border-bottom: 2px solid rgba(255, 215, 0, 0.35);
      box-shadow: 0 3px 0 rgba(255, 215, 0, 0.08), 0 6px 20px rgba(0, 0, 0, 0.9);
    }

    .hud-inner {
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: 100%;
      padding: 0 14px;
      gap: 8px;
    }

    .hud-block {
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .hud-label {
      font-size: clamp(5px, 1.5vw, 7px);
      color: rgba(255, 215, 0, 0.7);
      letter-spacing: 2px;
      text-transform: uppercase;
    }

    .hud-val {
      font-size: clamp(7px, 2vw, 11px);
      color: #ffd700;
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
    }

    .hearts-row {
      display: flex;
      gap: 3px;
      align-items: center;
      flex-wrap: wrap;
      max-width: 180px;
    }

    .heart-full {
      width: 16px;
      height: 16px;
      background: linear-gradient(135deg, #ff4444, #cc1111);
      border: 1.5px solid #ff6666;
      clip-path: polygon(50% 90%, 0% 35%, 15% 10%, 50% 25%, 85% 10%, 100% 35%);
      box-shadow: 0 0 8px rgba(255, 50, 50, 0.7), inset 0 1px 0 rgba(255, 180, 180, 0.3);
    }

    .heart-empty {
      width: 16px;
      height: 16px;
      background: #1c0808;
      border: 1.5px solid #441818;
      clip-path: polygon(50% 90%, 0% 35%, 15% 10%, 50% 25%, 85% 10%, 100% 35%);
    }

    .xp-bar-wrap {
      width: 90px;
      height: 6px;
      background: #080818;
      border: 1px solid rgba(40, 80, 200, 0.4);
      border-radius: 3px;
      overflow: hidden;
    }

    .xp-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #1166ff, #00eeff);
      transition: width .3s;
      border-radius: 3px;
      box-shadow: inset 0 0 6px rgba(0, 200, 255, 0.4);
    }

    .weapon-badge {
      font-size: clamp(5px, 1.5vw, 8px);
      color: #ffdd55;
      background: rgba(255, 200, 0, 0.07);
      border: 1px solid rgba(255, 215, 0, 0.25);
      padding: 3px 7px;
      text-shadow: 0 0 8px rgba(255, 200, 0, 0.4);
    }

    .hud-quest-text {
      font-size: clamp(5px, 1.4vw, 7.5px);
      color: #ccbbaa;
      max-width: 140px;
      line-height: 1.7;
      text-align: right;
    }

    .lvl-badge {
      font-size: clamp(6px, 1.6vw, 9px);
      color: #44ddff;
      text-shadow: 0 0 8px rgba(0, 200, 255, 0.6);
    }

    /* ====== BOSS HP BAR ====== */
    #boss-hud {
      position: fixed;
      top: 64px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
      width: min(400px, 88vw);
      display: none;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      padding: 7px 14px 8px;
      background: rgba(2, 2, 10, 0.97);
      border: 1.5px solid rgba(255, 60, 60, 0.4);
      border-top: none;
      box-shadow: 0 8px 28px rgba(255, 0, 0, 0.2), inset 0 -1px 0 rgba(255, 50, 50, 0.1);
    }

    #boss-hud-name {
      font-size: clamp(7px, 2vw, 11px);
      color: #ff9999;
      letter-spacing: 3px;
      text-align: center;
      text-shadow: 0 0 12px rgba(255, 60, 60, 0.5);
    }

    #boss-hp-wrap {
      width: 100%;
      height: 14px;
      background: #100000;
      border: 1px solid rgba(255, 50, 50, 0.2);
      border-radius: 2px;
      overflow: hidden;
      position: relative;
    }

    #boss-hp-fill {
      height: 100%;
      background: linear-gradient(90deg, #bb0000, #ff4400, #ff8800);
      transition: width .15s;
      border-radius: 2px;
      box-shadow: inset 0 2px 0 rgba(255, 200, 200, 0.2), 0 0 8px rgba(255, 60, 0, 0.4);
    }

    #boss-hp-wrap::after {
      content: '';
      position: absolute;
      inset: 0;
      background: repeating-linear-gradient(90deg, transparent, transparent 24px, rgba(0, 0, 0, 0.25) 24px, rgba(0, 0, 0, 0.25) 25px);
    }

    #boss-phase-wrap {
      width: 100%;
      display: flex;
      justify-content: center;
      gap: 8px;
      margin-top: 2px;
    }

    .boss-phase-pip {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #160000;
      border: 1.5px solid rgba(255, 50, 50, 0.3);
    }

    .boss-phase-pip.active {
      background: #ff2222;
      box-shadow: 0 0 10px #ff2222, 0 0 20px rgba(255, 0, 0, 0.4);
    }

    /* ====== MINIMAP ====== */
    #minimap-wrap {
      position: fixed;
      top: 80px;
      right: 10px;
      z-index: 90;
      background: rgba(2, 2, 10, 0.96);
      border: 2px solid rgba(255, 215, 0, 0.55);
      box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.9), 0 6px 20px rgba(0, 0, 0, 0.8),
        0 0 16px rgba(255, 215, 0, 0.1), inset 0 0 10px rgba(0, 0, 0, 0.5);
    }

    #minimap-wrap::before {
      content: 'CARTE';
      position: absolute;
      top: -16px;
      left: 0;
      right: 0;
      text-align: center;
      font-size: 7px;
      color: rgba(255, 215, 0, 0.8);
      letter-spacing: 3px;
      text-shadow: 0 0 8px rgba(255, 215, 0, 0.4);
    }

    #mmc {
      display: block;
      width: 110px;
      height: 74px;
    }

    /* ====== DIALOG ====== */
    #dialog {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      z-index: 200;
      display: none;
      background: linear-gradient(0deg, rgba(5, 5, 15, 0.99) 0%, rgba(8, 8, 25, 0.96) 100%);
      border-top: 2px solid #ffd70066;
      box-shadow: 0 -10px 40px rgba(0, 0, 0, 0.9);
    }

    .dlg-inner {
      display: grid;
      grid-template-columns: 64px 1fr;
      min-height: 80px;
      padding: 10px 14px 10px 0;
    }

    .dlg-portrait-wrap {
      display: flex;
      align-items: flex-start;
      justify-content: center;
    }

    .dlg-portrait-box {
      width: 50px;
      height: 50px;
      background: linear-gradient(135deg, #0d0d1a, #1a1a35);
      border: 2px solid #ffd70066;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      flex-shrink: 0;
    }

    .dlg-body {
      padding-left: 10px;
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .dlg-name {
      font-size: clamp(5px, 1.5vw, 7px);
      color: #ffd700;
      letter-spacing: 2px;
      border-bottom: 1px solid #ffd70022;
      padding-bottom: 3px;
      margin-bottom: 2px;
    }

    #dlg-text {
      font-family: 'VT323', monospace;
      font-size: clamp(16px, 4vw, 21px);
      color: #e8e0c0;
      line-height: 1.5;
      min-height: 40px;
    }

    .dlg-actions {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-top: 4px;
    }

    .dlg-continue {
      font-size: 7px;
      color: #ffd70088;
      animation: blinkAnim 0.8s step-end infinite;
    }

    .dlg-btn {
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(5px, 1.4vw, 7px);
      background: linear-gradient(180deg, #8b5e00, #4a3000);
      color: #ffd700;
      border: none;
      padding: 7px 14px;
      cursor: pointer;
      box-shadow: 0 0 0 1px #ffd70055, 2px 2px 0 #000;
      pointer-events: all;
    }

    .dlg-btn:active {
      transform: translate(1px, 1px);
    }

    /* ====== DEATH SCREEN ====== */
    #deathscreen {
      position: fixed;
      inset: 0;
      z-index: 270;
      display: none;
      background: rgba(80, 0, 0, 0.97);
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 16px;
    }

    .death-icon {
      font-size: 70px;
      animation: deathPulse 1.5s ease-in-out infinite;
    }

    .death-title {
      font-size: clamp(14px, 3.5vw, 28px);
      color: #ff4444;
      text-align: center;
      text-shadow: 3px 3px 0 #600, 0 0 40px #ff0000;
      line-height: 1.8;
    }

    .death-msg {
      font-family: 'VT323', monospace;
      font-size: clamp(16px, 4vw, 26px);
      color: #ff9988;
      text-align: center;
      max-width: 420px;
      padding: 0 20px;
      line-height: 1.7;
    }

    .death-btn {
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(9px, 2vw, 12px);
      background: linear-gradient(180deg, #cc2020, #8b0000);
      color: #fff;
      border: none;
      padding: 13px 26px;
      cursor: pointer;
      box-shadow: 0 0 0 2px #ff4444, 0 0 0 4px #000, 4px 4px 0 #000;
    }

    .death-btn:active {
      transform: translate(3px, 3px);
    }

    @keyframes deathPulse {

      0%,
      100% {
        transform: scale(1);
      }

      50% {
        transform: scale(1.12);
      }
    }

    /* ====== LEVEL TRANSITION ====== */
    #leveltrans {
      position: fixed;
      inset: 0;
      z-index: 250;
      display: none;
      background: rgba(0, 0, 0, 0.97);
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 14px;
    }

    .lt-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      text-align: center;
      padding: 0 20px;
    }

    .lt-icon {
      font-size: 56px;
      filter: drop-shadow(0 0 30px #ffd700);
    }

    .lt-title {
      font-size: clamp(11px, 3vw, 20px);
      color: #ffd700;
      text-shadow: 3px 3px 0 #8b5e00;
      line-height: 1.8;
    }

    .lt-zone {
      font-family: 'VT323', monospace;
      font-size: clamp(16px, 4vw, 26px);
      color: #e8d890;
    }

    .lt-reward {
      font-size: clamp(7px, 1.8vw, 10px);
      color: #88ccff;
      line-height: 2;
      background: rgba(0, 100, 200, 0.1);
      border: 1px solid #88ccff33;
      padding: 8px 16px;
    }

    .lt-next-btn {
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(8px, 2vw, 11px);
      background: linear-gradient(180deg, #c8a020, #8b5e00);
      color: #000;
      border: none;
      padding: 12px 24px;
      cursor: pointer;
      box-shadow: 0 0 0 2px #ffd700, 0 0 0 4px #000, 4px 4px 0 #000;
    }

    .lt-next-btn:active {
      transform: translate(3px, 3px);
    }

    /* ====== VICTORY ====== */
    #victory {
      position: fixed;
      inset: 0;
      z-index: 260;
      display: none;
      background: rgba(0, 0, 0, 0.97);
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
    }

    .vic-title {
      font-size: clamp(12px, 3.5vw, 24px);
      color: #ffd700;
      text-align: center;
      text-shadow: 3px 3px 0 #8b5e00;
      animation: logoPulse 2s infinite;
      line-height: 1.8;
    }

    .vic-msg {
      font-family: 'VT323', monospace;
      font-size: clamp(15px, 4vw, 26px);
      color: #e8d890;
      text-align: center;
      max-width: 500px;
      padding: 0 20px;
      line-height: 1.7;
    }

    .vic-btn {
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(8px, 2vw, 11px);
      background: linear-gradient(180deg, #c8a020, #8b5e00);
      color: #000;
      border: none;
      padding: 12px 22px;
      cursor: pointer;
      box-shadow: 0 0 0 2px #ffd700, 0 0 0 4px #000, 4px 4px 0 #000;
    }

    /* ====== PARTICLES ====== */
    .particle {
      position: fixed;
      pointer-events: none;
      z-index: 280;
      font-size: 20px;
      animation: particleFly var(--dur) ease-out forwards;
    }

    @keyframes particleFly {
      0% {
        opacity: 1;
        transform: translate(0, 0) scale(1) rotate(0deg);
      }

      100% {
        opacity: 0;
        transform: translate(var(--dx), var(--dy)) scale(0) rotate(var(--rot));
      }
    }

    /* ====== DAMAGE NUMBERS ====== */
    .dmg {
      position: fixed;
      pointer-events: none;
      z-index: 180;
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(8px, 2vw, 12px);
      animation: dmgAnim 0.85s ease-out forwards;
    }

    .dmg.heal {
      color: #44ff88;
      text-shadow: 0 0 8px #44ff88;
    }

    .dmg.crit {
      color: #ffff00;
      font-size: clamp(11px, 2.8vw, 17px);
      text-shadow: 0 0 12px #ffff00;
    }

    .dmg.normal {
      color: #ff4444;
      text-shadow: 0 0 8px #ff4444;
    }

    .dmg.ice {
      color: #88ccff;
      text-shadow: 0 0 8px #88ccff;
    }

    .dmg.fire {
      color: #ff8822;
      text-shadow: 0 0 8px #ff8822;
    }

    .dmg.spin {
      color: #cc44ff;
      text-shadow: 0 0 8px #cc44ff;
    }

    .dmg.boss {
      color: #ff0000;
      font-size: clamp(13px, 3.5vw, 20px);
      text-shadow: 0 0 15px #ff0000, 0 0 30px #ff000088;
    }

    @keyframes dmgAnim {
      0% {
        opacity: 1;
        transform: translateY(0) scale(1);
      }

      30% {
        opacity: 1;
        transform: translateY(-20px) scale(1.2);
      }

      100% {
        opacity: 0;
        transform: translateY(-65px) scale(0.6);
      }
    }

    /* ====== SCANLINES ====== */
    #scanlines {
      position: fixed;
      inset: 0;
      z-index: 500;
      pointer-events: none;
      background: repeating-linear-gradient(0deg, transparent, transparent 3px, rgba(0, 0, 0, 0.04) 3px, rgba(0, 0, 0, 0.04) 4px);
    }

    #atkflash {
      position: fixed;
      inset: 0;
      z-index: 170;
      pointer-events: none;
      opacity: 0;
      background: radial-gradient(ellipse at center, rgba(255, 255, 255, 0.25) 0%, transparent 70%);
      transition: opacity 0.1s;
    }

    /* ====== WARNING OVERLAY ====== */
    #warn-overlay {
      position: fixed;
      inset: 0;
      z-index: 165;
      pointer-events: none;
      opacity: 0;
      background: rgba(255, 0, 0, 0.08);
      border: 4px solid rgba(255, 0, 0, 0);
      transition: opacity 0.08s, border-color 0.08s;
    }

    /* ====== MOBILE CONTROLS ====== */
    /* Zone enti√®re ‚Äî fixe en bas, jamais superpos√©e au jeu */
    #mobilecontrols {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 180px;
      z-index: 96;
      pointer-events: none;
      display: none;
      background: linear-gradient(0deg, rgba(2, 2, 10, 0.26) 0%, rgba(2, 2, 10, 0.144) 65%, transparent 100%);
    }

    /* ‚îÄ‚îÄ JOYSTICK (moiti√© gauche) ‚îÄ‚îÄ */
    #joystick-col {
      position: absolute;
      left: 0;
      bottom: 0;
      width: 48%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: all;
    }

    #joystick-zone {
      width: 144px;
      height: 144px;
      position: relative;
      pointer-events: all;
    }

    #joystick-base {
      position: absolute;
      inset: 0;
      border-radius: 50%;
      background: rgba(255, 215, 0, 0.05);
      border: 2px solid rgba(255, 215, 0, 0.22);
      /* cercles concentriques d√©coratifs via box-shadow */
      box-shadow: inset 0 0 0 42px rgba(255, 215, 0, 0.03),
        inset 0 0 0 70px rgba(0, 0, 0, 0.1);
    }

    /* croix directionnelle subtile */
    #joystick-base::before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 50%;
      background:
        linear-gradient(rgba(255, 215, 0, 0.07) 0, rgba(255, 215, 0, 0.07) 100%) center/2px 70% no-repeat,
        linear-gradient(rgba(255, 215, 0, 0.07) 0, rgba(255, 215, 0, 0.07) 100%) center/70% 2px no-repeat;
    }

    #joystick-knob {
      position: absolute;
      width: 56px;
      height: 56px;
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: radial-gradient(circle at 38% 32%, rgba(255, 245, 150, 0.96), rgba(210, 140, 0, 0.88));
      border: 2.5px solid rgba(255, 215, 0, 1);
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.55), 0 4px 10px rgba(0, 0, 0, 0.7),
        inset 0 2px 5px rgba(255, 255, 200, 0.3);
    }

    /* ‚îÄ‚îÄ BARRE DE COMP√âTENCES (moiti√© droite) ‚îÄ‚îÄ */
    #skills-col {
      position: absolute;
      right: 0;
      bottom: 0;
      width: 52%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: all;
    }

    /* Disposition : 1 grand bouton ATK central + 3 skills en arc */
    #skills-layout {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding-bottom: 8px;
    }

    /* ‚îÄ Rang√©e haute : 3 skills ‚îÄ */
    #skills-top {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    /* ‚îÄ Rang√©e basse : ESQUIVE + (espace) + CHARGE ‚îÄ */
    #skills-bot {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    /* Bouton de skill g√©n√©rique */
    .sk {
      position: relative;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      background: rgba(10, 10, 26, 0.96);
      pointer-events: all;
      transition: transform 0.06s, filter 0.05s;
      -webkit-user-select: none;
      user-select: none;
      /* pas de font-size ici ‚Äî g√©r√© par .sk-ico */
    }

    .sk:active {
      transform: scale(0.82);
      filter: brightness(1.4);
    }

    .sk.cd {
      opacity: 0.45;
    }

    .sk-ico {
      font-size: 22px;
      line-height: 1;
      display: block;
      pointer-events: none;
      margin-bottom: 1px;
    }

    .sk-lbl {
      font-family: 'VT323', monospace;
      font-size: 10px;
      line-height: 1;
      pointer-events: none;
      letter-spacing: 0.3px;
    }

    /* Tailles */
    .sk.sm {
      width: 58px;
      height: 58px;
      border: 2px solid rgba(255, 215, 0, 0.3);
    }

    .sk.md {
      width: 64px;
      height: 64px;
      border: 2px solid rgba(255, 215, 0, 0.3);
    }

    /* Couleurs */
    #bsk-spin {
      border-color: rgba(180, 70, 255, 0.6);
    }

    #bsk-spin .sk-lbl {
      color: rgba(210, 130, 255, 0.9);
    }

    #bsk-proj {
      border-color: rgba(60, 170, 255, 0.6);
    }

    #bsk-proj .sk-lbl {
      color: rgba(120, 200, 255, 0.9);
    }

    #bsk-charge {
      border-color: rgba(255, 110, 30, 0.6);
    }

    #bsk-charge .sk-lbl {
      color: rgba(255, 160, 80, 0.9);
    }

    #bsk-dash {
      border-color: rgba(0, 225, 175, 0.65);
    }

    #bsk-dash .sk-lbl {
      color: rgba(0, 225, 175, 0.95);
    }

    #bsk-dash .sk-ico {
      font-size: 20px;
    }

    /* Anneau de cooldown conic */
    .sk-ring {
      position: absolute;
      inset: -3px;
      border-radius: 50%;
      pointer-events: none;
      background: conic-gradient(rgba(0, 0, 0, 0) var(--p, 0%), rgba(0, 0, 0, 0.78) var(--p, 0%));
      display: none;
    }

    .sk-ring.on {
      display: block;
    }

    /* Dash invincible */
    #bsk-dash.inv {
      border-color: rgba(0, 255, 200, 1);
      background: rgba(0, 170, 130, 0.22);
      animation: invGlow 0.36s ease-in-out infinite alternate;
    }

    @keyframes invGlow {
      from {
        box-shadow: 0 0 12px rgba(0, 255, 200, 0.5);
      }

      to {
        box-shadow: 0 0 28px rgba(0, 255, 200, 1), 0 0 55px rgba(0, 255, 200, 0.3);
      }
    }

    /* Overlay invincible plein √©cran */
    #invincible-overlay {
      position: fixed;
      inset: 0;
      z-index: 164;
      pointer-events: none;
      opacity: 0;
      background: radial-gradient(ellipse at center, rgba(0, 255, 200, 0.09) 0%, transparent 65%);
      border: 3px solid transparent;
      transition: opacity 0.08s;
    }

    #invincible-overlay.active {
      opacity: 1;
      border-color: rgba(0, 255, 200, 0.4);
      animation: invBorder 0.25s step-end infinite;
    }

    @keyframes invBorder {
      50% {
        border-color: transparent;
      }
    }
  </style>
</head>

<body>
  <div id="scanlines"></div>
  <div id="atkflash"></div>
  <div id="warn-overlay"></div>

  <!-- TITLE -->
  <div id="title">
    <canvas id="title-canvas"></canvas>
    <div class="title-content">
      <div class="title-sword">‚öîÔ∏è</div>
      <div class="title-logo">ANNIVERSAIRE<br>PAPA</div>
      <div class="title-tagline">‚Äî L√©gende du Royaume ‚Äî</div>
      <div class="title-features">
        Sauvez le royaume en incarnant un h√©ros d'exception !<br>
        Explorez des donjons p√©rilleux, affrontez des monstres redoutables,<br>
        Atteignez "l'√©toile" et confiez lui le voeu pour lequel vous vous √™tes battu durant ces 365 jours !<br>
        Bonne chance, H√©ro !
      </div>
      <button class="start-btn" onclick="startGame()">‚ñ∫ COMMENCER L'AVENTURE</button>
    </div>
  </div>

  <!-- GAME -->
  <div id="game"><canvas id="gc"></canvas></div>

  <!-- HUD -->
  <div id="hud" style="display:none">
    <div class="hud-inner">
      <div class="hud-block">
        <div class="hud-label">H√©ros</div>
        <div class="hud-val">üßô Papa</div>
        <div class="lvl-badge" id="hud-lvl">Niv. 1</div>
      </div>
      <div class="hud-block" style="align-items:center">
        <div class="hud-label">Vie</div>
        <div class="hearts-row" id="hearts"></div>
        <div class="xp-bar-wrap">
          <div class="xp-bar-fill" id="xpbar" style="width:0%"></div>
        </div>
      </div>
      <div class="hud-block" style="align-items:center">
        <div class="hud-label">Arme</div>
        <div class="weapon-badge" id="hud-weapon">‚öîÔ∏è √âp√©e</div>
      </div>
      <div class="hud-block" style="align-items:flex-end">
        <div class="hud-label" style="text-align:right">Qu√™te</div>
        <div class="hud-quest-text" id="hud-quest">Explore...</div>
      </div>
    </div>
  </div>

  <!-- BOSS HP BAR -->
  <div id="boss-hud">
    <div id="boss-hud-name">BOSS</div>
    <div id="boss-hp-wrap">
      <div id="boss-hp-fill" style="width:100%"></div>
    </div>
    <div id="boss-phase-wrap"></div>
  </div>

  <!-- MINIMAP -->
  <div id="minimap-wrap" style="display:none"><canvas id="mmc"></canvas></div>

  <div id="invincible-overlay"></div>

  <!-- MOBILE CONTROLS ‚Äî barre fixe en bas -->
  <div id="mobilecontrols">
    <!-- GAUCHE : Joystick directionnel -->
    <div id="joystick-col">
      <div id="joystick-zone">
        <div id="joystick-base"></div>
        <div id="joystick-knob"></div>
      </div>
    </div>

    <!-- DROITE : Barre de comp√©tences
       TOP :   üåÄ SPIN  |  üîÆ TIR  |  üõ°Ô∏è DASH
       BOT :   (vide)   |  üí• CHARG
  -->
    <div id="skills-col">
      <div id="skills-layout">
        <div id="skills-top">
          <button class="sk sm" id="bsk-spin">
            <span class="sk-ico">üåÄ</span><span class="sk-lbl">SPIN</span>
            <div class="sk-ring" id="ring-spin"></div>
          </button>
          <button class="sk sm" id="bsk-proj">
            <span class="sk-ico">üîÆ</span><span class="sk-lbl">TIR</span>
            <div class="sk-ring" id="ring-proj"></div>
          </button>
          <button class="sk sm" id="bsk-dash">
            <span class="sk-ico">üõ°Ô∏è</span><span class="sk-lbl">ESQUIVE</span>
            <div class="sk-ring" id="ring-dash"></div>
          </button>
        </div>
        <div id="skills-bot">
          <button class="sk md" id="bsk-charge">
            <span class="sk-ico">üí•</span><span class="sk-lbl">CHARGE</span>
            <div class="sk-ring" id="ring-charge"></div>
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- DIALOG -->
  <div id="dialog">
    <div class="dlg-inner">
      <div class="dlg-portrait-wrap">
        <div class="dlg-portrait-box" id="dlg-portrait">üßô</div>
      </div>
      <div class="dlg-body">
        <div class="dlg-name" id="dlg-name">???</div>
        <div id="dlg-text">...</div>
        <div class="dlg-actions">
          <div class="dlg-continue" id="dlg-cont">‚ñº Continuer</div>
          <button class="dlg-btn" id="dlg-btn" onclick="nextLine()" style="display:none">SUITE ‚ñ∂</button>
        </div>
      </div>
    </div>
  </div>

  <!-- DEATH SCREEN -->
  <div id="deathscreen">
    <div class="death-icon">üíÄ</div>
    <div class="death-title">GAME OVER</div>
    <div class="death-msg" id="death-msg">Le h√©ros est tomb√©...<br>Courage, on recommence !</div>
    <button class="death-btn" onclick="restartLevel()">‚Ü∫ RECOMMENCER</button>
  </div>

  <!-- LEVEL TRANSITION -->
  <div id="leveltrans">
    <div class="lt-content">
      <div class="lt-icon" id="lt-icon">üèÜ</div>
      <div class="lt-title" id="lt-title">NIVEAU ACCOMPLI !</div>
      <div class="lt-zone" id="lt-zone">‚Äî</div>
      <div class="lt-reward" id="lt-reward">R√©compense !</div>
      <button class="lt-next-btn" id="lt-btn" onclick="goNextLevel()">NIVEAU SUIVANT ‚ñ∫</button>
    </div>
  </div>

  <!-- VICTORY -->
  <div id="victory">
    <div style="font-size:clamp(50px,12vw,75px);filter:drop-shadow(0 0 30px #ffd700);animation:swordFloat 2s infinite">
      üåü</div>
    <div class="vic-title">QU√äTE ACCOMPLIE !<br>üéâ JOYEUX ANNIVERSAIRE ! üéâ</div>
    <div class="vic-msg">Papa,<br><br>
      Tu as travers√© la For√™t des Souvenirs,<br>
      Le Ch√¢teau des √âpreuves,<br>
      Et le Sommet de la Sagesse.<br><br>
      Comme dans la vie ‚Äî jamais tu n'as l√¢ch√©. ‚ù§Ô∏è<br><br>
      On t'aime. Merci d'√™tre notre h√©ros. üèÜ</div>
    <button class="vic-btn" onclick="fireworks()">üéÜ C√âL√âBRER !</button>
  </div>

  <script>
    'use strict';
    // ============================================================
    // AUDIO
    // ============================================================
    let actx;
    function ac() { if (!actx) actx = new (window.AudioContext || window.webkitAudioContext)(); if (actx.state === 'suspended') actx.resume(); return actx; }
    function note(f, d, tp = 'square', v = 0.07, dl = 0) {
      try {
        const c = ac(), o = c.createOscillator(), g = c.createGain();
        o.connect(g); g.connect(c.destination); o.type = tp; o.frequency.value = f;
        g.gain.setValueAtTime(0, c.currentTime + dl);
        g.gain.linearRampToValueAtTime(v, c.currentTime + dl + 0.01);
        g.gain.linearRampToValueAtTime(0, c.currentTime + dl + d);
        o.start(c.currentTime + dl); o.stop(c.currentTime + dl + d + 0.1);
      } catch (e) { }
    }
    function seq(ns) { let t = 0; ns.forEach(([f, d]) => { if (f > 0) note(f, d * .85, 'square', 0.065, t); t += d; }); }
    function sHit() { note(180, 0.07, 'sawtooth', 0.09); }
    function sSwing() { note(440, 0.05, 'square', 0.07); note(330, 0.05, 'square', 0.04, 0.06); }
    function sDie() { seq([[220, 0.1], [165, 0.1], [110, 0.2]]); }
    function sPick() { seq([[784, 0.07], [1047, 0.10], [1319, 0.16]]); }
    function sLvlUp() { seq([[523, 0.09], [659, 0.09], [784, 0.09], [1047, 0.20], [1319, 0.32]]); }
    function sBeep() { if (Math.random() < 0.35) note(880, 0.022, 'square', 0.018); }
    function sWalk() { if (Math.random() < 0.15) note(165 + Math.random() * 20, 0.03, 'square', 0.014); }
    function sDmg() { note(85, 0.14, 'sawtooth', 0.14); }
    function sSpin() { note(600, 0.04, 'sawtooth', 0.07); note(500, 0.04, 'sawtooth', 0.055, 0.055); note(400, 0.09, 'sawtooth', 0.045, 0.11); }
    function sProj() { note(800, 0.04, 'square', 0.07); note(1000, 0.09, 'square', 0.055, 0.04); }
    function sCharge() { note(200, 0.04, 'sawtooth', 0.09); note(300, 0.04, 'sawtooth', 0.09, 0.04); note(500, 0.18, 'sawtooth', 0.11, 0.09); }
    function sDeath() { seq([[200, 0.15], [160, 0.15], [120, 0.2], [80, 0.4]]); }
    function sVic() { seq([[523, 0.14], [523, 0.14], [523, 0.14], [415, 0.09], [523, 0.38], [784, 0.14], [784, 0.14], [784, 0.14], [698, 0.09], [784, 0.38], [1047, 0.09], [988, 0.09], [932, 0.09], [880, 0.09], [1047, 0.48]]); }
    function sBossDash() { note(1200, 0.06, 'sawtooth', 0.18); note(200, 0.12, 'sawtooth', 0.2, 0.04); }
    function sBossBeam() { note(300, 0.05, 'sawtooth', 0.15); note(400, 0.05, 'sawtooth', 0.12, 0.05); note(1800, 0.4, 'sine', 0.07, 0.08); }
    function sBossWave() { note(100, 0.2, 'sawtooth', 0.18); note(150, 0.2, 'sawtooth', 0.15, 0.1); }
    function sBossSpawn() { seq([[440, 0.08], [350, 0.08], [280, 0.08], [200, 0.15]]); }
    function sBossRage() { note(80, 0.3, 'sawtooth', 0.25); note(120, 0.3, 'sawtooth', 0.2, 0.15); note(60, 0.5, 'sawtooth', 0.28, 0.3); }

    // ============================================================
    // CANVAS
    // ============================================================
    const canvas = document.getElementById('gc');
    const C = canvas.getContext('2d');
    const mm = document.getElementById('mmc');
    const MC = mm.getContext('2d');
    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; mm.width = 110; mm.height = 74; }
    window.addEventListener('resize', resize); resize();
    const tc = document.getElementById('title-canvas');
    const TC = tc.getContext('2d');
    function resizeTitle() { tc.width = window.innerWidth; tc.height = window.innerHeight; }
    window.addEventListener('resize', resizeTitle); resizeTitle();

    // ============================================================
    // NOISE
    // ============================================================
    function smoothNoise(x, y) {
      const ix = Math.floor(x), iy = Math.floor(y);
      const fx = x - ix, fy = y - iy;
      const u = fx * fx * (3 - 2 * fx), v = fy * fy * (3 - 2 * fy);
      const h = (a, b) => Math.abs(Math.sin(a * 127.1 + b * 311.7) * 43758.5453) % 1;
      return h(ix, iy) * (1 - u) * (1 - v) + h(ix + 1, iy) * u * (1 - v) + h(ix, iy + 1) * (1 - u) * v + h(ix + 1, iy + 1) * u * v;
    }
    function fbm(x, y, oct = 4) {
      let v = 0, amp = 1, freq = 1, max = 0;
      for (let i = 0; i < oct; i++) { v += smoothNoise(x * freq, y * freq) * amp; max += amp; amp *= 0.5; freq *= 2; }
      return v / max;
    }

    // ============================================================
    // TILES
    // ============================================================
    const TSIZ = 32;
    const tileCache = new Map();
    const TB = {
      GRASS: 0, PATH: 1, WATER: 2, ROCK: 3, TREE: 4, FLOWER: 5, MUSHROOM: 6,
      FLOOR: 7, WALL: 8, SNOW: 9, ICE: 10, LAVA: 11, DARK: 12, BRIDGE: 13, TALL_GRASS: 14,
      HILL: 15, SAND: 16, MOSS: 17
    };
    const BLOCK = { 2: true, 3: true, 4: true, 8: true, 11: true };
    const PASSABLE = t => !BLOCK[t];
    function buildTile(id, frame = 0) {
      const key = `${id}_${frame % 4}`;
      if (tileCache.has(key)) return tileCache.get(key);
      const off = new OffscreenCanvas(TSIZ, TSIZ);
      drawTileTexture(off.getContext('2d'), id, frame);
      tileCache.set(key, off); return off;
    }
    function rand(a, b, c) { return Math.abs(Math.sin(a + b * 127.1 + c * 311.7) * 43758.5453) % 1; }
    function drawTileTexture(cx, id, f) {
      cx.clearRect(0, 0, TSIZ, TSIZ); const T = TSIZ;
      switch (id) {
        case TB.GRASS: { cx.fillStyle = '#2a7a2a'; cx.fillRect(0, 0, T, T);['#2e8834', '#267326', '#1e7025', '#338a33', '#3a9a3a'].forEach((c, i) => { cx.fillStyle = c; cx.fillRect(rand(i * 7, f, i) * T | 0, rand(i * 11, f, i) * T | 0, 3 + (i % 2), 2 + (i % 2)); }); cx.strokeStyle = '#4ab04a'; cx.lineWidth = 1; for (let i = 0; i < 7; i++) { const x = rand(i * 17, f, i) * T, y = rand(i * 23, f, i) * T; cx.beginPath(); cx.moveTo(x, y + 3); cx.lineTo(x + Math.sin(f * 0.08) * 1.5, y - 3); cx.stroke(); } break; }
        case TB.PATH: { cx.fillStyle = '#a07830'; cx.fillRect(0, 0, T, T);['#b08040', '#906820', '#c09040', '#8a6018'].forEach((c, i) => { cx.fillStyle = c; cx.fillRect(rand(i * 3, f, 1) * T | 0, rand(i * 7, 2, i) * T | 0, 2 + (i % 3), 2 + (i % 2)); }); break; }
        case TB.WATER: { cx.fillStyle = '#0d3a6e'; cx.fillRect(0, 0, T, T); for (let w = 0; w < 4; w++) { const y = 4 + w * 7 + Math.sin(f * 0.05 + w * 1.2) * 2; cx.fillStyle = `rgba(80,160,255,${0.12 + w * 0.06})`; cx.beginPath(); cx.moveTo(0, y); for (let x = 0; x <= T; x += 3)cx.lineTo(x, y + Math.sin((x + f * 2) * 0.3 + w) * 2.5); cx.lineTo(T, y + 8); cx.lineTo(0, y + 8); cx.closePath(); cx.fill(); } break; }
        case TB.ROCK: { cx.fillStyle = '#4a4a55'; cx.fillRect(0, 0, T, T); cx.fillStyle = '#6a6a78'; cx.fillRect(3, 3, 26, 23); cx.fillStyle = '#7a7a88'; cx.fillRect(5, 5, 14, 12); cx.fillStyle = 'rgba(255,255,255,0.14)'; cx.fillRect(5, 5, 8, 3); break; }
        case TB.TREE: { cx.fillStyle = '#12280e'; cx.fillRect(0, 0, T, T); cx.fillStyle = '#1a4015'; cx.fillRect(4, 3, 24, 22); cx.fillStyle = '#257830'; cx.fillRect(7, 5, 18, 16); cx.fillStyle = '#4a2e10'; cx.fillRect(13, 21, 6, 11); break; }
        case TB.FLOWER: { cx.fillStyle = '#2a7a2a'; cx.fillRect(0, 0, T, T); const fp = [[7, 22], [19, 17], [14, 27], [25, 21]]; fp.forEach(([x, y], i) => { cx.fillStyle = ['#ff6688', '#ffcc44', '#ff88aa', '#cc66ff'][i]; for (let p2 = 0; p2 < 5; p2++) { const a = p2 / 5 * 6.28; cx.beginPath(); cx.arc(x + Math.cos(a) * 2.5, y - 8 + Math.sin(a) * 2.5, 2, 0, 6.28); cx.fill(); } }); break; }
        case TB.MUSHROOM: { cx.fillStyle = '#1e5a2a'; cx.fillRect(0, 0, T, T);[[8, 25], [20, 21], [26, 27]].forEach(([x, y]) => { cx.fillStyle = '#bb3333'; cx.beginPath(); cx.arc(x, y - 5, 5, Math.PI, 0); cx.fill(); cx.fillStyle = '#e8d0b0'; cx.fillRect(x - 2, y - 5, 4, 6); }); break; }
        case TB.FLOOR: { cx.fillStyle = '#252440'; cx.fillRect(0, 0, T, T); const g2 = T / 2; cx.fillStyle = '#2e2d50'; cx.fillRect(0, 0, g2 - 1, g2 - 1); cx.fillRect(g2 + 1, g2 + 1, g2 - 1, g2 - 1); cx.fillStyle = '#1e1d3a'; cx.fillRect(g2 + 1, 0, g2 - 1, g2 - 1); cx.fillRect(0, g2 + 1, g2 - 1, g2 - 1); cx.fillStyle = '#14132a'; cx.fillRect(0, g2, T, 2); cx.fillRect(g2, 0, 2, T); break; }
        case TB.WALL: { cx.fillStyle = '#16163a'; cx.fillRect(0, 0, T, T); cx.fillStyle = '#22224a'; cx.fillRect(2, 2, 12, 9); cx.fillRect(18, 2, 12, 9); cx.fillStyle = '#2a2a58'; cx.fillRect(10, 13, 16, 9); cx.fillRect(2, 22, 8, 8); cx.fillRect(22, 22, 8, 8); cx.fillStyle = '#0a0a20'; cx.fillRect(0, 0, T, 2); cx.fillRect(0, 11, T, 2); cx.fillRect(0, 22, T, 2); break; }
        case TB.SNOW: { cx.fillStyle = '#d0e8f8'; cx.fillRect(0, 0, T, T); for (let i = 0; i < 8; i++) { cx.fillStyle = i % 2 ? 'rgba(255,255,255,0.45)' : 'rgba(180,200,220,0.3)'; cx.fillRect(rand(i * 5, 1, f) * T | 0, rand(i * 11, f, 2) * T | 0, 4 + i % 3, 2 + i % 3); } break; }
        case TB.ICE: { cx.fillStyle = '#7aaac8'; cx.fillRect(0, 0, T, T); cx.fillStyle = 'rgba(220,240,255,0.42)'; cx.fillRect(2, 2, 22, 5); cx.fillRect(5, 11, 12, 3); cx.fillStyle = 'rgba(255,255,255,0.55)'; cx.fillRect(3, 3, 10, 2); break; }
        case TB.LAVA: { cx.fillStyle = '#380e00'; cx.fillRect(0, 0, T, T); for (let i = 0; i < 3; i++) { const y = 5 + i * 9 + Math.sin(f * 0.06 + i * 1.8) * 2.5; cx.fillStyle = `rgba(${175 - i * 28},${55 - i * 10},0,0.75)`; cx.beginPath(); cx.moveTo(0, y); for (let x = 0; x <= T; x += 3)cx.lineTo(x, y + Math.sin((x + f * 3) * 0.4 + i) * 3.5); cx.lineTo(T, y + 9); cx.lineTo(0, y + 9); cx.closePath(); cx.fill(); } break; }
        case TB.DARK: { cx.fillStyle = '#090914'; cx.fillRect(0, 0, T, T); cx.fillStyle = 'rgba(25,25,55,0.5)'; cx.fillRect(3, 3, T - 6, T - 6); break; }
        case TB.BRIDGE: { cx.fillStyle = '#0c3a6a'; cx.fillRect(0, 0, T, T);['#8b5e2a', '#a06830', '#7a5020', '#9a6828'].forEach((c, i) => { const y = 4 + i * 7; cx.fillStyle = c; cx.fillRect(1, y, T - 2, 6); }); break; }
        case TB.TALL_GRASS: { cx.fillStyle = '#2a7a2a'; cx.fillRect(0, 0, T, T); cx.strokeStyle = '#44b044'; cx.lineWidth = 1.5; for (let i = 0; i < 10; i++) { const x = 3 + i * 2.8, h = 9 + Math.sin(i * 2.3) * 3, sw = Math.sin(f * 0.04 + i * 0.7) * 2; cx.beginPath(); cx.moveTo(x, T - 2); cx.quadraticCurveTo(x + sw, T - h * 0.5, x + sw * 1.5, T - h); cx.stroke(); } break; }
        case TB.HILL: { cx.fillStyle = '#3a8c30'; cx.fillRect(0, 0, T, T); const hg = cx.createLinearGradient(0, 0, 0, T); hg.addColorStop(0, 'rgba(120,200,80,0.28)'); hg.addColorStop(1, 'rgba(0,0,0,0.22)'); cx.fillStyle = hg; cx.fillRect(0, 0, T, T); break; }
        case TB.SAND: { cx.fillStyle = '#c8a060'; cx.fillRect(0, 0, T, T);['#d4aa70', '#b89050', '#dcb878', '#c8a458'].forEach((c, i) => { cx.fillStyle = c; cx.fillRect(rand(i * 3, f, 1) * T | 0, rand(i * 7, 2, i) * T | 0, 2 + i % 3, 1 + i % 2); }); break; }
        case TB.MOSS: { cx.fillStyle = '#1e5a2a'; cx.fillRect(0, 0, T, T); for (let i = 0; i < 14; i++) { cx.fillStyle = i % 3 === 0 ? '#2a7a30' : i % 3 === 1 ? '#163820' : '#3a8a3a'; cx.beginPath(); cx.arc(rand(i * 5, f, i) * T, rand(i * 9, i, f) * T, 2 + rand(i, f, i) * 3, 0, 6.28); cx.fill(); } break; }
      }
    }
    const ANIM_TILES = [TB.WATER, TB.LAVA, TB.TALL_GRASS];
    let tileFrame = 0;
    setInterval(() => { tileFrame++; ANIM_TILES.forEach(id => { for (let f = 0; f < 4; f++)tileCache.delete(`${id}_${f}`); }); }, 120);

    // ============================================================
    // WORLD CONSTANTS
    // ============================================================
    const COLS = 80, ROWS = 60, WW = COLS * TSIZ, WH = ROWS * TSIZ;

    // ============================================================
    // LEVELS DATA
    // ============================================================
    const LEVELS = [{
      name: ["La For√™t des Souvenirs", "brrr...", "Un frisson vous traverse", "une pr√©sence sinistre du nord semble vous en vouloir..."], biome: "forest",
      quest: "Retrouve 3 M√©daillons", questCount: 3, questType: "collect", questItem: "ü•á",
      questMsgs: [
        ["ü•á", "M√âDAILLON", "Un m√©daillon en or... rappelant des moments pass√©s √† tes c√¥t√©s.", "Ces moments du quotidien ‚Äî les repas, les rires, les balades...", "Ce sont les tr√©sors les plus pr√©cieux.", "Vous r√©cup√©rez le m√©daillon"],
        ["ü•á", "M√âDAILLON", "Un... m√©daillon ?", " Il semble repr√©senter la patience.", "Elle est d√©sormais votre, une patience √† toutes √©preuves", "Peut √™tre au final, que vous l'avez toujours √©t√©", "Vous r√©cup√©rez le m√©daillon de sagesse"],
        ["ü•á", "M√âDAILLON", "Un m√©daillon brille d'or pur.", "Une vision vous assaillit.","Une famille... aimante... est-ce la votre", "M√©daillon de Famille r√©cup√©r√© !"]
      ],
      bossName: "Seigneur Oubli", bossIcon: "üëπ", bossHP: 40, bossPhases: 2,
      bossPatterns: ['slash', 'poison_ring', 'enrage'],
      bossDialog: ["Je suis le Vorgath le Br√ªl√© ! D√©voreur de souvenir !", "Je ne peux pas perdre la vie de cette fa√ßon !!!", "(Un cri strident retenti)", "BOSS VAINCU ! ‚öîÔ∏è √âp√©e de Vorgath d√©bloqu√©e !"],
      weapon: "‚öîÔ∏è √âp√©e de Vorgath le Br√ªl√©", wPow: 3,
      reward: "‚öîÔ∏è √âp√©e de Vorgath le Br√ªl√© ! +50 XP", rewardIcon: "‚öîÔ∏è", bgA: '#0d1f0d'
    }, {
      name: "Le Ch√¢teau des √âpreuves", biome: "castle",
      quest: "Vaincs 5 Gardiens", questCount: 5, questType: "kill", questItem: "üíÄ",
      questMsgs: [
        ["üíÄ", "GARDIEN VAINCU", "Un gardien vaincu. üìú 1/5"],
        ["üíÄ", "GARDIEN VAINCU", "Deux de moins ! üìú 2/5", "Est-ce la preuve d'une force infini ?"],
        ["üíÄ", "GARDIEN VAINCU", "La moiti√© du chemin. üìú 3/5", "ou peut-√™tre une pers√©v√©rance sans nom."],
        ["üíÄ", "GARDIEN VAINCU", "Presque l√† ! üìú 4/5", "..."],
        ["üíÄ", "TOUS VAINCUS !", "D√©sormais votre force n'a plus de doute.","Un grincement se fait entendre... Vos sens sont en alerte", "Un nom apparait dans votre esprit", "Nytherion, le Revenant..."]
      ],
      bossName: "Nytherion, le Revenant", bossIcon: "üëë", bossHP: 60, bossPhases: 3,
      bossSpeed: 0.42, bossAggroR: 280, bossWarnR: 380,
      bossPatterns: ['teleport_strike', 'shadow_wave', 'death_beam', 'enrage'],
      bossDialog: ["Je suis Nytherion, le Revenant !", "Moi ? Vaincu par un simple voyageur...", "Toi... Qui ne doutes plus... D'OU SORT TU CETTE ASSURANCE ?!", "La lumi√®re fantomatique se tarit dans un sifflement l√©ger, et vous vous sentez plus l√©ger", "BOSS VAINCU ! üîÆ B√¢ton de Nytherion d√©bloqu√© !"],
      weapon: "üîÆ B√¢ton de Nytherion", wPow: 6,
      reward: "üîÆ B√¢ton de Nytherion ! +100 XP", rewardIcon: "üîÆ", bgA: '#0d0d22'
    }, {
      name: "Le Sommet de la Sagesse", biome: "mountain",
      quest: ["Atteins l'√âtoile Finale, au sommet de la montagne", "Une pr√©sence pesante vous glace le sang..."], questCount: 1, questType: "collect", questItem: "‚≠ê",
      questMsgs: [["‚≠ê", "L'√âTOILE FINALE", "Vous l'avez donc trouv√©e... l'\"√âtoile\"", "Elle brille pour vous depuis les t√©n√®bres de l'univers.", "Vous sentez une √©nergie puissante vous envahir", "et une voix r√©sonne dans votre esprit :", "\"Tu as fait du chemin pour venir jusqu'ici... mais tu n'es pas encore arriv√©.\"", "Vous faites un voeu...", "Une ann√©e de combat, de pers√©v√©rance, de courage...", "L'√©toile vous octroie le fruit de votre d√©sir."]],
      bossName: "Thyrax, le Souffle Noir", bossIcon: "üêâ", bossHP: 100, bossPhases: 3,
      bossPatterns: ['fireball_burst', 'aerial_slam', 'time_stop', 'meteor', 'dash_slam', 'enrage'],
      bossDialog: ["Je suis Thyrax le Grand ! Les ann√©es passent, personne ne m'arr√™te !", "PERSONNE N'ETAIT CENSE DEROGER CET ORDRE", "\"vous avez mis fin au r√®gne temporel de Thyrax.\"", "üêâ DRAGON VAINCU ! ‚≠ê √âtoile de Sagesse ! VICTOIRE !"],
      weapon: "‚≠ê √âtoile de Sagesse", wPow: 10,
      reward: "‚≠ê √âtoile de Sagesse ! +200 XP", rewardIcon: "‚≠ê", bgA: '#080812'
    }];

    // ============================================================
    // MONSTERS
    // ============================================================
    const MONS = {
      forest: [{ icon: 'üê∫', name: 'Loup', hp: 4, maxHp: 4, spd: 1.1, dmg: 1, xp: 10, r: 13 },
      { icon: 'üï∑Ô∏è', name: 'Araign√©e', hp: 2, maxHp: 2, spd: 1.6, dmg: 1, xp: 8, r: 11 },
      { icon: 'ü¶á', name: 'Chauve-souris', hp: 2, maxHp: 2, spd: 2.0, dmg: 1, xp: 12, r: 11 },
      { icon: 'üåø', name: 'Entit√©', hp: 6, maxHp: 6, spd: 0.7, dmg: 2, xp: 15, r: 13 }],
      castle: [{ icon: 'üíÄ', name: 'Squelette', hp: 7, maxHp: 7, spd: 0.8, dmg: 2, xp: 20, r: 13 },
      { icon: 'üßü', name: 'Zombie', hp: 12, maxHp: 12, spd: 0.45, dmg: 2, xp: 28, r: 15 },
      { icon: 'üëª', name: 'Fant√¥me', hp: 4, maxHp: 4, spd: 2.2, dmg: 2, xp: 18, r: 11 },
      { icon: 'ü™ñ', name: 'Chevalier', hp: 10, maxHp: 10, spd: 1.0, dmg: 3, xp: 30, r: 14 }],
      mountain: [{ icon: 'üßä', name: 'G√©ant de Glace', hp: 16, maxHp: 16, spd: 0.38, dmg: 4, xp: 40, r: 17 },
      { icon: 'ü¶Ö', name: 'Griffon', hp: 8, maxHp: 8, spd: 1.6, dmg: 3, xp: 32, r: 13 },
      { icon: 'ü™®', name: 'Golem', hp: 20, maxHp: 20, spd: 0.28, dmg: 5, xp: 50, r: 18 },
      { icon: 'üå®Ô∏è', name: '√âl√©mental', hp: 11, maxHp: 11, spd: 1.3, dmg: 3, xp: 38, r: 13 }]
    };

    // ============================================================
    // MAP GENERATION HELPERS
    // ============================================================
    function fillR(map, r0, c0, r1, c1, t) { for (let r = r0; r < r1; r++)for (let c = c0; c < c1; c++)if (r >= 0 && r < ROWS && c >= 0 && c < COLS) map[r][c] = t; }
    function fillE(map, cr, cc, rr, rc, t) { for (let r = Math.max(0, cr - rr); r <= Math.min(ROWS - 1, cr + rr); r++)for (let c = Math.max(0, cc - rc); c <= Math.min(COLS - 1, cc + rc); c++) { const dr = (r - cr) / rr, dc = (c - cc) / rc; if (dr * dr + dc * dc <= 1) map[r][c] = t; } }
    function carveLine(map, r0, c0, r1, c1, t) { const dr = Math.abs(r1 - r0), dc = Math.abs(c1 - c0); const sr = r0 < r1 ? 1 : -1, sc = c0 < c1 ? 1 : -1; let err = dr - dc, r = r0, c = c0; for (; ;) { if (r >= 0 && r < ROWS && c >= 0 && c < COLS) map[r][c] = t; if (r === r1 && c === c1) break; const e2 = 2 * err; if (e2 > -dc) { err -= dc; r += sr; } if (e2 < dr) { err += dr; c += sc; } } }
    function carveT(map, r0, c0, r1, c1, t, w = 1) { for (let dr = -w; dr <= w; dr++)for (let dc = -w; dc <= w; dc++)carveLine(map, r0 + dr, c0 + dc, r1 + dr, c1 + dc, t); }
    function ri(lo, hi) { return lo + Math.floor(Math.random() * (hi - lo + 1)); }
    function bfsPassable(map, startR, startC, limit = 2000) {
      const visited = new Set(); const queue = [[startR, startC]];
      const key = (r, c) => r * COLS + c; visited.add(key(startR, startC)); const cells = [];
      while (queue.length && cells.length < limit) {
        const [r, c] = queue.shift(); if (PASSABLE(map[r][c])) cells.push([r, c]);
        for (const [dr, dc] of [[-1, 0], [1, 0], [0, -1], [0, 1]]) {
          const nr = r + dr, nc = c + dc;
          if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) continue; const k = key(nr, nc);
          if (!visited.has(k) && PASSABLE(map[nr][nc])) { visited.add(k); queue.push([nr, nc]); }
        }
      }
      return cells;
    }
    function safeSpawnCell(cells, avoidX, avoidY, minDist = 80) {
      const far = cells.filter(([r, c]) => { const wx = c * TSIZ + TSIZ / 2, wy = r * TSIZ + TSIZ / 2; return Math.hypot(wx - avoidX, wy - avoidY) > minDist; });
      const pool = far.length > 0 ? far : cells; if (!pool.length) return null;
      const [r, c] = pool[Math.floor(Math.random() * pool.length)]; return { x: c * TSIZ + TSIZ / 2, y: r * TSIZ + TSIZ / 2 };
    }
    function ensurePassable(map, wx, wy) {
      const c0 = Math.floor(wx / TSIZ), r0 = Math.floor(wy / TSIZ);
      if (r0 >= 0 && r0 < ROWS && c0 >= 0 && c0 < COLS && PASSABLE(map[r0][c0])) return { x: wx, y: wy };
      for (let d = 1; d < 10; d++)for (let dr = -d; dr <= d; dr++)for (let dc = -d; dc <= d; dc++) {
        const r = r0 + dr, c = c0 + dc; if (r >= 0 && r < ROWS && c >= 0 && c < COLS && PASSABLE(map[r][c])) return { x: c * TSIZ + TSIZ / 2, y: r * TSIZ + TSIZ / 2 };
      }
      return { x: wx, y: wy };
    }
    function genMap(biome) {
      const seed = Math.random() * 1000;
      const base = biome === 'castle' ? TB.FLOOR : biome === 'mountain' ? TB.SNOW : TB.GRASS;
      const wall = biome === 'castle' ? TB.WALL : biome === 'mountain' ? TB.ROCK : TB.TREE;
      const map = [];
      for (let r = 0; r < ROWS; r++) { map[r] = []; for (let c = 0; c < COLS; c++)map[r][c] = base; }
      fillR(map, 0, 0, 3, COLS, wall); fillR(map, ROWS - 3, 0, ROWS, COLS, wall);
      fillR(map, 0, 0, ROWS, 3, wall); fillR(map, 0, COLS - 3, ROWS, COLS, wall);
      let startPos, bossPos, questPos;
      if (biome === 'forest') {
        for (let r = 3; r < ROWS - 3; r++)for (let c = 3; c < COLS - 3; c++) {
          const n = fbm(c * 0.08 + seed * 0.1, r * 0.08 + seed * 0.1), n2 = fbm(c * 0.15 + 50 + seed * 0.05, r * 0.15 + 50 + seed * 0.05), n3 = fbm(c * 0.05 + 100, r * 0.05 + 100);
          if (n > 0.63) map[r][c] = TB.TREE; else if (n > 0.56 && n2 > 0.55) map[r][c] = TB.MUSHROOM;
          else if (n < 0.35 && n2 < 0.4) map[r][c] = TB.MOSS; else if (n3 > 0.66 && n < 0.5) map[r][c] = TB.HILL;
          else if (n2 > 0.68 && n < 0.52) map[r][c] = TB.FLOWER; else if (n < 0.43 && n2 > 0.5 && n3 < 0.5) map[r][c] = TB.TALL_GRASS;
        }
        const lakeR = ri(28, 36), lakeC = ri(28, 50), lakeRR = ri(5, 8), lakeRC = ri(8, 14);
        fillE(map, lakeR, lakeC, lakeRR + 2, lakeRC + 2, TB.SAND); fillE(map, lakeR, lakeC, lakeRR, lakeRC, TB.WATER);
        const startC = ri(35, 45), startR = ROWS - 5;
        const mid1R = lakeR + lakeRR + 3, mid1C = lakeC, mid2R = lakeR - lakeRR - 3;
        const topR = 5, topC = ri(30, 50), bridgeC = lakeC + ri(-3, 3);
        carveT(map, startR, startC, mid1R, startC, TB.PATH, 1); carveT(map, mid1R, startC, mid1R, mid1C, TB.PATH, 1);
        for (let r = lakeR - lakeRR - 1; r <= lakeR + lakeRR + 1; r++)for (let dc = -1; dc <= 1; dc++) { const cc = bridgeC + dc; if (r >= 0 && r < ROWS && cc >= 0 && cc < COLS) map[r][cc] = map[r][cc] === TB.WATER ? TB.BRIDGE : TB.PATH; }
        carveT(map, mid1R, mid1C, lakeR + lakeRR + 1, bridgeC, TB.PATH, 1); carveT(map, lakeR - lakeRR - 1, bridgeC, mid2R, bridgeC, TB.PATH, 1);
        carveT(map, mid2R, bridgeC, topR, bridgeC, TB.PATH, 1); carveT(map, topR, bridgeC, topR, topC, TB.PATH, 1);
        startPos = ensurePassable(map, startC * TSIZ + TSIZ / 2, (startR - 1) * TSIZ + TSIZ / 2);
        bossPos = ensurePassable(map, topC * TSIZ + TSIZ / 2, (topR + 1) * TSIZ + TSIZ / 2);
        const cells = bfsPassable(map, startR - 1, startC);
        questPos = [safeSpawnCell(cells, startPos.x, startPos.y, 200) || { x: 18 * TSIZ, y: 40 * TSIZ },
        safeSpawnCell(cells, startPos.x, startPos.y, 150) || { x: 60 * TSIZ, y: 35 * TSIZ },
        safeSpawnCell(cells, bossPos.x, bossPos.y, 200) || { x: mid1C * TSIZ, y: mid2R * TSIZ }].map(p => ({ ...p, collected: false }));
      } else if (biome === 'castle') {
        fillR(map, 3, 3, ROWS - 3, COLS - 3, TB.FLOOR);
        fillR(map, 3, 3, 8, COLS - 3, TB.WALL); fillR(map, ROWS - 8, 3, ROWS - 3, COLS - 3, TB.WALL);
        fillR(map, 3, 3, ROWS - 3, 8, TB.WALL); fillR(map, 3, COLS - 8, ROWS - 3, COLS - 3, TB.WALL);
        const rms = [{ r0: 8, c0: 8, r1: 22, c1: 28 }, { r0: 8, c0: 32, r1: 22, c1: 52 }, { r0: 8, c0: 56, r1: 22, c1: 72 },
        { r0: 24, c0: 8, r1: 38, c1: 28 }, { r0: 24, c0: 32, r1: 38, c1: 52 }, { r0: 24, c0: 56, r1: 38, c1: 72 },
        { r0: 40, c0: 8, r1: 55, c1: 28 }, { r0: 40, c0: 32, r1: 55, c1: 52 }, { r0: 40, c0: 56, r1: 55, c1: 72 }];
        for (const rm of rms) { fillR(map, rm.r0, rm.c0, rm.r1, rm.c1, TB.WALL); fillR(map, rm.r0 + 2, rm.c0 + 2, rm.r1 - 2, rm.c1 - 2, TB.FLOOR); fillR(map, rm.r0 + 2, rm.c0 + 2, rm.r0 + 4, rm.c0 + 4, TB.DARK); }
        const cors = [{ r: 15, c0: 28, c1: 32 }, { r: 15, c0: 52, c1: 56 }, { r: 31, c0: 28, c1: 32 }, { r: 31, c0: 52, c1: 56 }, { r: 47, c0: 28, c1: 32 }, { r: 47, c0: 52, c1: 56 }];
        for (const co of cors) fillR(map, co.r - 1, co.c0, co.r + 2, co.c1, TB.FLOOR);
        const eC = 42;
        carveT(map, ROWS - 9, eC, 40, eC, TB.PATH, 1); carveT(map, 40, eC, 31, 42, TB.PATH, 1); carveT(map, 31, 42, 15, 42, TB.PATH, 1); carveT(map, 15, 42, 8, 42, TB.PATH, 1);
        carveT(map, 31, 28, 31, 18, TB.PATH, 0); carveT(map, 31, 52, 31, 64, TB.PATH, 0);
        startPos = ensurePassable(map, eC * TSIZ + TSIZ / 2, (ROWS - 5) * TSIZ + TSIZ / 2);
        bossPos = ensurePassable(map, eC * TSIZ + TSIZ / 2, 9 * TSIZ + TSIZ / 2);
        const cells = bfsPassable(map, ROWS - 5, eC);
        questPos = [safeSpawnCell(cells, startPos.x, startPos.y, 200) || { x: 18 * TSIZ, y: 47 * TSIZ },
        safeSpawnCell(cells, startPos.x, startPos.y, 150) || { x: 64 * TSIZ, y: 47 * TSIZ },
        safeSpawnCell(cells, bossPos.x, bossPos.y, 200) || { x: 18 * TSIZ, y: 15 * TSIZ }].map(p => ({ ...p, collected: false }));
      } else {
        fillR(map, 3, 3, ROWS - 3, COLS - 3, TB.SNOW);
        for (let r = 3; r < ROWS - 3; r++)for (let c = 3; c < COLS - 3; c++) {
          const n = fbm(c * 0.1 + seed * 0.08, r * 0.1 + seed * 0.08), n2 = fbm(c * 0.07 + 30 + seed * 0.05, r * 0.07 + 30 + seed * 0.05);
          if (n > 0.69) map[r][c] = TB.ROCK; else if (n > 0.61 && n2 < 0.45) map[r][c] = TB.HILL;
          else if (n < 0.32) map[r][c] = TB.ICE; else if (n2 > 0.71 && n < 0.55) map[r][c] = TB.LAVA;
        }
        const ridgeR = ri(24, 30), ridge2R = ri(10, 16), lw = ri(12, 16), rw = ri(62, 66);
        for (let c = 3; c < COLS - 3; c++) { const j = Math.round(Math.sin(c * 0.3 + seed) * 2), h = 3 + Math.round(Math.sin(c * 0.15) * 1); for (let r = ridgeR + j; r < ridgeR + j + h && r < ROWS - 3; r++)if (r > 3) map[r][c] = TB.ROCK; }
        for (let c = 3; c < COLS - 3; c++) { const j = Math.round(Math.cos(c * 0.25 + seed) * 2), h = 2 + Math.round(Math.sin(c * 0.2) * 1); for (let r = ridge2R + j; r < ridge2R + j + h && r < ROWS - 3; r++)if (r > 3) map[r][c] = TB.ROCK; }
        for (let r = 3; r < ROWS - 3; r++) { const j = Math.round(Math.sin(r * 0.2 + seed) * 2); for (let c = 3; c < lw + j && c < COLS - 3; c++)if (c > 3) map[r][c] = TB.ROCK; }
        for (let r = 3; r < ROWS - 3; r++) { const j = Math.round(Math.sin(r * 0.2 + seed + 5) * 2); for (let c = rw + j; c < COLS - 3; c++)if (c > 3) map[r][c] = TB.ROCK; }
        const glacR = ri(36, 44), glacC = ri(26, 52);
        fillE(map, glacR, glacC, ri(5, 8), ri(9, 14), TB.ICE); fillE(map, glacR, glacC, ri(2, 4), ri(4, 7), TB.WATER);
        for (let i = 0; i < 4; i++)fillE(map, ri(4, ridge2R - 2), ri(15, 65), ri(1, 3), ri(2, 5), TB.LAVA);
        const pass1C = ri(30, 50), pass2C = ri(28, 52);
        fillR(map, ridgeR - 1, pass1C - 2, ridgeR + 5, pass1C + 3, TB.SNOW); fillR(map, ridge2R - 1, pass2C - 2, ridge2R + 4, pass2C + 3, TB.SNOW);
        const startC = ri(35, 45), startR = ROWS - 5, bossR = 5, bossC = ri(30, 50);
        carveT(map, startR, startC, ridgeR, startC, TB.PATH, 1); carveT(map, ridgeR, startC, ridgeR, pass1C, TB.PATH, 1);
        carveT(map, ridgeR, pass1C, ridge2R, pass1C, TB.PATH, 1); carveT(map, ridge2R, pass1C, ridge2R, pass2C, TB.PATH, 1);
        carveT(map, ridge2R, pass2C, bossR, pass2C, TB.PATH, 1); carveT(map, bossR, pass2C, bossR, bossC, TB.PATH, 1);
        startPos = ensurePassable(map, startC * TSIZ + TSIZ / 2, (startR - 1) * TSIZ + TSIZ / 2);
        bossPos = ensurePassable(map, bossC * TSIZ + TSIZ / 2, (bossR + 1) * TSIZ + TSIZ / 2);
        const cells = bfsPassable(map, startR - 1, startC);
        questPos = [safeSpawnCell(cells, startPos.x, startPos.y, 200) || { x: (lw + 5) * TSIZ, y: ridgeR * TSIZ },
        safeSpawnCell(cells, startPos.x, startPos.y, 150) || { x: glacC * TSIZ, y: glacR * TSIZ },
        safeSpawnCell(cells, bossPos.x, bossPos.y, 200) || { x: pass2C * TSIZ, y: (ridge2R - 4) * TSIZ }].map(p => ({ ...p, collected: false }));
      }
      return { map, questPos, bossPos, startPos };
    }

    function genDecos(mapD, biome) {
      const d = [];
      const icons = {
        forest: ['üå≤', 'üåø', 'üçÑ', 'üå∏', 'üå∫', 'üíé', 'ü™®', 'üå≥', 'ü¶ã', 'üåæ', 'üçÉ'],
        castle: ['üè∞', 'üíé', 'ü™¶', 'üï∏Ô∏è', 'üî¶', '‚öîÔ∏è', 'üõ°Ô∏è', 'üß±', 'üïØÔ∏è'],
        mountain: ['üèîÔ∏è', '‚ùÑÔ∏è', 'ü¶Ö', 'ü™®', 'üíé', 'üåü', '‚õ∞Ô∏è', 'üßä', 'üå¨Ô∏è']
      };
      const arr = icons[biome] || icons.forest;
      const { map } = mapD;
      for (let i = 0; i < 100; i++) {
        const c = Math.floor(Math.random() * COLS), r = Math.floor(Math.random() * ROWS);
        if (!map[r] || map[r][c] === undefined) continue;
        const t = map[r][c]; if (t === TB.PATH || BLOCK[t]) continue;
        if (Math.random() < 0.25) d.push({ x: c * TSIZ + TSIZ / 2, y: r * TSIZ + TSIZ / 2, icon: arr[Math.floor(Math.random() * arr.length)], off: Math.random() * Math.PI * 2, scale: 0.65 + Math.random() * 0.5 });
      }
      return d;
    }
    function genAmbient(biome) {
      const p = []; const count = biome === 'forest' ? 40 : biome === 'castle' ? 25 : 30;
      const icons = biome === 'forest' ? ['‚ú®', 'üçÉ'] : biome === 'castle' ? ['üí´', 'üî•'] : ['‚ùÑÔ∏è', '‚ú¶'];
      for (let i = 0; i < count; i++)p.push({ x: Math.random() * WW, y: Math.random() * WH, icon: icons[i % icons.length], spd: 0.3 + Math.random() * 0.5, off: Math.random() * Math.PI * 2, alpha: 0.2 + Math.random() * 0.35, sz: 8 + Math.random() * 8 });
      return p;
    }

    // ============================================================
    // GAME STATE
    // ============================================================
    let gRun = false, curLvl = 0, isDead = false;
    const SKILL_CD = [18, 75, 42, 110];
    const DASH_CD = 180; // 3 secondes √† 60fps
    const GS = {
      p: {
        x: 400, y: 300, vx: 0, vy: 0, hp: 5, maxHp: 5, xp: 0, lvl: 1, wPow: 1,
        weapon: '‚öîÔ∏è √âp√©e Rouill√©e', spd: 3.4, r: 12,
        atkCDs: [0, 0, 0, 0], atkAnim: 0, inv: 0, fx: 1, fy: 0,
        qItems: 0, qKills: 0, charging: false, chargeTime: 0,
        dashCD: 0, invincible: false, invincibleTimer: 0
      },
      cam: { x: 0, y: 0 }, map: null, mons: [], boss: null,
      decos: [], ambient: [], qItems: [],
      bossSpawned: false, bossDefeated: false,
      dlgActive: false, frame: 0, atks: [], shake: 0,
      lightPulse: 0, projectiles: [], spinAnim: null,
      bossProjectiles: [], bossWarnings: [],
      timeStop: false, timeStopTimer: 0,
      screenFlash: { r: 0, g: 0, b: 0, a: 0 }
    };

    // ============================================================
    // INPUT
    // ============================================================
    const K = {};
    document.addEventListener('keydown', e => {
      K[e.code] = true;
      if (['Space', 'KeyX'].includes(e.code)) { doAtk(0); e.preventDefault(); }
      if (e.code === 'KeyE') { doAtk(1); e.preventDefault(); }
      if (e.code === 'KeyR') { doAtk(2); e.preventDefault(); }
      if (e.code === 'KeyG' || e.code === 'ShiftLeft' || e.code === 'ShiftRight') { doDash(); e.preventDefault(); }
      if (e.code === 'KeyF') { if (!GS.p.charging) startCharge(); e.preventDefault(); }
      if (['Enter', 'Space'].includes(e.code) && GS.dlgActive) { nextLine(); e.preventDefault(); }
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) e.preventDefault();
    });
    document.addEventListener('keyup', e => { K[e.code] = false; if (e.code === 'KeyF' && GS.p.charging) releaseCharge(); });

    // ============================================================
    // MOBILE JOYSTICK
    // ============================================================
    const jZone = document.getElementById('joystick-zone');
    const jKnob = document.getElementById('joystick-knob');
    let joystickActive = false, jTouchId = null, jOriginX = 0, jOriginY = 0;
    const J_MAX = 48;
    function jStart(e) {
      e.preventDefault(); const t = e.changedTouches[0]; const rect = jZone.getBoundingClientRect();
      jTouchId = t.identifier; jOriginX = rect.left + rect.width / 2; jOriginY = rect.top + rect.height / 2; joystickActive = true; jMove(e);
    }
    function jMove(e) {
      e.preventDefault(); if (!joystickActive) return; let touch = null;
      for (let i = 0; i < e.changedTouches.length; i++)if (e.changedTouches[i].identifier === jTouchId) touch = e.changedTouches[i];
      if (!touch) return; let dx = touch.clientX - jOriginX, dy = touch.clientY - jOriginY;
      const d = Math.sqrt(dx * dx + dy * dy); if (d > J_MAX) { dx = dx / d * J_MAX; dy = dy / d * J_MAX; }
      jKnob.style.left = (72 + dx - 28) + 'px'; jKnob.style.top = (72 + dy - 28) + 'px';
      const mag = Math.sqrt(dx * dx + dy * dy);
      if (mag > 5) { GS.p.vx = dx / J_MAX; GS.p.vy = dy / J_MAX; GS.p.fx = dx / mag; GS.p.fy = dy / mag; } else { GS.p.vx = 0; GS.p.vy = 0; }
    }
    function jEnd(e) {
      e.preventDefault(); joystickActive = false; jTouchId = null;
      jKnob.style.left = '44px'; jKnob.style.top = '44px'; GS.p.vx = 0; GS.p.vy = 0;
    }
    jZone.addEventListener('touchstart', jStart, { passive: false });
    jZone.addEventListener('touchmove', jMove, { passive: false });
    jZone.addEventListener('touchend', jEnd, { passive: false });
    jZone.addEventListener('touchcancel', jEnd, { passive: false });

    // ‚îÄ‚îÄ‚îÄ Boutons skills mobiles ‚îÄ‚îÄ‚îÄ
    const skMap = [
      ['bsk-spin', () => doAtk(1)],
      ['bsk-proj', () => doAtk(2)],
      ['bsk-dash', () => doDash()],
      ['bsk-charge', 'charge'],
    ];
    for (const [id, action] of skMap) {
      const btn = document.getElementById(id);
      if (!btn) continue;
      if (action === 'charge') {
        btn.addEventListener('touchstart', (e) => { e.preventDefault(); startCharge(); }, { passive: false });
        btn.addEventListener('touchend', (e) => { e.preventDefault(); releaseCharge(); }, { passive: false });
      } else {
        btn.addEventListener('touchstart', (e) => { e.preventDefault(); action(); }, { passive: false });
      }
    }

    // ‚îÄ‚îÄ‚îÄ Canvas : 1 tap = attaque, double-tap = dash ‚îÄ‚îÄ‚îÄ
    let lastTap = 0;
    canvas.addEventListener('touchstart', (e) => {
      if (GS.dlgActive) { e.preventDefault(); nextLine(); return; }
      e.preventDefault();
      const now = Date.now();
      if (now - lastTap < 260) {
        doDash(); // double-tap
      } else {
        doAtk(0); // simple tap
      }
      lastTap = now;
    }, { passive: false });

    // ‚îÄ‚îÄ‚îÄ Clic souris (PC) : 1 clic = attaque, double-clic = dash ‚îÄ‚îÄ‚îÄ
    canvas.addEventListener('click', (e) => {
      if (!GS.dlgActive && !joystickActive) doAtk(0);
    });
    canvas.addEventListener('dblclick', (e) => {
      if (!GS.dlgActive) doDash();
    });

    // ============================================================
    // HELPERS
    // ============================================================
    function dst(a, b) { const dx = a.x - b.x, dy = a.y - b.y; return Math.sqrt(dx * dx + dy * dy); }
    function lerp(a, b, t) { return a + (b - a) * t; }
    function blk(wx, wy, map) { const c = Math.floor(wx / TSIZ), r = Math.floor(wy / TSIZ); if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return true; return !!BLOCK[map[r][c]]; }
    function dmgFx(wx, wy, val, cls) {
      const sx = wx - GS.cam.x, sy = wy - GS.cam.y;
      const d = document.createElement('div'); d.className = `dmg ${cls}`;
      d.textContent = (cls === 'heal' ? '+' : cls === 'crit' ? '‚òÖ' : '') + Math.abs(val);
      d.style.left = (sx + (Math.random() - 0.5) * 30) + 'px'; d.style.top = (sy - 30) + 'px';
      document.body.appendChild(d); setTimeout(() => d.remove(), 900);
    }
    function screenFlash(r, g, b, a, dur = 200) {
      const fl = document.getElementById('atkflash');
      fl.style.background = `radial-gradient(ellipse at center,rgba(${r},${g},${b},${a}) 0%,transparent 70%)`;
      fl.style.opacity = '1'; setTimeout(() => { fl.style.opacity = '0'; }, dur);
    }
    function warnFlash() {
      const w = document.getElementById('warn-overlay');
      w.style.opacity = '0.6'; w.style.borderColor = 'rgba(255,0,0,0.6)';
      setTimeout(() => { w.style.opacity = '0'; w.style.borderColor = 'transparent'; }, 150);
    }
    function hitMon(m, dmg, cls = 'normal') {
      if (m.state === 'dead' || m.state === 'dying') return;
      m.hp -= dmg; m.hitFlash = 8; m.state = 'chase';
      GS.shake = cls === 'crit' ? 10 : cls === 'boss' ? 4 : 3; sHit(); dmgFx(m.x, m.y, dmg, cls);
      if (m.hp <= 0) killMon(m);
    }
    function killMon(m) {
      m.state = 'dying'; m.dyingTimer = 22; sDie();
      GS.p.xp += m.xp;
      if (GS.p.xp >= GS.p.lvl * 100) { GS.p.lvl++; GS.p.xp = 0; GS.p.maxHp = Math.min(12, GS.p.maxHp + 1); GS.p.hp = GS.p.maxHp; sLvlUp(); dmgFx(GS.p.x, GS.p.y, GS.p.lvl, 'heal'); }
      updHUD();
      if (m.boss) {
        GS.bossDefeated = true;
        document.getElementById('boss-hud').style.display = 'none';
        setTimeout(() => openDlg(m.icon, m.name, LEVELS[curLvl].bossDialog, () => showLT()), 600);
      } else if (LEVELS[curLvl].questType === 'kill') {
        GS.p.qKills++; updHUD();
        const lv = LEVELS[curLvl]; const mi = Math.min(GS.p.qKills - 1, lv.questMsgs.length - 1);
        const msg = lv.questMsgs[mi]; openDlg(msg[0], msg[1], msg.slice(2), null);
        if (GS.p.qKills >= lv.questCount && !GS.bossSpawned) spawnBoss();
      }
    }

    // ============================================================
    // PLAYER DAMAGE
    // ============================================================
    function damagePlayer(dmg, cls = 'normal') {
      const p = GS.p;
      // Invincibilit√© totale pendant le dash ‚Äî aucun d√©g√¢t
      if (p.invincible) return;
      if (p.inv > 0) return;
      p.hp -= dmg; p.inv = 60; GS.shake = 6; sDmg();
      dmgFx(p.x, p.y, -dmg, cls); updHUD();
      warnFlash();
      if (p.hp <= 0) playerDie();
    }

    // ============================================================
    // DEATH / RESPAWN
    // ============================================================
    function playerDie() {
      if (isDead) return; isDead = true; gRun = false; sDeath(); GS.shake = 25;
      screenFlash(200, 0, 0, 0.5, 600);
      document.getElementById('boss-hud').style.display = 'none';
      setTimeout(() => document.getElementById('deathscreen').style.display = 'flex', 900);
    }
    function restartLevel() {
      document.getElementById('deathscreen').style.display = 'none';
      isDead = false; gRun = true; loadLevel(curLvl);
    }

    // ============================================================
    // ATTACKS (PLAYER)
    // ============================================================
    function doAtk(type = 0) {
      if (GS.dlgActive || isDead) return;
      const p = GS.p; if (p.atkCDs[type] > 0) return;
      p.atkCDs[type] = SKILL_CD[type]; p.atkAnim = 14;
      if (type === 0) {
        sSwing(); GS.lightPulse = 10;
        screenFlash(255, 255, 255, 0.25, 60);
        const range = 55 + p.wPow * 5, angle = Math.atan2(p.fy, p.fx);
        GS.atks.push({ worldX: p.x + p.fx * 34, worldY: p.y + p.fy * 34, icon: '‚ú®', sz: 18, life: 10, maxLife: 10, vx: p.fx, vy: p.fy });
        const all = [...GS.mons]; if (GS.boss && GS.boss.state !== 'dead') all.push(GS.boss);
        for (const m of all) {
          if (m.state === 'dead' || m.state === 'dying') continue; if (dst(p, m) > range + m.r) continue;
          const ma = Math.atan2(m.y - p.y, m.x - p.x); let da = ma - angle;
          while (da > Math.PI) da -= Math.PI * 2; while (da < -Math.PI) da += Math.PI * 2;
          if (Math.abs(da) > 1.1) continue;
          const crit = Math.random() < 0.2;
          hitMon(m, Math.ceil(p.wPow * (crit ? 2.5 : 1) + (Math.random() < 0.3 ? 1 : 0)), crit ? 'crit' : 'normal');
        }
      } else if (type === 1) {
        sSpin(); GS.shake = 4; screenFlash(200, 100, 255, 0.3, 120);
        const range = 65 + p.wPow * 4;
        for (let i = 0; i < 8; i++) {
          const a = i / 8 * Math.PI * 2;
          GS.atks.push({ worldX: p.x + Math.cos(a) * range * 0.55, worldY: p.y + Math.sin(a) * range * 0.55, icon: 'üí•', sz: 19, life: 15, maxLife: 15, vx: Math.cos(a) * 0.4, vy: Math.sin(a) * 0.4 });
        }
        const all = [...GS.mons]; if (GS.boss && GS.boss.state !== 'dead') all.push(GS.boss);
        for (const m of all) {
          if (m.state === 'dead' || m.state === 'dying') continue; if (dst(p, m) > range + m.r) continue;
          hitMon(m, Math.ceil(p.wPow * 0.9 + (Math.random() < 0.25 ? 1 : 0)), 'spin');
        }
        GS.spinAnim = { timer: 24, maxTimer: 24 };
      } else if (type === 2) {
        sProj(); GS.lightPulse = 8;
        const icon = curLvl === 0 ? '‚ö°' : curLvl === 1 ? 'üîÆ' : '‚ùÑÔ∏è';
        GS.projectiles.push({ x: p.x + p.fx * 20, y: p.y + p.fy * 20, vx: p.fx * 6.2, vy: p.fy * 6.2, power: Math.ceil(p.wPow), icon, sz: 20, life: 85, r: 10, owner: 'player' });
        GS.atks.push({ worldX: p.x + p.fx * 20, worldY: p.y + p.fy * 20, icon, sz: 22, life: 8, maxLife: 8, vx: p.fx * 0.3, vy: p.fy * 0.3 });
      } else if (type === 3) {
        if (p.charging) releaseCharge(); else startCharge();
      }
      updSkillBar();
    }
    function startCharge() { if (GS.dlgActive || isDead) return; GS.p.charging = true; GS.p.chargeTime = 0; }
    function releaseCharge() {
      const p = GS.p; if (!p.charging) return; p.charging = false;
      if (p.atkCDs[3] > 0) { p.chargeTime = 0; return; }
      p.atkCDs[3] = SKILL_CD[3]; const charge = Math.min(1, p.chargeTime / 60); sCharge();
      screenFlash(255, 200, 50, 0.8, 180); GS.shake = 12 + charge * 8; GS.lightPulse = 24;
      const range = (74 + p.wPow * 6) * (1 + charge * 0.8), angle = Math.atan2(p.fy, p.fx);
      for (let i = 0; i < 6; i++) {
        const sp = (Math.random() - 0.5) * 1.8;
        GS.atks.push({ worldX: p.x + p.fx * range * 0.5, worldY: p.y + p.fy * range * 0.5, icon: 'üí´', sz: 30 + charge * 14, life: 22, maxLife: 22, vx: p.fx + sp, vy: p.fy + sp });
      }
      const all = [...GS.mons]; if (GS.boss && GS.boss.state !== 'dead') all.push(GS.boss);
      for (const m of all) {
        if (m.state === 'dead' || m.state === 'dying') continue; if (dst(p, m) > range + m.r) continue;
        const ma = Math.atan2(m.y - p.y, m.x - p.x); let da = ma - angle;
        while (da > Math.PI) da -= Math.PI * 2; while (da < -Math.PI) da += Math.PI * 2;
        if (Math.abs(da) > 1.4) continue;
        const dmg = Math.ceil(p.wPow * (1 + charge * 3.5));
        hitMon(m, dmg, 'crit');
        if (m.state !== 'dying') { const kd = Math.min(70, 100 / (dst(p, m) + 1)); m.x += (m.x - p.x) / (dst(p, m) + 1) * kd; m.y += (m.y - p.y) / (dst(p, m) + 1) * kd; }
      }
      p.chargeTime = 0; updSkillBar();
    }

    // ‚îÄ‚îÄ ESQUIVE / DASH ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const INVINCIBLE_DUR = 36; // ~0.6s √† 60fps
    function doDash() {
      if (GS.dlgActive || isDead) return;
      const p = GS.p; if (p.dashCD > 0) return;
      p.dashCD = DASH_CD;
      // Dash dans la direction du mouvement (ou vers l'avant si immobile)
      const dx = p.vx !== 0 || p.vy !== 0 ? p.vx : p.fx;
      const dy = p.vx !== 0 || p.vy !== 0 ? p.vy : p.fy;
      const mag = Math.sqrt(dx * dx + dy * dy) || 1;
      const nx = dx / mag, ny = dy / mag;
      // Propulser le joueur
      const dashDist = 80; const { map } = GS.map;
      let tx = p.x + nx * dashDist, ty = p.y + ny * dashDist;
      // Pas dans un mur
      if (blk(tx, p.y, map)) tx = p.x;
      if (blk(p.x, ty, map)) ty = p.y;
      p.x = tx; p.y = ty;
      // Invincibilit√©
      p.invincible = true; p.invincibleTimer = INVINCIBLE_DUR;
      p.inv = INVINCIBLE_DUR + 10; // immunit√© d√©g√¢ts normaux aussi
      // Effets visuels
      GS.shake = 3;
      screenFlash(0, 255, 200, 0.35, 180);
      // Train√©e
      for (let i = 0; i < 6; i++) {
        GS.atks.push({
          worldX: p.x - nx * i * 12, worldY: p.y - ny * i * 12,
          icon: 'üí®', sz: 18 - i * 2, life: 14 - i, maxLife: 14, vx: -nx * 0.5, vy: -ny * 0.5
        });
      }
      // Son
      try {
        const c = ac(), o = c.createOscillator(), g = c.createGain();
        o.connect(g); g.connect(c.destination); o.type = 'sine';
        o.frequency.setValueAtTime(800, c.currentTime); o.frequency.linearRampToValueAtTime(400, c.currentTime + 0.12);
        g.gain.setValueAtTime(0.12, c.currentTime); g.gain.linearRampToValueAtTime(0, c.currentTime + 0.14);
        o.start(); o.stop(c.currentTime + 0.16);
      } catch (e) { }
      updDashBtn();
    }
    function updSkillBar() {
      // Skill 1 = SPIN (atkCDs[1])
      _updSkRing('bsk-spin', 'ring-spin', GS.p.atkCDs[1], SKILL_CD[1]);
      // Skill 2 = PROJ (atkCDs[2])
      _updSkRing('bsk-proj', 'ring-proj', GS.p.atkCDs[2], SKILL_CD[2]);
      // Skill 3 = CHARGE (atkCDs[3])
      _updSkRing('bsk-charge', 'ring-charge', GS.p.atkCDs[3], SKILL_CD[3]);
      updDashBtn();
    }
    function _updSkRing(btnId, ringId, cd, max) {
      const btn = document.getElementById(btnId);
      const ring = document.getElementById(ringId);
      if (!btn || !ring) return;
      if (cd > 0) {
        const pct = ((max - cd) / max * 100);
        ring.style.setProperty('--p', pct + '%'); ring.classList.add('on'); btn.classList.add('cd');
      } else { ring.classList.remove('on'); btn.classList.remove('cd'); }
    }
    function updDashBtn() {
      const btn = document.getElementById('bsk-dash');
      const ring = document.getElementById('ring-dash');
      if (!btn || !ring) return;
      const p = GS.p;
      if (p.invincible) {
        btn.classList.add('inv'); btn.classList.remove('cd'); ring.classList.remove('on');
        document.getElementById('invincible-overlay').classList.add('active');
      } else {
        btn.classList.remove('inv');
        document.getElementById('invincible-overlay').classList.remove('active');
        if (p.dashCD > 0) {
          const pct = ((DASH_CD - p.dashCD) / DASH_CD * 100);
          ring.style.setProperty('--p', pct + '%'); ring.classList.add('on'); btn.classList.add('cd');
        } else { ring.classList.remove('on'); btn.classList.remove('cd'); }
      }
    }

    // ============================================================
    // BOSS SPAWN
    // ============================================================
    function spawnBoss() {
      if (GS.bossSpawned) return; GS.bossSpawned = true;
      const lv = LEVELS[curLvl]; const pos = GS.map.bossPos;
      GS.boss = {
        icon: lv.bossIcon, name: lv.bossName, hp: lv.bossHP, maxHp: lv.bossHP,
        spd: lv.bossSpeed || (0.55 + curLvl * 0.12), dmg: 2 + curLvl, x: pos.x, y: pos.y,
        state: 'idle', dyingTimer: 0, atkCD: 0,
        aggroR: lv.bossAggroR || 480, loseR: 700, warnR: lv.bossWarnR || null, wAngle: 0, wTimer: 0,
        hitFlash: 0, r: 24, boss: true, xp: 80 + curLvl * 40,
        // Boss-specific
        phase: 0, phaseTimer: 0, pattern: 0, patternTimer: 0,
        patterns: lv.bossPatterns || [],
        dashTarget: { x: pos.x, y: pos.y }, dashTimer: 0, dashActive: false,
        teleportCooldown: 0, rageMode: false,
        warningTimer: 0, beamAngle: 0, beamActive: false, beamTimer: 0,
        orbiting: false, orbitAngle: 0,
        timeStopActive: false,
        // Boss 2 warning
        warnZone: false, warnZoneTimer: 0, warnZoneAlerted: false,
        // Boss 3 aerial
        aerialActive: false, aerialTimer: 0, aerialTargetX: 0, aerialTargetY: 0
      };
      GS.bossSpawned = true;
      // Setup boss HP bar
      const bossHud = document.getElementById('boss-hud');
      bossHud.style.display = 'flex';
      document.getElementById('boss-hud-name').textContent = lv.bossName.toUpperCase();
      // Phase pips
      const pip = document.getElementById('boss-phase-wrap'); pip.innerHTML = '';
      const phases = lv.bossPhases || 2;
      for (let i = 0; i < phases; i++) { const d = document.createElement('div'); d.className = 'boss-phase-pip' + (i === 0 ? ' active' : ''); d.id = `bpip${i}`; pip.appendChild(d); }
      sBossSpawn();
      openDlg('‚ö†Ô∏è', 'DANGER !', [`üëπ ${lv.bossName} APPARA√éT !`, 'Attention ! Ce boss a des patterns d√©vastateurs !', 'Esquive et frappe au bon moment !'], null);
    }
    function updBossHPBar() {
      const b = GS.boss; if (!b) return;
      const pct = Math.max(0, b.hp / b.maxHp * 100);
      document.getElementById('boss-hp-fill').style.width = pct + '%';
      // Phase transitions
      const lv = LEVELS[curLvl]; const phases = lv.bossPhases || 2;
      const threshold = 1 / phases;
      const currentPhase = Math.floor((1 - b.hp / b.maxHp) / threshold);
      if (currentPhase !== b.phase && currentPhase < phases) {
        b.phase = currentPhase;
        // Light up phase pip
        for (let i = 0; i < phases; i++) { const pip = document.getElementById(`bpip${i}`); if (pip) pip.classList.toggle('active', i <= currentPhase); }
        // Rage at last phase
        if (currentPhase >= phases - 1) { b.rageMode = true; sBossRage(); screenFlash(255, 50, 0, 0.6, 500); GS.shake = 20; }
      }
    }

    // ============================================================
    // BOSS AI ‚Äî Patterns
    // ============================================================
    function doBossPattern(b) {
      const p = GS.p; const lv = LEVELS[curLvl];
      if (!b.patterns || b.patterns.length === 0) return;
      if (b.patternTimer > 0) { b.patternTimer--; return; }
      // Pick next pattern
      const patterns = b.patterns;
      const patIdx = Math.floor(GS.frame / 200) % patterns.length;
      const pattern = patterns[patIdx + (b.rageMode ? 1 : 0) % patterns.length] || patterns[0];
      const cd = b.rageMode ? 140 : 200;
      b.patternTimer = cd;
      executeBossPattern(b, pattern, p);
    }

    function executeBossPattern(b, pattern, p) {
      switch (pattern) {
        // ---- PATTERN 1: Slash (melee dash toward player) ----
        case 'slash': {
          if (dst(b, p) < 200) {
            b.dashActive = true; b.dashTimer = 12;
            const ang = Math.atan2(p.y - b.y, p.x - b.x);
            b.dashVx = Math.cos(ang) * 10; b.dashVy = Math.sin(ang) * 10;
            // Warning indicator
            GS.bossWarnings.push({ x: p.x, y: p.y, r: 60, life: 25, maxLife: 25, type: 'circle', color: '#ff4400' });
            sBossDash();
          }
          break;
        }
        // ---- PATTERN 2: Poison ring ----
        case 'poison_ring': {
          for (let i = 0; i < 8; i++) {
            const ang = i / 8 * Math.PI * 2;
            GS.bossProjectiles.push({ x: b.x, y: b.y, vx: Math.cos(ang) * 2.2, vy: Math.sin(ang) * 2.2, icon: '‚ò†Ô∏è', sz: 18, life: 100, r: 12, dmg: 2, cls: 'spin' });
          }
          GS.bossWarnings.push({ x: b.x, y: b.y, r: 80, life: 20, maxLife: 20, type: 'ring', color: '#44ff44' });
          screenFlash(0, 200, 0, 0.25, 200); sBossWave();
          break;
        }
        // ---- PATTERN 3: Teleport strike ----
        case 'teleport_strike': {
          if (b.teleportCooldown <= 0) {
            // Teleport near player
            const ang = Math.random() * Math.PI * 2; const dist = 80 + Math.random() * 60;
            const nx = p.x + Math.cos(ang) * dist, ny = p.y + Math.sin(ang) * dist;
            // Safety check
            if (!blk(nx, ny, GS.map.map)) {
              // Warning first
              GS.bossWarnings.push({ x: nx, y: ny, r: 50, life: 30, maxLife: 30, type: 'circle', color: '#cc00ff' });
              setTimeout(() => {
                if (b.state === 'dead' || b.state === 'dying') return;
                b.x = nx; b.y = ny; b.hitFlash = 5;
                GS.atks.push({ worldX: b.x, worldY: b.y, icon: 'üåÄ', sz: 40, life: 18, maxLife: 18, vx: 0, vy: 0 });
                screenFlash(150, 0, 255, 0.4, 200); sBossDash();
                // Instant hit if still close
                if (dst(b, p) < 60) damagePlayer(3, 'spin');
              }, 500);
              b.teleportCooldown = 180;
            }
          }
          break;
        }
        // ---- PATTERN 4: Shadow wave (row of projectiles) ----
        case 'shadow_wave': {
          const ang = Math.atan2(p.y - b.y, p.x - b.x);
          for (let i = -2; i <= 2; i++) {
            const a = ang + i * 0.25;
            setTimeout(() => {
              if (b.state === 'dead' || b.state === 'dying') return;
              GS.bossProjectiles.push({ x: b.x, y: b.y, vx: Math.cos(a) * 4, vy: Math.sin(a) * 4, icon: 'üíú', sz: 22, life: 90, r: 14, dmg: 2, cls: 'spin' });
            }, i * 80 + 80);
          }
          GS.bossWarnings.push({ x: b.x, y: b.y, r: 120, life: 24, maxLife: 24, type: 'ring', color: '#8800ff' });
          sBossWave();
          break;
        }
        // ---- PATTERN 5: Death beam (sweeping laser) ----
        case 'death_beam': {
          // Charge-up phase first ‚Äî boss stops, glows, then fires
          b.beamCharging = true; b.beamChargeTimer = 70; // ~1.2s warning
          b.beamTargetAngle = Math.atan2(p.y - b.y, p.x - b.x);
          b.beamSweepDir = 1; b.beamDmgCD = 0;
          // Big visible warnings: multiple expanding rings + screen tint
          for (let i = 0; i < 3; i++) {
            setTimeout(() => {
              if (b.state === 'dead' || b.state === 'dying') return;
              GS.bossWarnings.push({ x: b.x, y: b.y, r: 60 + i * 60, life: 50, maxLife: 50, type: 'ring', color: '#ff0000' });
            }, i * 200);
          }
          // Directional warning line (shows where beam will fire)
          GS.bossWarnings.push({ x: b.x, y: b.y, r: 260, life: 65, maxLife: 65, type: 'beam_warn', angle: b.beamTargetAngle, color: '#ff4400' });
          screenFlash(255, 0, 0, 0.25, 1200); sBossBeam();
          // Actually fire after charge-up delay
          setTimeout(() => {
            if (b.state === 'dead' || b.state === 'dying' || !b.beamCharging) return;
            b.beamCharging = false;
            b.beamActive = true; b.beamTimer = 100;
            b.beamAngle = b.beamTargetAngle - 0.5;
            screenFlash(255, 80, 0, 0.5, 300); GS.shake = 10;
          }, 1150);
          break;
        }
        // ---- PATTERN 6: Fireball burst ----
        case 'fireball_burst': {
          for (let i = 0; i < 12; i++) {
            setTimeout(() => {
              if (b.state === 'dead' || b.state === 'dying') return;
              const ang = Math.atan2(p.y - b.y, p.x - b.x) + (Math.random() - 0.5) * 0.6;
              GS.bossProjectiles.push({ x: b.x, y: b.y, vx: Math.cos(ang) * 4.5, vy: Math.sin(ang) * 4.5, icon: 'üî•', sz: 24, life: 70, r: 14, dmg: 3, cls: 'fire' });
            }, i * 80);
          }
          GS.bossWarnings.push({ x: b.x, y: b.y, r: 150, life: 26, maxLife: 26, type: 'ring', color: '#ff5500' });
          screenFlash(255, 150, 0, 0.4, 300); sBossBeam();
          break;
        }
        // ---- PATTERN 7: Dash slam (fast dash then shockwave) ----
        case 'dash_slam': {
          const ang = Math.atan2(p.y - b.y, p.x - b.x);
          b.dashActive = true; b.dashTimer = 18;
          b.dashVx = Math.cos(ang) * 14; b.dashVy = Math.sin(ang) * 14;
          GS.bossWarnings.push({ x: p.x, y: p.y, r: 90, life: 28, maxLife: 28, type: 'circle', color: '#ff8800' });
          sBossDash();
          // After dash, shockwave
          setTimeout(() => {
            if (b.state === 'dead' || b.state === 'dying') return;
            for (let i = 0; i < 12; i++) {
              const a = i / 12 * Math.PI * 2;
              GS.bossProjectiles.push({ x: b.x, y: b.y, vx: Math.cos(a) * 3.5, vy: Math.sin(a) * 3.5, icon: 'üåä', sz: 20, life: 60, r: 12, dmg: 2, cls: 'ice' });
            }
            GS.shake = 15; screenFlash(255, 200, 50, 0.5, 250);
          }, 350);
          break;
        }
        // ---- PATTERN 8: Time stop ----
        case 'time_stop': {
          GS.timeStop = true; GS.timeStopTimer = 120;
          screenFlash(100, 100, 255, 0.6, 600); GS.shake = 12;
          // During time stop, boss fires a spiral
          for (let i = 0; i < 20; i++) {
            setTimeout(() => {
              if (b.state === 'dead' || b.state === 'dying') return;
              const a = i * 0.5;
              GS.bossProjectiles.push({ x: b.x, y: b.y, vx: Math.cos(a) * 3, vy: Math.sin(a) * 3, icon: '‚è∞', sz: 18, life: 80, r: 12, dmg: 2, cls: 'ice' });
            }, i * 100);
          }
          sBossRage();
          break;
        }
        // ---- PATTERN 9: Meteor shower ----
        case 'meteor': {
          for (let i = 0; i < 6; i++) {
            setTimeout(() => {
              if (b.state === 'dead' || b.state === 'dying') return;
              const tx = p.x + (Math.random() - 0.5) * 200; const ty = p.y + (Math.random() - 0.5) * 200;
              GS.bossWarnings.push({ x: tx, y: ty, r: 55, life: 40, maxLife: 40, type: 'circle', color: '#ff3300' });
              setTimeout(() => {
                if (b.state === 'dead' || b.state === 'dying') return;
                GS.atks.push({ worldX: tx, worldY: ty, icon: '‚òÑÔ∏è', sz: 44, life: 22, maxLife: 22, vx: 0, vy: 0 });
                GS.shake = 10;
                if (dst({ x: tx, y: ty }, p) < 65) damagePlayer(4, 'fire');
              }, 600);
            }, i * 200);
          }
          sBossBeam();
          break;
        }
        // ---- PATTERN 10: Enrage (speed + fire ring) ----
        case 'enrage': {
          b.rageMode = true;
          for (let i = 0; i < 16; i++) {
            const a = i / 16 * Math.PI * 2;
            GS.bossProjectiles.push({ x: b.x, y: b.y, vx: Math.cos(a) * 3, vy: Math.sin(a) * 3, icon: 'üí¢', sz: 16, life: 120, r: 10, dmg: 2, cls: 'fire' });
          }
          GS.shake = 18; screenFlash(255, 0, 0, 0.6, 500); sBossRage();
          break;
        }
        // ---- PATTERN 11: Aerial Slam (Dragon takes flight, picks target, CRASHES DOWN) ----
        case 'aerial_slam': {
          if (b.aerialActive) break; // already in flight
          b.aerialActive = true;
          b.aerialTimer = 0;
          b.aerialTargetX = p.x;
          b.aerialTargetY = p.y;
          b.aerialPhase = 'rising'; // rising ‚Üí hovering ‚Üí warning ‚Üí slamming ‚Üí impact
          // Phase 1: Dragon rises (scale up, glow)
          screenFlash(255, 100, 0, 0.4, 300); GS.shake = 8;
          sBossRage();
          // Store original pos for rendering offset
          b.aerialOriginX = b.x; b.aerialOriginY = b.y;
          b.aerialRiseTimer = 50; // frames rising
          b.patternTimer += 220; // give extra cooldown since this is a long attack
          break;
        }
      }
    }

    // ============================================================
    // MONSTER AI
    // ============================================================
    function updMons() {
      if (GS.timeStop && GS.timeStopTimer > 0) {
        GS.timeStopTimer--; if (GS.timeStopTimer <= 0) { GS.timeStop = false; screenFlash(100, 100, 255, 0.3, 300); }
        // Only update boss during time stop (it attacks)
        if (GS.boss && GS.boss.state !== 'dead' && GS.boss.state !== 'dying') {
          updBoss(GS.boss); updBossHPBar();
        }
        return;
      }
      const p = GS.p; const { map } = GS.map;
      for (const m of GS.mons) {
        if (m.hitFlash > 0) m.hitFlash--; if (m.atkCD > 0) m.atkCD--;
        if (m.state === 'dying') { m.dyingTimer--; if (m.dyingTimer <= 0) m.state = 'dead'; continue; }
        if (m.state === 'dead') continue;
        const d = dst(m, p);
        if (m.state === 'idle' || m.state === 'wander') {
          m.wTimer--; if (m.wTimer <= 0) { m.wAngle += (Math.random() - 0.5) * Math.PI; m.wTimer = 60 + Math.random() * 90; }
          m.vx = Math.cos(m.wAngle) * m.spd * 0.3; m.vy = Math.sin(m.wAngle) * m.spd * 0.3; m.state = 'wander';
          if (d < m.aggroR) m.state = 'chase';
        }
        if (m.state === 'chase') {
          if (d > m.loseR) { m.state = 'idle'; m.vx = 0; m.vy = 0; continue; }
          m.vx = lerp(m.vx, (p.x - m.x) / d * m.spd, 0.12); m.vy = lerp(m.vy, (p.y - m.y) / d * m.spd, 0.12);
          if (d < m.r + p.r + 6 && m.atkCD <= 0) { damagePlayer(m.dmg, 'normal'); m.atkCD = 65; }
        }
        let nx = m.x + m.vx, ny = m.y + m.vy;
        if (!blk(nx, m.y, map)) m.x = nx; else m.vx *= -1;
        if (!blk(m.x, ny, map)) m.y = ny; else m.vy *= -1;
        m.x = Math.max(TSIZ, Math.min(WW - TSIZ, m.x)); m.y = Math.max(TSIZ, Math.min(WH - TSIZ, m.y));
      }
      if (GS.boss && GS.boss.state !== 'dead') { updBoss(GS.boss); updBossHPBar(); }
    }

    function updBoss(b) {
      if (b.hitFlash > 0) b.hitFlash--; if (b.atkCD > 0) b.atkCD--; if (b.teleportCooldown > 0) b.teleportCooldown--;
      if (b.state === 'dying') { b.dyingTimer--; if (b.dyingTimer <= 0) b.state = 'dead'; return; }
      if (b.state === 'dead') return;
      const p = GS.p; const d = dst(b, p); const { map } = GS.map;
      // Boss 2: show "DANGER" warning zone before aggro
      if (b.warnR && b.state === 'idle' && !b.warnZoneAlerted) {
        if (d < b.warnR) {
          b.warnZoneAlerted = true;
          GS.bossWarnings.push({ x: b.x, y: b.y, r: b.warnR, life: 60, maxLife: 60, type: 'warn_zone', color: '#ff8800' });
          screenFlash(255, 120, 0, 0.3, 800); GS.shake = 6;
          // pulse warning to player
          for (let i = 0; i < 3; i++) setTimeout(() => { if (b.state === 'dead') return; GS.bossWarnings.push({ x: b.x, y: b.y, r: b.warnR * 0.6, life: 30, maxLife: 30, type: 'ring', color: '#ff6600' }); }, i * 350);
        }
      }
      if (b.state === 'idle') { if (d < b.aggroR) { b.state = 'chase'; if (b.warnR) { screenFlash(255,50,0,0.5,400); GS.shake=12; } } }
      if (b.state === 'chase' || b.state === 'attack') {
        // Dash movement
        if (b.dashActive && b.dashTimer > 0) {
          b.dashTimer--;
          const nx = b.x + b.dashVx, ny = b.y + b.dashVy;
          if (!blk(nx, b.y, map)) b.x = nx; else { b.dashVx *= -0.5; b.x += b.dashVx; }
          if (!blk(b.x, ny, map)) b.y = ny; else { b.dashVy *= -0.5; b.y += b.dashVy; }
          // Damage if hits player during dash
          if (dst(b, p) < b.r + p.r + 10 && b.atkCD <= 0) { damagePlayer(b.dmg + 1, 'boss'); b.atkCD = 40; }
          if (b.dashTimer <= 0) { b.dashActive = false; GS.shake = 8; }
        } else if (b.aerialActive && (b.aerialPhase === 'rising' || b.aerialPhase === 'hovering' || b.aerialPhase === 'frozen')) {
          // During aerial: hover in place, don't move horizontally
          b.vx = 0; b.vy = 0;
        } else {
          // Normal chase ‚Äî boss PHASES through walls (no getting stuck!)
          const spd = b.rageMode ? b.spd * 1.7 : b.spd;
          const tx = (p.x - b.x) / d * spd, ty = (p.y - b.y) / d * spd;
          b.vx = lerp(b.vx || 0, tx, 0.08); b.vy = lerp(b.vy || 0, ty, 0.08);
          // Bosses are too powerful to be stopped by walls ‚Äî they phase through!
          b.x += b.vx || 0; b.y += b.vy || 0;
          // Wall phase visual effect: emit ghostly particles when inside a wall
          if (blk(b.x, b.y, map)) {
            GS.atks.push({ worldX: b.x, worldY: b.y, icon: 'üëÅÔ∏è', sz: 28, life: 12, maxLife: 12, vx: (Math.random()-0.5)*1.5, vy: (Math.random()-0.5)*1.5 });
          }
        }
        b.x = Math.max(TSIZ, Math.min(WW - TSIZ, b.x)); b.y = Math.max(TSIZ, Math.min(WH - TSIZ, b.y));
        // Melee attack
        if (d < b.r + p.r + 10 && b.atkCD <= 0 && !b.dashActive) { damagePlayer(b.dmg, 'boss'); b.atkCD = 55; }
        // Beam damage
        if (b.beamActive && b.beamTimer > 0) {
          b.beamTimer--;
          // Slow sweep ‚Äî much more dodgeable
          b.beamAngle += 0.008 * b.beamSweepDir * (b.rageMode ? 1.3 : 1);
          if (b.beamDmgCD > 0) b.beamDmgCD--;
          const beamDirX = Math.cos(b.beamAngle), beamDirY = Math.sin(b.beamAngle);
          const toPX = p.x - b.x, toPY = p.y - b.y;
          const dot = toPX * beamDirX + toPY * beamDirY;
          const cross = Math.abs(toPX * beamDirY - toPY * beamDirX);
          // Damage only every 30 frames (0.5s) and only if truly in beam
          if (dot > 0 && cross < 24 && dst(b, p) < 450 && b.beamDmgCD <= 0) {
            damagePlayer(b.rageMode ? 2 : 1, 'fire');
            b.beamDmgCD = 30;
          }
          if (b.beamTimer <= 0) { b.beamActive = false; }
        }
        // Pattern trigger
        doBossPattern(b);
        // ---- AERIAL SLAM (Boss 3) state machine ----
        if (b.aerialActive) {
          b.aerialTimer++;
          const t = b.aerialTimer;
          if (b.aerialPhase === 'rising') {
            // Move upward visually (we store aerialY offset)
            b.aerialYOff = (b.aerialYOff || 0) - 2.5;
            if (b.aerialYOff < -80) b.aerialYOff = -80;
            if (t >= b.aerialRiseTimer) {
              b.aerialPhase = 'hovering';
              b.aerialTimer = 0;
              // Lock onto current player position for slam
              b.aerialTargetX = p.x; b.aerialTargetY = p.y;
            }
          } else if (b.aerialPhase === 'hovering') {
            // 40 frames: dragon hovers above, shadow + warning circle grows below
            const progress = t / 40;
            if (t % 8 === 0) GS.bossWarnings.push({ x: b.aerialTargetX, y: b.aerialTargetY, r: 20 + progress * 80, life: 18, maxLife: 18, type: 'slam_zone', color: '#ff3300' });
            if (t === 15) { screenFlash(255,50,0,0.3,200); GS.shake = 4; }
            if (t >= 40) {
              b.aerialPhase = 'frozen'; // freeze moment before slam
              b.aerialTimer = 0;
              // Big final warning
              GS.bossWarnings.push({ x: b.aerialTargetX, y: b.aerialTargetY, r: 90, life: 20, maxLife: 20, type: 'slam_zone', color: '#ff0000' });
              screenFlash(255,0,0,0.6,300); GS.shake = 10;
            }
          } else if (b.aerialPhase === 'frozen') {
            // Freeze in air for dramatic effect (20 frames)
            b.aerialYOff = (b.aerialYOff || -80); // stay up
            if (t >= 20) {
              b.aerialPhase = 'slamming';
              b.aerialTimer = 0;
              sBossRage();
            }
          } else if (b.aerialPhase === 'slamming') {
            // Fast crash down (15 frames)
            const progress = Math.min(1, t / 15);
            b.aerialYOff = -80 * (1 - progress);
            b.x = lerp(b.x, b.aerialTargetX, 0.18);
            b.y = lerp(b.y, b.aerialTargetY, 0.08);
            if (t >= 15 || (b.aerialYOff >= -5)) {
              b.aerialYOff = 0;
              b.x = b.aerialTargetX; b.y = b.aerialTargetY;
              b.aerialPhase = 'impact';
              b.aerialTimer = 0;
              // IMPACT ‚Äî massive damage, shockwave, screen shake
              GS.shake = 30; screenFlash(255,100,0,0.9,400);
              const impDist = dst(b, p);
              if (impDist < 110) { damagePlayer(b.rageMode ? 7 : 5, 'fire'); }
              else if (impDist < 180) { damagePlayer(b.rageMode ? 4 : 2, 'fire'); }
              // Shockwave projectiles radially
              for (let i = 0; i < 16; i++) {
                const a = i / 16 * Math.PI * 2;
                GS.bossProjectiles.push({ x: b.x, y: b.y, vx: Math.cos(a) * 5, vy: Math.sin(a) * 5, icon: 'üî•', sz: 22, life: 55, r: 13, dmg: b.rageMode ? 3 : 2, cls: 'fire' });
              }
              // Big impact visuals
              for (let i = 0; i < 10; i++) {
                GS.atks.push({ worldX: b.x + (Math.random()-0.5)*80, worldY: b.y + (Math.random()-0.5)*80, icon: 'üí•', sz: 34 + Math.random()*20, life: 22, maxLife: 22, vx: (Math.random()-0.5)*2, vy: (Math.random()-0.5)*2 });
              }
              sBossBeam();
            }
          } else if (b.aerialPhase === 'impact') {
            if (t >= 30) { b.aerialActive = false; b.aerialYOff = 0; b.aerialPhase = null; }
          }
        }
      }
    }

    // ============================================================
    // PROJECTILE UPDATE
    // ============================================================
    function updProjectiles() {
      const { map } = GS.map; const p = GS.p;
      // Player projectiles
      for (let i = GS.projectiles.length - 1; i >= 0; i--) {
        const pr = GS.projectiles[i]; pr.life--; pr.x += pr.vx; pr.y += pr.vy;
        if (blk(pr.x, pr.y, map) || pr.life <= 0) { GS.projectiles.splice(i, 1); continue; }
        let hit = false;
        const all = [...GS.mons]; if (GS.boss && GS.boss.state !== 'dead') all.push(GS.boss);
        for (const m of all) {
          if (m.state === 'dead' || m.state === 'dying') continue;
          if (dst(pr, m) < m.r + pr.r) {
            const cls = curLvl === 2 ? 'ice' : curLvl === 1 ? 'fire' : 'normal';
            hitMon(m, pr.power, cls);
            GS.atks.push({ worldX: pr.x, worldY: pr.y, icon: 'üí•', sz: 24, life: 12, maxLife: 12, vx: 0, vy: 0 });
            GS.projectiles.splice(i, 1); hit = true; break;
          }
        }
      }
      // Boss projectiles
      for (let i = GS.bossProjectiles.length - 1; i >= 0; i--) {
        const pr = GS.bossProjectiles[i]; pr.life--; pr.x += pr.vx; pr.y += pr.vy;
        if (blk(pr.x, pr.y, map) || pr.life <= 0) { GS.bossProjectiles.splice(i, 1); continue; }
        if (dst(pr, p) < p.r + pr.r) {
          damagePlayer(pr.dmg, pr.cls || 'normal');
          GS.atks.push({ worldX: pr.x, worldY: pr.y, icon: 'üí•', sz: 22, life: 10, maxLife: 10, vx: 0, vy: 0 });
          GS.bossProjectiles.splice(i, 1);
        }
      }
      // Boss warnings
      for (let i = GS.bossWarnings.length - 1; i >= 0; i--) { GS.bossWarnings[i].life--; if (GS.bossWarnings[i].life <= 0) GS.bossWarnings.splice(i, 1); }
    }

    // ============================================================
    // PLAYER UPDATE
    // ============================================================
    function updPlayer() {
      const p = GS.p; if (GS.dlgActive) return;
      if (GS.timeStop && GS.timeStopTimer > 0) {
        // Slowed movement during time stop
        let mx = 0, my = 0;
        if (K['ArrowLeft'] || K['KeyA']) mx = -1; if (K['ArrowRight'] || K['KeyD']) mx = 1;
        if (K['ArrowUp'] || K['KeyW']) my = -1; if (K['ArrowDown'] || K['KeyS']) my = 1;
        if (p.vx !== 0 || p.vy !== 0) { mx = p.vx; my = p.vy; }
        if (mx !== 0 || my !== 0) { const mg = Math.sqrt(mx * mx + my * my); mx /= mg; my /= mg; }
        const { map } = GS.map; const slow = 0.4;
        let nx = p.x + mx * p.spd * slow, ny = p.y + my * p.spd * slow;
        if (!blk(nx, p.y, map)) p.x = nx; if (!blk(p.x, ny, map)) p.y = ny;
        GS.cam.x = lerp(GS.cam.x, p.x - canvas.width / 2, 0.1); GS.cam.y = lerp(GS.cam.y, p.y - canvas.height / 2, 0.1);
        GS.cam.x = Math.max(0, Math.min(WW - canvas.width, GS.cam.x)); GS.cam.y = Math.max(0, Math.min(WH - canvas.height, GS.cam.y));
        for (let i = 0; i < 4; i++)if (p.atkCDs[i] > 0) p.atkCDs[i]--;
        if (p.inv > 0) p.inv--;
        if (p.dashCD > 0) { p.dashCD--; updDashBtn(); }
        if (p.invincible) { p.invincibleTimer--; if (p.invincibleTimer <= 0) { p.invincible = false; updDashBtn(); } }
        return;
      }
      for (let i = 0; i < 4; i++)if (p.atkCDs[i] > 0) p.atkCDs[i]--;
      if (p.atkAnim > 0) p.atkAnim--; if (p.inv > 0) p.inv--;
      // Dash cooldown
      if (p.dashCD > 0) { p.dashCD--; updDashBtn(); }
      // Invincibilit√©
      if (p.invincible) {
        p.invincibleTimer--;
        if (p.invincibleTimer <= 0) { p.invincible = false; updDashBtn(); }
      }
      if (p.charging) { p.chargeTime++; if (p.chargeTime > 90) p.chargeTime = 90; }
      let mx = 0, my = 0;
      if (K['ArrowLeft'] || K['KeyA']) mx = -1; if (K['ArrowRight'] || K['KeyD']) mx = 1;
      if (K['ArrowUp'] || K['KeyW']) my = -1; if (K['ArrowDown'] || K['KeyS']) my = 1;
      if (p.vx !== 0 || p.vy !== 0) { mx = p.vx; my = p.vy; }
      if (mx !== 0 || my !== 0) { const mg = Math.sqrt(mx * mx + my * my); mx /= mg; my /= mg; p.fx = mx; p.fy = my; if (GS.frame % 8 === 0) sWalk(); }
      const { map } = GS.map;
      let nx = p.x + mx * p.spd, ny = p.y + my * p.spd;
      if (!blk(nx, p.y, map)) p.x = nx; if (!blk(p.x, ny, map)) p.y = ny;
      p.x = Math.max(TSIZ, Math.min(WW - TSIZ, p.x)); p.y = Math.max(TSIZ, Math.min(WH - TSIZ, p.y));
      if (LEVELS[curLvl].questType === 'collect') {
        const lv = LEVELS[curLvl];
        for (let i = 0; i < GS.qItems.length; i++) {
          const qi = GS.qItems[i];
          if (!qi.collected && dst(p, qi) < 38) {
            qi.collected = true; p.qItems++; sPick(); updHUD();
            const mi = Math.min(i, lv.questMsgs.length - 1); const msg = lv.questMsgs[mi];
            openDlg(msg[0], msg[1], msg.slice(2), null);
            if (p.qItems >= lv.questCount && !GS.bossSpawned) spawnBoss();
          }
        }
      }
      GS.cam.x = lerp(GS.cam.x, p.x - canvas.width / 2, 0.11); GS.cam.y = lerp(GS.cam.y, p.y - canvas.height / 2, 0.11);
      GS.cam.x = Math.max(0, Math.min(WW - canvas.width, GS.cam.x)); GS.cam.y = Math.max(0, Math.min(WH - canvas.height, GS.cam.y));
    }

    // ============================================================
    // RENDER MAP
    // ============================================================
    function renderMap() {
      const { cam, map: { map } } = GS;
      const sc = Math.max(0, Math.floor(cam.x / TSIZ) - 1), ec = Math.min(COLS - 1, Math.ceil((cam.x + canvas.width) / TSIZ) + 1);
      const sr = Math.max(0, Math.floor(cam.y / TSIZ) - 1), er = Math.min(ROWS - 1, Math.ceil((cam.y + canvas.height) / TSIZ) + 1);
      for (let r = sr; r <= er; r++)for (let c = sc; c <= ec; c++) {
        const px = Math.round(c * TSIZ - cam.x), py = Math.round(r * TSIZ - cam.y);
        C.drawImage(buildTile(map[r][c], tileFrame), px, py, TSIZ, TSIZ);
      }
    }

    // ============================================================
    // AMBIENT + DECOS ‚Äî pixel art par biome
    // ============================================================

    // ‚îÄ‚îÄ‚îÄ Particules ambiantes pixel art ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawAmbientParticle(ctx, sx, sy, type, sz, alpha) {
      ctx.save(); ctx.globalAlpha = alpha;
      const f = GS.frame;
      if (type === 'firefly') {
        // Luciole for√™t ‚Äî petit carr√© jaune-vert pulsant
        const p = (Math.sin(f * 0.18) + 1) / 2;
        ctx.fillStyle = `rgba(200,255,80,${0.6 + 0.4 * p})`;
        ctx.shadowColor = '#aaff44'; ctx.shadowBlur = 6 + p * 6;
        ctx.fillRect(sx - sz * 0.4, sy - sz * 0.4, sz * 0.8, sz * 0.8);
        // Trail
        ctx.shadowBlur = 0; ctx.globalAlpha *= 0.3;
        ctx.fillRect(sx - sz * 0.3, sy + sz * 0.3, sz * 0.5, sz * 0.3);
      } else if (type === 'leaf_fall') {
        // Feuille qui tombe ‚Äî losange vert pivotant
        const rot = f * 0.04;
        ctx.translate(sx, sy); ctx.rotate(rot);
        ctx.fillStyle = `rgba(${60 + Math.floor(Math.random()*20)},160,60,0.8)`;
        ctx.fillRect(-sz * 0.4, -sz * 0.15, sz * 0.8, sz * 0.3);
        ctx.fillRect(-sz * 0.15, -sz * 0.4, sz * 0.3, sz * 0.8);
      } else if (type === 'spark') {
        // √âtincelle ch√¢teau ‚Äî pixel blanc-bleu
        ctx.fillStyle = '#aabbff';
        ctx.shadowColor = '#6688ff'; ctx.shadowBlur = 8;
        ctx.fillRect(sx - 1, sy - 1, 2, 2);
        // croisillon
        ctx.fillRect(sx - 3, sy, 6, 1); ctx.fillRect(sx, sy - 3, 1, 6);
      } else if (type === 'candle') {
        // Flamme chandelle ch√¢teau
        const flicker = Math.sin(f * 0.3 + sz) * 2;
        ctx.fillStyle = '#ffaa00'; ctx.fillRect(sx - 2, sy - 4 + flicker, 4, 6);
        ctx.fillStyle = '#ffee44'; ctx.fillRect(sx - 1, sy - 6 + flicker, 2, 4);
        ctx.fillStyle = 'rgba(255,150,0,0.3)'; ctx.fillRect(sx - 4, sy - 4 + flicker, 8, 8);
      } else if (type === 'snowflake') {
        // Flocon montagne
        ctx.strokeStyle = `rgba(200,230,255,0.8)`; ctx.lineWidth = 1;
        for (let a = 0; a < Math.PI * 2; a += Math.PI / 3) {
          ctx.beginPath();
          ctx.moveTo(sx, sy);
          ctx.lineTo(sx + Math.cos(a) * sz * 0.6, sy + Math.sin(a) * sz * 0.6);
          ctx.stroke();
        }
        ctx.fillStyle = 'rgba(220,240,255,0.9)'; ctx.fillRect(sx - 1, sy - 1, 2, 2);
      } else if (type === 'ice_crystal') {
        // Cristal de glace flottant
        ctx.fillStyle = `rgba(140,200,255,${0.4 + 0.3 * Math.sin(f * 0.07)})`;
        ctx.save(); ctx.translate(sx, sy); ctx.rotate(f * 0.02);
        ctx.fillRect(-sz * 0.5, -1, sz, 2); ctx.fillRect(-1, -sz * 0.5, 2, sz);
        ctx.restore();
      }
      ctx.restore();
    }

    function renderAmbient() {
      const { cam, ambient } = GS;
      const biome = LEVELS[curLvl].biome;
      for (const p of ambient) {
        p.y -= p.spd * 0.3; if (p.y < 0) p.y = WH;
        p.x += Math.sin(GS.frame * 0.01 + p.off) * 0.3;
        const sx = p.x - cam.x, sy = p.y - cam.y;
        if (sx < -30 || sx > canvas.width + 30 || sy < -30 || sy > canvas.height + 30) continue;
        const a = p.alpha * (0.5 + 0.5 * Math.sin(GS.frame * 0.03 + p.off));
        // Choisir le type selon le biome et l'index
        const types = biome === 'forest'
          ? ['firefly', 'leaf_fall']
          : biome === 'castle'
            ? ['spark', 'candle']
            : ['snowflake', 'ice_crystal'];
        const type = types[Math.floor(p.off * 100) % 2];
        drawAmbientParticle(C, sx, sy, type, p.sz, a);
      }
    }

    // ‚îÄ‚îÄ‚îÄ D√©cors pixel art par biome ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawDecoForest(ctx, sx, sy, bob, scale) {
      const s = Math.max(1, Math.round(scale * TSIZ * 0.75 / 16));
      const t = GS.frame;
      const variant = Math.floor((sx * 7 + sy * 13) % 5);
      if (variant === 0) {
        // Champignon
        ctx.fillStyle = '#cc3333'; ctx.beginPath(); ctx.arc(sx, sy - s * 3 + bob, s * 3, Math.PI, 0); ctx.fill();
        ctx.fillStyle = '#ff6666'; ctx.fillRect(sx - s, sy - s * 3 + bob, s, s); ctx.fillRect(sx + s, sy - s * 4 + bob, s, s);
        ctx.fillStyle = '#e8d0b0'; ctx.fillRect(sx - s, sy - s * 3 + bob, s * 2, s * 4);
        ctx.fillStyle = '#c0a888'; ctx.fillRect(sx - s * 2, sy + bob, s * 4, s);
      } else if (variant === 1) {
        // Fleur rose
        for (let i = 0; i < 5; i++) {
          const a = (i / 5) * Math.PI * 2 + t * 0.01;
          ctx.fillStyle = i % 2 === 0 ? '#ff88aa' : '#ffaabb';
          ctx.fillRect(sx + Math.cos(a) * s * 2 - s, sy - s * 3 + Math.sin(a) * s * 2 + bob, s * 2, s * 2);
        }
        ctx.fillStyle = '#ffee44'; ctx.fillRect(sx - s, sy - s * 3 - s + bob, s * 2, s * 2);
        ctx.fillStyle = '#2a8040'; ctx.fillRect(sx, sy - s * 2 + bob, s, s * 3);
      } else if (variant === 2) {
        // Rocher moussu
        ctx.fillStyle = '#5a5a4a'; ctx.fillRect(sx - s * 3, sy - s * 2 + bob, s * 6, s * 3);
        ctx.fillStyle = '#6a6a58'; ctx.fillRect(sx - s * 2, sy - s * 3 + bob, s * 4, s);
        ctx.fillStyle = '#2a8040'; ctx.fillRect(sx - s * 3, sy - s * 3 + bob, s * 3, s);
        ctx.fillRect(sx + s, sy - s * 4 + bob, s * 2, s);
        ctx.fillStyle = 'rgba(255,255,255,0.18)'; ctx.fillRect(sx - s * 2, sy - s * 3 + bob, s * 2, s);
      } else if (variant === 3) {
        // Petit arbre touffu
        ctx.fillStyle = '#4a2e10'; ctx.fillRect(sx - s, sy + bob, s * 2, s * 4);
        ctx.fillStyle = '#1a5010'; ctx.fillRect(sx - s * 4, sy - s * 5 + bob, s * 8, s * 6);
        ctx.fillStyle = '#2a7020'; ctx.fillRect(sx - s * 3, sy - s * 7 + bob, s * 6, s * 4);
        ctx.fillStyle = '#3a9030'; ctx.fillRect(sx - s * 2, sy - s * 8 + bob, s * 4, s * 3);
        ctx.fillStyle = '#1a4010'; ctx.fillRect(sx - s * 2, sy - s * 4 + bob, s * 4, s);
      } else {
        // Buisson baies
        ctx.fillStyle = '#1a5010'; ctx.fillRect(sx - s * 3, sy - s * 3 + bob, s * 6, s * 4);
        ctx.fillStyle = '#2a7020'; ctx.fillRect(sx - s * 2, sy - s * 4 + bob, s * 4, s * 2);
        // Baies rouges
        for (let i = 0; i < 4; i++) {
          ctx.fillStyle = '#cc2222';
          ctx.beginPath(); ctx.arc(sx - s * 2 + i * s * 1.3, sy - s * 2 + bob, s * 0.8, 0, Math.PI * 2); ctx.fill();
        }
      }
    }

    function drawDecoCastle(ctx, sx, sy, bob, scale) {
      const s = Math.max(1, Math.round(scale * TSIZ * 0.75 / 16));
      const t = GS.frame;
      const variant = Math.floor((sx * 11 + sy * 7) % 5);
      if (variant === 0) {
        // Chandelier mural
        ctx.fillStyle = '#888'; ctx.fillRect(sx - s * 2, sy - s * 6 + bob, s * 4, s);
        ctx.fillStyle = '#c8a020'; ctx.fillRect(sx - s * 2, sy - s * 6 + bob, s * 4, s * 2);
        // 3 bougies
        for (let i = 0; i < 3; i++) {
          const cx = sx - s * 2 + i * s * 2;
          ctx.fillStyle = '#f0d080'; ctx.fillRect(cx - s * 0.5, sy - s * 4 + bob, s, s * 3);
          const flicker = Math.sin(t * 0.3 + i) * 1;
          ctx.fillStyle = '#ffaa00'; ctx.fillRect(cx - s * 0.5, sy - s * 5 + bob + flicker, s, s * 1.5);
          ctx.fillStyle = '#ffee44'; ctx.fillRect(cx - s * 0.3, sy - s * 6 + bob + flicker, s * 0.6, s);
          ctx.fillStyle = `rgba(255,160,0,${0.2 + 0.1 * Math.sin(t * 0.3 + i)})`;
          ctx.beginPath(); ctx.arc(cx, sy - s * 5 + bob + flicker, s * 2, 0, Math.PI * 2); ctx.fill();
        }
      } else if (variant === 1) {
        // Cr√¢ne d√©coratif
        ctx.fillStyle = '#c8c0a8';
        ctx.fillRect(sx - s * 2, sy - s * 4 + bob, s * 4, s * 4);
        ctx.fillRect(sx - s * 3, sy - s * 2 + bob, s * 6, s * 2);
        ctx.fillStyle = '#000'; ctx.fillRect(sx - s * 2, sy - s * 3 + bob, s, s * 2); ctx.fillRect(sx + s, sy - s * 3 + bob, s, s * 2);
        ctx.fillStyle = '#c8c0a8'; ctx.fillRect(sx - s * 2, sy + bob, s, s * 2); ctx.fillRect(sx, sy + bob, s, s * 2); ctx.fillRect(sx + s * 2, sy + bob, s, s * 2);
        ctx.fillStyle = '#aaa'; ctx.fillRect(sx - s * 2, sy - s * 5 + bob, s, s * 2); ctx.fillRect(sx + s, sy - s * 5 + bob, s, s * 2);
      } else if (variant === 2) {
        // Coffre
        ctx.fillStyle = '#6a4010'; ctx.fillRect(sx - s * 3, sy - s * 2 + bob, s * 6, s * 4);
        ctx.fillStyle = '#c8a020'; ctx.fillRect(sx - s * 3, sy - s * 2 + bob, s * 6, s);
        ctx.fillRect(sx - s * 3, sy - s * 2 + bob, s, s * 4);
        ctx.fillRect(sx + s * 2, sy - s * 2 + bob, s, s * 4);
        ctx.fillRect(sx - s * 3, sy + s + bob, s * 6, s);
        ctx.fillStyle = '#ffd700'; ctx.fillRect(sx - s, sy - s + bob, s * 2, s * 2);
        ctx.fillStyle = '#ffee88'; ctx.fillRect(sx - s * 0.5, sy - s * 0.5 + bob, s, s);
      } else if (variant === 3) {
        // Torche murale
        ctx.fillStyle = '#6a4010'; ctx.fillRect(sx - s, sy - s * 6 + bob, s * 2, s * 5);
        ctx.fillStyle = '#888'; ctx.fillRect(sx - s * 2, sy - s * 8 + bob, s * 4, s * 2);
        const fl = Math.sin(t * 0.25) * 1.5;
        ctx.fillStyle = '#ff6600'; ctx.fillRect(sx - s, sy - s * 10 + bob + fl, s * 2, s * 3);
        ctx.fillStyle = '#ffaa00'; ctx.fillRect(sx - s * 0.5, sy - s * 12 + bob + fl, s, s * 3);
        ctx.fillStyle = '#ffee44'; ctx.fillRect(sx - s * 0.3, sy - s * 13 + bob + fl, s * 0.6, s * 2);
        ctx.fillStyle = `rgba(255,120,0,${0.2 + 0.1 * Math.abs(fl)})`;
        ctx.beginPath(); ctx.arc(sx, sy - s * 10 + bob + fl, s * 3, 0, Math.PI * 2); ctx.fill();
      } else {
        // Banni√®re royale
        ctx.fillStyle = '#333'; ctx.fillRect(sx - s * 0.5, sy - s * 8 + bob, s, s * 8);
        ctx.fillStyle = '#8800aa'; ctx.fillRect(sx, sy - s * 7 + bob, s * 4, s * 5);
        ctx.fillStyle = '#aa00cc'; ctx.fillRect(sx + s, sy - s * 6 + bob, s * 2, s * 3);
        ctx.fillStyle = '#ffd700'; ctx.fillRect(sx + s, sy - s * 5 + bob, s * 2, s);
        // Bas frang√©
        for (let i = 0; i < 4; i++) { ctx.fillStyle = '#6600aa'; ctx.fillRect(sx + i * s, sy - s * 2 + bob, s * 0.6, s * 2); }
      }
    }

    function drawDecoMountain(ctx, sx, sy, bob, scale) {
      const s = Math.max(1, Math.round(scale * TSIZ * 0.75 / 16));
      const t = GS.frame;
      const variant = Math.floor((sx * 9 + sy * 17) % 5);
      if (variant === 0) {
        // Cristal de glace
        ctx.fillStyle = '#88ccff'; ctx.fillRect(sx - s, sy - s * 6 + bob, s * 2, s * 6);
        ctx.fillStyle = '#aaddff'; ctx.fillRect(sx - s * 2, sy - s * 4 + bob, s * 4, s * 2);
        // Pointe
        ctx.fillStyle = '#cceeFF';
        ctx.beginPath(); ctx.moveTo(sx, sy - s * 7 + bob); ctx.lineTo(sx - s, sy - s * 6 + bob); ctx.lineTo(sx + s, sy - s * 6 + bob); ctx.closePath(); ctx.fill();
        // Reflet
        const glow = ctx.createLinearGradient(sx, sy - s * 7 + bob, sx, sy + bob);
        glow.addColorStop(0, 'rgba(200,240,255,0.6)'); glow.addColorStop(1, 'rgba(100,180,255,0.1)');
        ctx.fillStyle = glow; ctx.fillRect(sx - s * 2, sy - s * 6 + bob, s, s * 6);
      } else if (variant === 1) {
        // Cairn (empilement de pierres)
        const sizes = [4, 3, 2.5, 1.5];
        for (let i = 0; i < sizes.length; i++) {
          const w = sizes[i] * s; const y = sy + bob - i * s * 2;
          ctx.fillStyle = i % 2 === 0 ? '#7a7a8a' : '#8a8a9a';
          ctx.fillRect(sx - w, y - s * 2, w * 2, s * 2);
          ctx.fillStyle = 'rgba(255,255,255,0.12)'; ctx.fillRect(sx - w, y - s * 2, w * 2, s * 0.5);
        }
      } else if (variant === 2) {
        // Stalactite / stalagmite
        ctx.fillStyle = '#9090a0';
        // stalagmite bas
        ctx.beginPath(); ctx.moveTo(sx - s * 2, sy + bob); ctx.lineTo(sx, sy - s * 5 + bob); ctx.lineTo(sx + s * 2, sy + bob); ctx.closePath(); ctx.fill();
        ctx.fillStyle = '#b0b0c0'; ctx.beginPath(); ctx.moveTo(sx - s, sy + bob); ctx.lineTo(sx, sy - s * 4 + bob); ctx.lineTo(sx + s, sy + bob); ctx.closePath(); ctx.fill();
        ctx.fillStyle = 'rgba(200,220,255,0.3)'; ctx.fillRect(sx - s * 0.5, sy - s * 4 + bob, s * 0.5, s * 4);
      } else if (variant === 3) {
        // Ruines enneig√©es
        ctx.fillStyle = '#6a6a7a'; ctx.fillRect(sx - s * 3, sy + bob, s * 6, s * 2);
        ctx.fillRect(sx - s * 3, sy - s * 5 + bob, s * 2, s * 5);
        ctx.fillRect(sx + s, sy - s * 4 + bob, s * 2, s * 4);
        // Neige sur le dessus
        ctx.fillStyle = '#e8f4ff'; ctx.fillRect(sx - s * 3, sy - s * 5 + bob, s * 6, s);
        ctx.fillRect(sx - s * 3, sy + bob, s * 6, s * 0.5);
        ctx.fillStyle = '#ffffff'; ctx.fillRect(sx - s * 3, sy - s * 5 + bob, s * 2, s * 0.5);
        ctx.fillRect(sx + s, sy - s * 4 + bob, s * 2, s * 0.5);
      } else {
        // Ossements anciens
        ctx.fillStyle = '#d4ccb0';
        // cr√¢ne
        ctx.fillRect(sx - s * 2, sy - s * 4 + bob, s * 4, s * 3);
        ctx.fillRect(sx - s * 3, sy - s * 2 + bob, s * 6, s);
        ctx.fillStyle = '#000'; ctx.fillRect(sx - s * 2, sy - s * 3 + bob, s, s); ctx.fillRect(sx + s, sy - s * 3 + bob, s, s);
        // Os crois√©s
        ctx.fillStyle = '#c8c0a8';
        ctx.save(); ctx.translate(sx, sy + s * 2 + bob); ctx.rotate(0.4);
        ctx.fillRect(-s * 4, -s * 0.5, s * 8, s); ctx.restore();
        ctx.save(); ctx.translate(sx, sy + s * 2 + bob); ctx.rotate(-0.4);
        ctx.fillRect(-s * 4, -s * 0.5, s * 8, s); ctx.restore();
      }
    }

    function renderDecos() {
      const { cam, decos } = GS;
      const biome = LEVELS[curLvl].biome;
      for (const d of decos) {
        const sx = d.x - cam.x, sy = d.y - cam.y;
        if (sx < -TSIZ * 3 || sx > canvas.width + TSIZ * 3 || sy < -TSIZ * 3 || sy > canvas.height + TSIZ * 3) continue;
        const bob = Math.sin(GS.frame * 0.022 + d.off) * 1.5;
        C.save(); C.globalAlpha = 0.85;
        if (biome === 'forest') drawDecoForest(C, sx, sy, bob, d.scale);
        else if (biome === 'castle') drawDecoCastle(C, sx, sy, bob, d.scale);
        else drawDecoMountain(C, sx, sy, bob, d.scale);
        C.restore();
      }
    }

    // ============================================================
    // QUEST ITEMS
    // ============================================================
    function renderQItems() {
      const { cam, qItems } = GS; const lv = LEVELS[curLvl];
      C.textAlign = 'center'; C.textBaseline = 'middle';
      for (const qi of qItems) {
        if (qi.collected) continue;
        const sx = qi.x - cam.x, sy = qi.y - cam.y;
        if (Math.abs(sx) > canvas.width / 2 + 80 || Math.abs(sy) > canvas.height / 2 + 80) continue;
        const bob = Math.sin(GS.frame * 0.07 + qi.x) * 6;
        const ag = C.createRadialGradient(sx, sy + bob, 0, sx, sy + bob, 30);
        ag.addColorStop(0, 'rgba(255,215,0,0.4)'); ag.addColorStop(1, 'transparent');
        C.fillStyle = ag; C.beginPath(); C.arc(sx, sy + bob, 30, 0, Math.PI * 2); C.fill();
        C.save(); C.shadowColor = '#ffd700'; C.shadowBlur = 22;
        // Dessin pixel art selon le type d'objet de qu√™te
        const qi2 = lv.questItem;
        if (qi2 === 'ü•á') {
          // M√©daillon dor√©
          C.fillStyle = '#ffd700'; C.beginPath(); C.arc(sx, sy+bob, 10, 0, Math.PI*2); C.fill();
          C.fillStyle = '#cc8800'; C.beginPath(); C.arc(sx, sy+bob, 10, 0, Math.PI*2); C.stroke();
          C.strokeStyle = '#cc8800'; C.lineWidth = 2; C.stroke();
          C.fillStyle = '#ffee88'; C.fillRect(sx-3, sy+bob-4, 6, 8);
          C.fillStyle = '#cc8800'; C.fillRect(sx-1, sy+bob-6, 2, 3);
          C.fillStyle = '#ffee88'; C.fillRect(sx-1, sy+bob-1, 2, 2);
        } else if (qi2 === 'üíÄ') {
          // Cr√¢ne (pour les kills)
          C.fillStyle = '#e8e0c8';
          C.fillRect(sx-7, sy+bob-8, 14, 12);
          C.fillRect(sx-5, sy+bob-10, 10, 5);
          C.fillStyle = '#000'; C.fillRect(sx-5, sy+bob-8, 4, 4); C.fillRect(sx+1, sy+bob-8, 4, 4);
          C.fillStyle = '#e8e0c8'; C.fillRect(sx-4, sy+bob+3, 2, 3); C.fillRect(sx-1, sy+bob+3, 2, 3); C.fillRect(sx+2, sy+bob+3, 2, 3);
        } else if (qi2 === '‚≠ê') {
          // √âtoile or 5 branches
          C.fillStyle = '#ffd700';
          const starR = 12, starr = 5;
          C.beginPath();
          for(let i=0;i<10;i++){
            const r2 = i%2===0?starR:starr;
            const a = (i/10)*Math.PI*2 - Math.PI/2;
            if(i===0) C.moveTo(sx+Math.cos(a)*r2, sy+bob+Math.sin(a)*r2);
            else C.lineTo(sx+Math.cos(a)*r2, sy+bob+Math.sin(a)*r2);
          }
          C.closePath(); C.fill();
          C.fillStyle = '#ffe066'; C.fillRect(sx-2, sy+bob-4, 4, 4);
        } else {
          // Fallback g√©n√©rique : diamant brillant
          C.fillStyle = '#aaddff';
          C.beginPath(); C.moveTo(sx, sy+bob-10); C.lineTo(sx+8, sy+bob); C.lineTo(sx, sy+bob+10); C.lineTo(sx-8, sy+bob); C.closePath(); C.fill();
          C.fillStyle = '#fff'; C.fillRect(sx-2, sy+bob-5, 3, 3);
        }
        C.restore();
      }
    }

    // ============================================================
    // BOSS WARNINGS RENDER
    // ============================================================
    function renderBossWarnings() {
      const { cam } = GS;
      for (const w of GS.bossWarnings) {
        const sx = w.x - cam.x, sy = w.y - cam.y;
        const alpha = (w.life / w.maxLife) * 0.75;
        const pulse = Math.sin(GS.frame * 0.4) * 0.3;
        C.save();
        if (w.type === 'slam_zone') {
          // Aerial slam danger zone ‚Äî filled red circle + concentric rings
          const a = Math.max(0, alpha * 0.55 + pulse * 0.2);
          const rg = C.createRadialGradient(sx, sy, 0, sx, sy, w.r);
          rg.addColorStop(0, `rgba(255,60,0,${a * 0.6})`); rg.addColorStop(0.7, `rgba(255,20,0,${a * 0.3})`); rg.addColorStop(1, 'transparent');
          C.fillStyle = rg; C.beginPath(); C.arc(sx, sy, w.r, 0, Math.PI * 2); C.fill();
          C.strokeStyle = w.color; C.lineWidth = 4; C.globalAlpha = a + 0.2;
          C.shadowColor = '#ff0000'; C.shadowBlur = 18;
          C.setLineDash([8, 4]); C.beginPath(); C.arc(sx, sy, w.r, 0, Math.PI * 2); C.stroke();
          C.setLineDash([]);
          // Inner target cross
          C.strokeStyle = `rgba(255,200,0,${a + 0.1})`; C.lineWidth = 2; C.shadowBlur = 10;
          C.beginPath(); C.moveTo(sx - 16, sy); C.lineTo(sx + 16, sy); C.stroke();
          C.beginPath(); C.moveTo(sx, sy - 16); C.lineTo(sx, sy + 16); C.stroke();
        } else if (w.type === 'warn_zone') {
          // Boss 2 approach warning ‚Äî pulsing orange ring
          C.strokeStyle = w.color; C.lineWidth = 4; C.globalAlpha = (alpha + pulse) * 0.8;
          C.shadowColor = w.color; C.shadowBlur = 20;
          C.setLineDash([12, 8]);
          C.beginPath(); C.arc(sx, sy, w.r, 0, Math.PI * 2); C.stroke();
          C.setLineDash([]);
          // "DANGER" text pulsing
          if (Math.floor(GS.frame / 6) % 2 === 0) {
            C.globalAlpha = 0.9; C.fillStyle = '#ff8800'; C.shadowBlur = 12;
            C.font = '7px "Press Start 2P"'; C.textAlign = 'center'; C.textBaseline = 'middle';
            C.fillText('‚ö† DANGER ‚ö†', sx, sy - w.r - 12);
          }
        } else if (w.type === 'beam_warn') {
          // Directional warning ‚Äî shows beam trajectory before it fires
          const blink = Math.floor(GS.frame / 5) % 2 === 0;
          if (blink) {
            C.globalAlpha = (alpha + pulse) * 0.7;
            C.strokeStyle = '#ff2200'; C.lineWidth = 6; C.shadowColor = '#ff0000'; C.shadowBlur = 20;
            C.setLineDash([14, 8]);
            C.beginPath(); C.moveTo(sx, sy);
            C.lineTo(sx + Math.cos(w.angle) * w.r, sy + Math.sin(w.angle) * w.r);
            C.stroke(); C.setLineDash([]);
            // "LASER" label
            C.font = '7px "Press Start 2P"'; C.fillStyle = '#ff4400'; C.textAlign = 'center'; C.textBaseline = 'middle';
            C.fillText('‚ö° LASER ‚ö°', sx + Math.cos(w.angle) * w.r * 0.5, sy + Math.sin(w.angle) * w.r * 0.5 - 14);
          }
        } else if (w.type === 'circle') {
          C.strokeStyle = w.color; C.lineWidth = 3; C.globalAlpha = alpha + pulse;
          C.shadowColor = w.color; C.shadowBlur = 12;
          C.setLineDash([6, 4]);
          C.beginPath(); C.arc(sx, sy, w.r, 0, Math.PI * 2); C.stroke();
          C.setLineDash([]);
        } else {
          C.strokeStyle = w.color; C.lineWidth = 2; C.globalAlpha = alpha + pulse;
          C.shadowColor = w.color; C.shadowBlur = 10;
          C.beginPath(); C.arc(sx, sy, w.r, 0, Math.PI * 2); C.stroke();
        }
        C.restore();
      }
    }

    // ============================================================
    // BOSS BEAM RENDER
    // ============================================================
    function renderBossBeam() {
      const { boss, cam } = GS; if (!boss || !boss.beamActive || boss.beamTimer <= 0) return;
      const sx = boss.x - cam.x, sy = boss.y - cam.y;
      const len = 500;
      const ex = sx + Math.cos(boss.beamAngle) * len, ey = sy + Math.sin(boss.beamAngle) * len;
      const alpha = Math.min(1, boss.beamTimer / 15);
      C.save();
      // Outer glow
      C.globalAlpha = alpha * 0.25; C.strokeStyle = '#ff4400'; C.lineWidth = 28; C.shadowColor = '#ff4400'; C.shadowBlur = 30;
      C.beginPath(); C.moveTo(sx, sy); C.lineTo(ex, ey); C.stroke();
      // Core
      C.globalAlpha = alpha * 0.9; C.strokeStyle = '#fff'; C.lineWidth = 4; C.shadowBlur = 15;
      C.beginPath(); C.moveTo(sx, sy); C.lineTo(ex, ey); C.stroke();
      C.restore();
    }

    // ============================================================
    // MONSTERS RENDER
    // ============================================================
    function renderMons() {
      const { cam, mons, boss } = GS; const all = [...mons]; if (boss) all.push(boss);
      for (const m of all) {
        if (m.state === 'dead') continue;
        const sx = m.x - cam.x, sy = m.y - cam.y;
        if (sx < -140 || sx > canvas.width + 140 || sy < -140 || sy > canvas.height + 140) continue;
        const dying = m.state === 'dying';
        const alpha = dying ? Math.max(0, m.dyingTimer / 22) : 1;
        const bob = dying ? 0 : Math.sin(GS.frame * 0.07 + m.x * 0.01) * 2;

        C.save();
        C.globalAlpha = alpha;
        if (m.hitFlash > 0) C.filter = 'brightness(3.5) saturate(0)';

        const frame = getMonFrame(m);
        const dir = getMonDir(m);

        if (m.boss) {
          // ‚îÄ‚îÄ BOSS ‚îÄ‚îÄ
          const aerialOff = m.aerialYOff || 0;
          const lvlType = getBossType(curLvl);

          if (m.boss && aerialOff < -10) {
            // ombre au sol pendant le vol
            C.save();
            C.globalAlpha *= (0.15 + 0.3 * (1 - Math.abs(aerialOff) / 80));
            C.filter = 'blur(6px) brightness(0)';
            C.translate(sx + 5, sy + 8 + bob);
            C.scale(1, 0.3);
            if (lvlType === 'demon') drawDemon(C, 0, 0, dir, frame, 2.8, 1, m.rageMode);
            else if (lvlType === 'king') drawKingDoubt(C, 0, 0, dir, frame, 2.8, 1, m.rageMode);
            else drawDragon(C, 0, 0, dir, frame, 3.0, 1, m.rageMode, 0);
            C.restore();
          }

          if (lvlType === 'demon') drawDemon(C, sx, sy + bob + aerialOff, dir, frame, 2.8, 1, m.rageMode);
          else if (lvlType === 'king') drawKingDoubt(C, sx, sy + bob + aerialOff, dir, frame, 2.8, 1, m.rageMode);
          else drawDragon(C, sx, sy + bob, dir, frame, 3.0, 1, m.rageMode, aerialOff);

          // Aura boss
          C.save(); C.globalAlpha = alpha * (m.rageMode ? 0.35 : 0.18);
          const rageT = m.rageMode ? 0.22 : 0;
          const bg = C.createRadialGradient(sx, sy, 5, sx, sy, 70);
          bg.addColorStop(0, `rgba(255,${m.rageMode ? 30 : 80},50,${0.18 + rageT})`);
          bg.addColorStop(1, 'transparent');
          C.fillStyle = bg; C.beginPath(); C.arc(sx, sy, 70, 0, Math.PI * 2); C.fill();
          C.restore();

          if (m.rageMode) {
            C.save(); C.globalAlpha = alpha * 0.6; C.strokeStyle = '#ff2200'; C.lineWidth = 3;
            C.shadowColor = '#ff2200'; C.shadowBlur = 18;
            C.beginPath(); C.arc(sx, sy, 60 + Math.sin(GS.frame * 0.2) * 5, 0, Math.PI * 2); C.stroke();
            C.restore();
          }

        } else {
          // ‚îÄ‚îÄ MONSTRES NORMAUX ‚îÄ‚îÄ
          const type = getMonsterType(m);
          if (type === 'wolf') drawWolf(C, sx, sy + bob, dir, frame, 1.8, 1);
          else if (type === 'bat') drawBat(C, sx, sy + bob, frame % 2, 1.5, 1);
          else if (type === 'spider') drawSpider(C, sx, sy + bob, frame % 2, 1.5, 1);
          else if (type === 'leaf') drawLeafMonster(C, sx, sy + bob, frame % 2, 1.7, 1);
          else if (type === 'skeleton') drawSkeleton(C, sx, sy + bob, dir, frame, 1.8, 1);
          else if (type === 'zombie') drawZombie(C, sx, sy + bob, dir, frame, 1.8, 1);
          else if (type === 'ghost') drawGhost(C, sx, sy + bob, frame % 2, 1.7, 1);
          else if (type === 'knight') drawKnight(C, sx, sy + bob, dir, frame, 1.8, 1);
          else if (type === 'iceGiant') drawIceGiant(C, sx, sy + bob, dir, frame, 2.0, 1);
          else if (type === 'griffon') drawGriffon(C, sx, sy + bob, dir, frame, 1.7, 1);
          else if (type === 'golem') drawGolem(C, sx, sy + bob, dir, frame, 2.0, 1);
          else if (type === 'elemental') drawElemental(C, sx, sy + bob, frame % 2, 1.7, 1);
          else {
            // fallback absolu (ne devrait pas arriver)
            C.textAlign = 'center'; C.textBaseline = 'middle';
            C.font = '20px serif'; C.fillStyle='#fff'; C.fillText('?', sx, sy + bob);
          }
        }

        C.restore();

        // HP bar
        if (!dying && m.hp < m.maxHp) {
          const bw = m.boss ? 72 : 38, bh = m.boss ? 9 : 5;
          const bx = sx - bw / 2, by = sy - (m.boss ? 55 : 28);
          C.fillStyle = 'rgba(0,0,0,0.8)'; C.fillRect(bx - 1, by - 1, bw + 2, bh + 2);
          C.fillStyle = '#2a0000'; C.fillRect(bx, by, bw, bh);
          const pct = m.hp / m.maxHp;
          C.fillStyle = pct > 0.6 ? '#44ff44' : pct > 0.3 ? '#ffaa00' : '#ff2222';
          C.fillRect(bx, by, bw * pct, bh);
          C.fillStyle = 'rgba(255,255,255,0.18)'; C.fillRect(bx, by, bw * pct, bh / 2);
          if (m.boss) {
            C.save(); C.font = '6px "Press Start 2P"';
            C.fillStyle = m.rageMode ? '#ff4444' : '#ff8888';
            C.textAlign = 'center';
            C.fillText(m.name + (m.rageMode ? ' ‚ö°RAGE' : m.phase > 0 ? ` P${m.phase + 1}` : ''), sx, sy - 68);
            C.restore();
          }
        }
      }
    }

    // ============================================================
    // PLAYER RENDER
    // ============================================================
    function renderPlayer() {
      const { p, cam } = GS;
      const sx = p.x - cam.x, sy = p.y - cam.y;
      const moving = Math.abs(p.vx) > 0.05 || Math.abs(p.vy) > 0.05 || K['ArrowLeft'] || K['ArrowRight'] || K['ArrowUp'] || K['ArrowDown'] || K['KeyA'] || K['KeyD'] || K['KeyW'] || K['KeyS'];
      const bob = moving ? Math.sin(GS.frame * 0.3) * 3 : 0;
      C.save();
      // Invincibilit√© dash ‚Äî clignotement rapide + aura cyan
      if (p.invincible) {
        if (Math.floor(GS.frame / 2) % 2 === 0) C.globalAlpha = 0.15;
        C.save();
        const ia = C.createRadialGradient(sx, sy, 4, sx, sy, 38);
        ia.addColorStop(0, 'rgba(0,255,200,0.45)'); ia.addColorStop(1, 'transparent');
        C.fillStyle = ia; C.beginPath(); C.arc(sx, sy, 38, 0, Math.PI * 2); C.fill();
        C.strokeStyle = 'rgba(0,255,200,0.7)'; C.lineWidth = 2.5;
        C.beginPath(); C.arc(sx, sy, 30 + Math.sin(GS.frame * 0.4) * 4, 0, Math.PI * 2); C.stroke();
        C.restore();
      } else if (p.inv > 0 && Math.floor(GS.frame / 3) % 2 === 0) {
        C.globalAlpha = 0.22;
      }
      // Time stop aura
      if (GS.timeStop) {
        C.save(); C.globalAlpha = 0.3 + Math.sin(GS.frame * 0.2) * 0.1; C.strokeStyle = '#8888ff'; C.lineWidth = 3;
        C.beginPath(); C.arc(sx, sy, 28, 0, Math.PI * 2); C.stroke(); C.restore();
      }
      // Attack arc
      if (p.atkAnim > 0) {
        const prog = 1 - p.atkAnim / 14, angle = Math.atan2(p.fy, p.fx);
        C.save(); C.globalAlpha = 0.7 * (1 - prog); C.strokeStyle = '#ffd700'; C.lineWidth = 7;
        C.shadowColor = '#ffd700'; C.shadowBlur = 18;
        C.beginPath(); C.arc(sx, sy, 48, angle - 1.0, angle + 1.0); C.stroke();
        C.strokeStyle = 'rgba(255,255,255,0.35)'; C.lineWidth = 2.5;
        C.beginPath(); C.arc(sx, sy, 48, angle - 1.0, angle + 1.0); C.stroke(); C.restore();
      }
      // Spin ring
      if (GS.spinAnim && GS.spinAnim.timer > 0) {
        const prog = GS.spinAnim.timer / GS.spinAnim.maxTimer;
        C.save(); C.globalAlpha = 0.5 * prog; C.strokeStyle = '#cc44ff'; C.lineWidth = 5;
        C.shadowColor = '#cc44ff'; C.shadowBlur = 20;
        C.beginPath(); C.arc(sx, sy, 55, 0, Math.PI * 2); C.stroke(); C.restore();
        GS.spinAnim.timer--;
      }
      // Charge aura
      if (p.charging && p.chargeTime > 0) {
        const ch = p.chargeTime / 90;
        const cg = C.createRadialGradient(sx, sy, 5, sx, sy, 32 + ch * 22);
        cg.addColorStop(0, `rgba(255,200,50,${0.45 * ch})`); cg.addColorStop(1, 'transparent');
        C.fillStyle = cg; C.beginPath(); C.arc(sx, sy, 52 + ch * 22, 0, Math.PI * 2); C.fill();
      }
      // Glow
      const glow = C.createRadialGradient(sx, sy + bob, 0, sx, sy + bob, 34);
      glow.addColorStop(0, `rgba(100,200,255,${0.12 + 0.05 * Math.sin(GS.frame * 0.05)})`); glow.addColorStop(1, 'transparent');
      C.fillStyle = glow; C.beginPath(); C.arc(sx, sy + bob, 34, 0, Math.PI * 2); C.fill();
      // Sprite sorcier pixel art
      const pdir = getPlayerDir(p);
      // scale up slightly if dying ‚Äî non (no dying state for player), just draw
      drawWizard(C, sx, sy + bob, pdir, p.atkAnim > 0 ? (Math.floor(GS.frame/4)%3) : (Math.floor(GS.frame/10)%3), 2.4);
      C.restore();
    }

    // ============================================================
    // ATTACK FX
    // ============================================================
    function renderAtks() {
      const { cam, atks } = GS;
      for (let i = atks.length - 1; i >= 0; i--) {
        const a = atks[i]; a.life--; if (a.life <= 0) { atks.splice(i, 1); continue; }
        const prog = (a.maxLife - a.life) / a.maxLife;
        const elapsed = a.maxLife - a.life;
        const sx = (a.worldX || a.x) - cam.x + a.vx * elapsed * 2.5;
        const sy = (a.worldY || a.y) - cam.y + a.vy * elapsed * 2.5;
        const fa = 1 - prog;
        C.save(); C.globalAlpha = fa;
        const sz = a.sz * (1 + prog * 0.3);

        if (a.icon === '‚ú®' || a.icon === 'üí´') {
          // √âclat dor√© ‚Äî croix de pixels + glow
          C.shadowColor = '#ffd700'; C.shadowBlur = 14 + prog * 10;
          C.fillStyle = '#ffd700';
          C.fillRect(sx - sz*0.5, sy - 2, sz, 4);
          C.fillRect(sx - 2, sy - sz*0.5, 4, sz);
          C.fillStyle = '#fff'; C.fillRect(sx - 2, sy - 2, 4, 4);
        } else if (a.icon === 'üí•') {
          // Explosion ‚Äî cercles concentriques pixelis√©s
          C.shadowColor = '#ff6600'; C.shadowBlur = 10;
          const rings = [['#ffcc00', sz*0.9], ['#ff6600', sz*0.65], ['#cc2200', sz*0.35]];
          for (const [col, r] of rings) {
            C.strokeStyle = col; C.lineWidth = 3;
            C.beginPath(); C.arc(sx, sy, r, 0, Math.PI*2); C.stroke();
          }
          C.fillStyle = '#fff'; C.fillRect(sx-2, sy-2, 4, 4);
        } else if (a.icon === 'üí®') {
          // Tra√Æn√©e dash ‚Äî petits rectangles bleus
          C.fillStyle = `rgba(0,220,180,${fa * 0.8})`;
          C.fillRect(sx - sz*0.4, sy - 2, sz*0.8, 4);
          C.fillRect(sx - 2, sy - sz*0.3, 4, sz*0.6);
        } else if (a.icon === 'üåÄ') {
          // T√©l√©port ‚Äî spirale violette
          C.strokeStyle = '#cc44ff'; C.lineWidth = 2; C.shadowColor = '#cc44ff'; C.shadowBlur = 12;
          for (let t = 0; t < Math.PI * 4; t += 0.3) {
            const r = (t / (Math.PI*4)) * sz * 0.6;
            const px2 = sx + Math.cos(t + GS.frame*0.3) * r;
            const py2 = sy + Math.sin(t + GS.frame*0.3) * r;
            C.fillStyle = `rgba(200,80,255,${fa*(1-t/(Math.PI*4))})`;
            C.fillRect(px2, py2, 2, 2);
          }
        } else if (a.icon === '‚òÑÔ∏è') {
          // M√©t√©ore ‚Äî cercle rouge + tra√Æn√©e
          C.shadowColor = '#ff3300'; C.shadowBlur = 18;
          C.fillStyle = '#ff8800';
          C.beginPath(); C.arc(sx, sy, sz*0.5, 0, Math.PI*2); C.fill();
          C.fillStyle = '#ffdd00';
          C.beginPath(); C.arc(sx, sy, sz*0.25, 0, Math.PI*2); C.fill();
          // tra√Æn√©e
          C.fillStyle = 'rgba(255,100,0,0.4)';
          for (let t = 1; t <= 4; t++) {
            C.beginPath(); C.arc(sx - t*sz*0.15, sy - t*sz*0.15, sz*0.4/t, 0, Math.PI*2); C.fill();
          }
        } else if (a.icon === 'üëÅÔ∏è') {
          // Wall phase eye ‚Äî oeil flottant
          C.fillStyle = `rgba(180,0,255,${fa*0.7})`;
          C.beginPath(); C.ellipse(sx, sy, sz*0.6, sz*0.35, 0, 0, Math.PI*2); C.fill();
          C.fillStyle = '#cc00ff';
          C.beginPath(); C.arc(sx, sy, sz*0.2, 0, Math.PI*2); C.fill();
          C.fillStyle = '#000';
          C.beginPath(); C.arc(sx, sy, sz*0.1, 0, Math.PI*2); C.fill();
        } else {
          // Fallback : carr√© color√© g√©n√©rique
          C.fillStyle = '#ffd700'; C.shadowColor = '#ffd700'; C.shadowBlur = 10;
          C.fillRect(sx - sz*0.4, sy - sz*0.4, sz*0.8, sz*0.8);
        }
        C.restore();
      }
    }

    // ============================================================
    // PROJECTILES RENDER
    // ============================================================
    function renderProjectiles() {
      const { cam } = GS;
      // Player projectiles
      for (const pr of GS.projectiles) {
        const sx = pr.x - cam.x, sy = pr.y - cam.y;
        if (sx < -60 || sx > canvas.width + 60 || sy < -60 || sy > canvas.height + 60) continue;
        C.save(); C.shadowBlur = 14;
        const ang = Math.atan2(pr.vy, pr.vx);
        C.translate(sx, sy); C.rotate(ang);
        if (pr.icon === '‚ö°') {
          // √âclair ‚Äî zigzag jaune
          C.shadowColor = '#ffd700'; C.strokeStyle = '#ffee00'; C.lineWidth = 3;
          C.beginPath(); C.moveTo(-10, 0); C.lineTo(-3, -5); C.lineTo(2, 3); C.lineTo(8, -4); C.lineTo(12, 0); C.stroke();
          C.strokeStyle = '#fff'; C.lineWidth = 1.5; C.stroke();
        } else if (pr.icon === 'üîÆ') {
          // Orbe violet
          C.shadowColor = '#aa00ff';
          C.fillStyle = '#8800cc';
          C.beginPath(); C.arc(0, 0, pr.sz*0.5, 0, Math.PI*2); C.fill();
          C.fillStyle = '#cc44ff';
          C.beginPath(); C.arc(-2, -2, pr.sz*0.2, 0, Math.PI*2); C.fill();
        } else if (pr.icon === '‚ùÑÔ∏è') {
          // Flocon glace
          C.shadowColor = '#88ccff'; C.strokeStyle = '#aaddff'; C.lineWidth = 2;
          for (let a = 0; a < Math.PI * 2; a += Math.PI/3) {
            C.beginPath(); C.moveTo(0,0); C.lineTo(Math.cos(a)*10, Math.sin(a)*10); C.stroke();
          }
          C.fillStyle = '#88ccff'; C.beginPath(); C.arc(0,0,3,0,Math.PI*2); C.fill();
        } else {
          C.fillStyle = '#ffd700'; C.shadowColor = '#ffd700';
          C.fillRect(-pr.sz*0.4, -pr.sz*0.4, pr.sz*0.8, pr.sz*0.8);
        }
        C.restore();
      }
      // Boss projectiles
      for (const pr of GS.bossProjectiles) {
        const sx = pr.x - cam.x, sy = pr.y - cam.y;
        if (sx < -60 || sx > canvas.width + 60 || sy < -60 || sy > canvas.height + 60) continue;
        C.save(); C.shadowBlur = 12; C.translate(sx, sy);
        if (pr.icon === '‚ò†Ô∏è') {
          // Poison ‚Äî cr√¢ne pixelis√©
          C.shadowColor = '#44ff44';
          C.fillStyle = '#228822';
          C.fillRect(-6, -6, 12, 10);
          C.fillStyle = '#44ff44'; C.fillRect(-4,-8,4,3); C.fillRect(2,-8,4,3);
          C.fillStyle = '#002200'; C.fillRect(-3,-4,3,3); C.fillRect(2,-4,3,3);
          C.fillRect(-2, 0, 2, 3); C.fillRect(0, 0, 2, 3); C.fillRect(2, 0, 2, 3);
        } else if (pr.icon === 'üíú') {
          // Ombre violette
          C.shadowColor = '#8800ff';
          C.fillStyle = '#6600cc';
          C.beginPath(); C.arc(0,0,pr.sz*0.5,0,Math.PI*2); C.fill();
          C.fillStyle = '#aa44ff'; C.beginPath(); C.arc(-2,-2,pr.sz*0.2,0,Math.PI*2); C.fill();
        } else if (pr.icon === 'üî•') {
          // Flamme
          C.shadowColor = '#ff4400';
          C.fillStyle = '#ff4400'; C.fillRect(-4, -8, 8, 10);
          C.fillStyle = '#ff8800'; C.fillRect(-3, -10, 6, 7);
          C.fillStyle = '#ffcc00'; C.fillRect(-2, -12, 4, 6);
          C.fillStyle = '#fff'; C.fillRect(-1, -13, 2, 3);
        } else if (pr.icon === 'üåä') {
          // Onde choc
          C.shadowColor = '#4488ff';
          C.strokeStyle = '#4488ff'; C.lineWidth = 2;
          C.beginPath(); C.arc(0, 0, pr.sz*0.6, 0, Math.PI*2); C.stroke();
          C.strokeStyle = '#88ccff'; C.lineWidth = 1;
          C.beginPath(); C.arc(0, 0, pr.sz*0.35, 0, Math.PI*2); C.stroke();
        } else if (pr.icon === 'üí¢') {
          // Enrage ‚Äî losange rouge
          C.shadowColor = '#ff0000';
          C.fillStyle = '#cc0000';
          C.save(); C.rotate(Math.PI/4 + GS.frame*0.05);
          C.fillRect(-5, -5, 10, 10);
          C.restore();
          C.fillStyle = '#ff4444'; C.fillRect(-2, -2, 4, 4);
        } else if (pr.icon === '‚è∞') {
          // Arr√™t du temps ‚Äî horloge
          C.shadowColor = '#8888ff';
          C.strokeStyle = '#8888ff'; C.lineWidth = 2;
          C.beginPath(); C.arc(0,0,pr.sz*0.5,0,Math.PI*2); C.stroke();
          C.fillStyle = '#8888ff'; C.fillRect(-1,-7,2,7); C.fillRect(0,-2,5,2);
        } else {
          C.fillStyle = '#ff4400'; C.shadowColor = '#ff4400';
          C.fillRect(-pr.sz*0.4, -pr.sz*0.4, pr.sz*0.8, pr.sz*0.8);
        }
        C.restore();
      }
    }

    // ============================================================
    // LIGHTING
    // ============================================================
    function renderLighting() {
      const { p, cam } = GS; const sx = p.x - cam.x, sy = p.y - cam.y;
      const biome = LEVELS[curLvl].biome;
      const vg = C.createRadialGradient(sx, sy, canvas.width * 0.14, sx, sy, canvas.width * 0.65);
      const outerA = biome === 'castle' ? 0.62 : biome === 'mountain' ? 0.52 : 0.42;
      vg.addColorStop(0, 'rgba(0,0,0,0)'); vg.addColorStop(1, `rgba(0,0,0,${outerA})`);
      C.fillStyle = vg; C.fillRect(0, 0, canvas.width, canvas.height);
      if (GS.lightPulse > 0) GS.lightPulse--;
      const lr = 220 + GS.lightPulse * 10;
      const lg = C.createRadialGradient(sx, sy, 0, sx, sy, lr);
      const lc = biome === 'castle' ? 'rgba(100,100,200,' : biome === 'mountain' ? 'rgba(150,200,255,' : 'rgba(255,220,100,';
      lg.addColorStop(0, lc + '0.13)'); lg.addColorStop(0.5, lc + '0.04)'); lg.addColorStop(1, 'transparent');
      C.fillStyle = lg; C.fillRect(0, 0, canvas.width, canvas.height);
      // Time stop tint
      if (GS.timeStop) {
        C.fillStyle = `rgba(50,50,200,${0.15 + 0.05 * Math.sin(GS.frame * 0.1)})`;
        C.fillRect(0, 0, canvas.width, canvas.height);
      }
      const edge = 8; C.fillStyle = 'rgba(0,0,0,0.25)';
      C.fillRect(0, 64, edge, canvas.height - 64); C.fillRect(canvas.width - edge, 64, edge, canvas.height - 64);
      C.fillRect(0, canvas.height - edge, canvas.width, edge);
    }

    // ============================================================
    // MINIMAP
    // ============================================================
    function renderMinimap() {
      const { map: { map }, p, cam, mons, boss, qItems } = GS;
      const mw = mm.width, mh = mm.height; const sx = mw / WW, sy = mh / WH;
      // Fond
      MC.fillStyle = '#020208'; MC.fillRect(0, 0, mw, mh);
      const step = 3;
      const tC = {
        0: '#2a7a2a', 1: '#a07830', 2: '#1a4a8a', 3: '#555', 4: '#1a3a1a', 5: '#3a8a3a',
        6: '#1e4a20', 7: '#252440', 8: '#16163a', 9: '#d0e8f8', 10: '#7aaac8', 11: '#cc2200',
        12: '#090914', 13: '#7a5020', 14: '#3a9a3a', 15: '#3a8c30', 16: '#c8a060', 17: '#1e5a2a'
      };
      for (let r = 0; r < ROWS; r += step)for (let c = 0; c < COLS; c += step) {
        MC.fillStyle = tC[map[r][c]] || '#333'; MC.fillRect(c * sx * TSIZ, r * sy * TSIZ, (step * sx * TSIZ) + 1, (step * sy * TSIZ) + 1);
      }
      // Items de qu√™te ‚Äî jaune vif
      for (const qi of qItems) if (!qi.collected) {
        MC.fillStyle = '#ffe000'; MC.fillRect(qi.x * sx - 2, qi.y * sy - 2, 4, 4);
      }
      // Ennemis ‚Äî rouge plus visible
      MC.fillStyle = '#ff3333';
      for (const m of mons) if (m.state !== 'dead') { MC.fillRect(m.x * sx - 1.5, m.y * sy - 1.5, 3, 3); }
      // Boss ‚Äî orange puls√©
      if (boss && boss.state !== 'dead') {
        MC.fillStyle = boss.rageMode ? '#ff6600' : '#ff2200';
        MC.fillRect(boss.x * sx - 3, boss.y * sy - 3, 6, 6);
      }
      // Vue cam√©ra
      MC.strokeStyle = 'rgba(255,255,100,0.25)'; MC.lineWidth = 1;
      MC.strokeRect(cam.x * sx, cam.y * sy, canvas.width * sx, canvas.height * sy);
      // Joueur ‚Äî point vert vif + halo
      MC.fillStyle = 'rgba(0,255,100,0.3)'; MC.beginPath(); MC.arc(p.x * sx, p.y * sy, 5, 0, Math.PI * 2); MC.fill();
      MC.fillStyle = '#00ff66'; MC.beginPath(); MC.arc(p.x * sx, p.y * sy, 2.5, 0, Math.PI * 2); MC.fill();
    }

    // ============================================================
    // HUD
    // ============================================================
    function updHUD() {
      const p = GS.p; const lv = LEVELS[curLvl];
      const hw = document.getElementById('hearts'); hw.innerHTML = '';
      for (let i = 0; i < p.maxHp; i++) { const h = document.createElement('div'); h.className = i < p.hp ? 'heart-full' : 'heart-empty'; hw.appendChild(h); }
      document.getElementById('xpbar').style.width = Math.min(100, p.xp / (p.lvl * 100) * 100) + '%';
      document.getElementById('hud-lvl').textContent = `Niv. ${p.lvl}`;
      document.getElementById('hud-weapon').textContent = p.weapon;
      const done = lv.questType === 'kill' ? p.qKills : p.qItems;
      document.getElementById('hud-quest').textContent = `${lv.quest} (${Math.min(done, lv.questCount)}/${lv.questCount})`;
    }

    // ============================================================
    // DIALOG
    // ============================================================
    let dlgLines = [], dlgIdx = 0, dlgCB = null, dlgTyping = false, dlgTimer = null, dlgFull = '';
    function openDlg(portrait, name, lines, cb) {
      GS.dlgActive = true; dlgLines = lines; dlgIdx = 0; dlgCB = cb;
      document.getElementById('dialog').style.display = 'block';
      document.getElementById('dlg-portrait').textContent = portrait;
      document.getElementById('dlg-name').textContent = name.toUpperCase();
      document.getElementById('dlg-btn').style.display = 'none';
      document.getElementById('dlg-cont').style.display = 'none';
      typeNext();
    }
    function typeNext() {
      if (dlgIdx >= dlgLines.length) { closeDlg(); return; }
      dlgFull = dlgLines[dlgIdx++];
      const el = document.getElementById('dlg-text');
      const btn = document.getElementById('dlg-btn'), cont = document.getElementById('dlg-cont');
      btn.style.display = 'none'; cont.style.display = 'none';
      if (dlgTimer) clearInterval(dlgTimer);
      dlgTyping = true; el.textContent = ''; let i = 0;
      dlgTimer = setInterval(() => {
        el.textContent += dlgFull[i]; sBeep(); i++;
        if (i >= dlgFull.length) {
          clearInterval(dlgTimer); dlgTyping = false; btn.style.display = 'block';
          if (dlgIdx < dlgLines.length) { cont.style.display = 'block'; btn.textContent = 'SUITE ‚ñ∂'; }
          else btn.textContent = 'FERMER ‚úï';
        }
      }, 28);
    }
    function nextLine() {
      if (dlgTyping) {
        clearInterval(dlgTimer); dlgTyping = false; document.getElementById('dlg-text').textContent = dlgFull;
        const btn = document.getElementById('dlg-btn'); btn.style.display = 'block';
        if (dlgIdx < dlgLines.length) { document.getElementById('dlg-cont').style.display = 'block'; btn.textContent = 'SUITE ‚ñ∂'; }
        else { document.getElementById('dlg-cont').style.display = 'none'; btn.textContent = 'FERMER ‚úï'; } return;
      }
      if (dlgIdx < dlgLines.length) typeNext(); else closeDlg();
    }
    function closeDlg() {
      document.getElementById('dialog').style.display = 'none';
      GS.dlgActive = false; if (dlgCB) { const cb = dlgCB; dlgCB = null; cb(); }
    }

    // ============================================================
    // LEVEL TRANSITION / VICTORY
    // ============================================================
    function showLT() {
      const lv = LEVELS[curLvl];
      document.getElementById('lt-icon').textContent = lv.rewardIcon;
      document.getElementById('lt-title').textContent = curLvl >= 2 ? 'üèÜ VICTOIRE FINALE !' : 'NIVEAU ACCOMPLI !';
      document.getElementById('lt-zone').textContent = lv.name + ' ‚Äî Termin√© !';
      document.getElementById('lt-reward').textContent = lv.reward;
      if (curLvl >= 2) {
        document.getElementById('lt-btn').style.display = 'none';
        const vb = document.createElement('button'); vb.className = 'lt-next-btn'; vb.textContent = 'üåü VOIR LA FIN';
        vb.onclick = () => { document.getElementById('leveltrans').style.display = 'none'; showVic(); };
        document.getElementById('leveltrans').appendChild(vb);
      }
      document.getElementById('leveltrans').style.display = 'flex';
      sLvlUp(); fireworks();
    }
    function goNextLevel() {
      document.getElementById('leveltrans').style.display = 'none';
      curLvl++; if (curLvl >= LEVELS.length) { showVic(); return; }
      loadLevel(curLvl);
    }
    function showVic() { document.getElementById('victory').style.display = 'flex'; sVic(); fireworks(); }

    // ============================================================
    // LOAD LEVEL
    // ============================================================
    function loadLevel(idx) {
      const lv = LEVELS[idx];
      const mapData = genMap(lv.biome);
      GS.map = mapData; GS.decos = genDecos(mapData, lv.biome); GS.ambient = genAmbient(lv.biome);
      GS.qItems = mapData.questPos; GS.mons = spawnMons(mapData, lv.biome, idx);
      GS.boss = null; GS.bossSpawned = false; GS.bossDefeated = false;
      GS.projectiles = []; GS.bossProjectiles = []; GS.bossWarnings = []; GS.atks = []; GS.spinAnim = null;
      GS.timeStop = false; GS.timeStopTimer = 0;
      const p = GS.p;
      p.x = mapData.startPos.x; p.y = mapData.startPos.y;
      p.qItems = 0; p.qKills = 0; p.inv = 100; p.charging = false; p.chargeTime = 0; p.atkCDs = [0, 0, 0, 0];
      p.dashCD = 0; p.invincible = false; p.invincibleTimer = 0;
      if (idx > 0) { p.weapon = LEVELS[idx - 1].weapon; p.wPow = LEVELS[idx - 1].wPow; }
      p.hp = p.maxHp;
      if (idx === 2) {
        const bp = mapData.bossPos;
        GS.qItems = [{ x: bp.x, y: bp.y, collected: false }];
        GS.boss = {
          icon: lv.bossIcon, name: lv.bossName, hp: lv.bossHP, maxHp: lv.bossHP,
          spd: 0.8, dmg: 5, x: bp.x - 80, y: bp.y, state: 'idle', dyingTimer: 0, atkCD: 0,
          aggroR: 400, loseR: 620, wAngle: 0, wTimer: 0, hitFlash: 0, r: 26, boss: true, xp: 250,
          phase: 0, phaseTimer: 0, patternTimer: 0, patterns: lv.bossPatterns || [],
          dashActive: false, dashTimer: 0, dashVx: 0, dashVy: 0, vx: 0, vy: 0,
          teleportCooldown: 0, rageMode: false, beamActive: false, beamTimer: 0, beamAngle: 0,
          beamSweepDir: 1, timeStopActive: false
        };
        GS.bossSpawned = true;
        // Setup boss HP bar
        document.getElementById('boss-hud').style.display = 'flex';
        document.getElementById('boss-hud-name').textContent = lv.bossName.toUpperCase();
        const pip = document.getElementById('boss-phase-wrap'); pip.innerHTML = '';
        for (let i = 0; i < (lv.bossPhases || 2); i++) { const d = document.createElement('div'); d.className = 'boss-phase-pip' + (i === 0 ? ' active' : ''); d.id = `bpip${i}`; pip.appendChild(d); }
      }
      GS.cam.x = p.x - canvas.width / 2; GS.cam.y = p.y - canvas.height / 2;
      GS.cam.x = Math.max(0, Math.min(WW - canvas.width, GS.cam.x)); GS.cam.y = Math.max(0, Math.min(WH - canvas.height, GS.cam.y));
      updHUD(); tileCache.clear();
      setTimeout(() => openDlg('üìú', `NIVEAU ${idx + 1}`, [`${lv.name}`, `Objectif : ${lv.quest}`, 'En avant, h√©ros !'], null), 700);
    }

    function spawnMons(mapData, biome, idx) {
      const types = MONS[biome] || MONS.forest; const count = 12 + idx * 5; const { map } = mapData;
      const sR = Math.floor(mapData.startPos.y / TSIZ), sC = Math.floor(mapData.startPos.x / TSIZ);
      const cells = bfsPassable(map, sR, sC, 5000); const out = [];
      for (let i = 0; i < count && cells.length > 0; i++) {
        const type = types[Math.floor(Math.random() * types.length)];
        const cell = safeSpawnCell(cells, mapData.startPos.x, mapData.startPos.y, 120);
        if (!cell) continue;
        out.push({
          ...JSON.parse(JSON.stringify(type)), id: i, x: cell.x, y: cell.y, vx: 0, vy: 0,
          state: 'idle', dyingTimer: 0, atkCD: 0, aggroR: 160 + Math.random() * 80, loseR: 300,
          wAngle: Math.random() * Math.PI * 2, wTimer: Math.random() * 90, hitFlash: 0
        });
      }
      return out;
    }

    // ============================================================
    // PIXEL ART SPRITES ‚Äî toutes les fonctions de dessin
    // ============================================================

    // Helper : dessine un pixel art √† partir d'une palette + grille
    function px(ctx, x, y, s, palette, grid, cols) {
      for (let i = 0; i < grid.length; i++) {
        const c = grid[i]; if (c === 0) continue;
        ctx.fillStyle = palette[c - 1];
        ctx.fillRect(x + (i % cols) * s, y + Math.floor(i / cols) * s, s, s);
      }
    }

    // ‚îÄ‚îÄ‚îÄ SORCIER (joueur) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // 12√ó16 pixels, 4 directions, 3 frames
    // direction: 0=bas 1=gauche 2=droite 3=haut
    function drawWizard(ctx, cx, cy, dir, frame, scale = 2) {
      const s = scale;
      const flip = dir === 1; // gauche = flip horizontal
      ctx.save();
      ctx.translate(cx, cy);
      if (flip) { ctx.scale(-1, 1); }

      // Palette: 1=robe fonc√©e 2=robe claire 3=peau 4=barbe 5=chapeau 6=b√¢ton 7=orbe 8=yeux 9=accent dor√©
      const P = ['#2a1c6e','#4a3ea8','#f2c07a','#e8e8e8','#1a1240','#7a4a1a','#00d4ff','#220022','#ffd700'];

      const W = 12, H = 16;
      const ox = -Math.floor(W * s / 2), oy = -Math.floor(H * s / 2);

      // Bob walking
      const legFrame = frame;
      const bodyBob = (frame === 1) ? -1 : 0;

      // --- CHAPEAU ---
      // pointe du chapeau
      for (let i = 3; i <= 8; i++) {
        const h = Math.max(0, 4 - Math.abs(i - 5.5));
        ctx.fillStyle = P[4];
        ctx.fillRect(ox + i * s, oy + (1 + (3 - h)) * s, s, h * s);
      }
      // bord chapeau
      ctx.fillStyle = P[4];
      ctx.fillRect(ox + 1 * s, oy + 5 * s, 10 * s, s);
      // √©toile sur chapeau
      ctx.fillStyle = P[8];
      ctx.fillRect(ox + 5 * s, oy + 3 * s, s, s);
      ctx.fillRect(ox + 4 * s, oy + 4 * s, 3 * s, s);
      ctx.fillRect(ox + 5 * s, oy + 4 * s, s, s);

      // --- T√äTE ---
      ctx.fillStyle = P[2];
      ctx.fillRect(ox + 3 * s, oy + (6 + bodyBob) * s, 6 * s, 4 * s);
      // yeux (selon direction)
      ctx.fillStyle = P[7];
      if (dir !== 3) { // pas dos
        ctx.fillRect(ox + 4 * s, oy + (7 + bodyBob) * s, s, s);
        ctx.fillRect(ox + 7 * s, oy + (7 + bodyBob) * s, s, s);
      }
      // barbe
      ctx.fillStyle = P[3];
      ctx.fillRect(ox + 3 * s, oy + (9 + bodyBob) * s, 6 * s, s);
      ctx.fillRect(ox + 4 * s, oy + (9 + bodyBob) * s, 4 * s, 2 * s);

      // --- ROBE ---
      ctx.fillStyle = P[0];
      ctx.fillRect(ox + 2 * s, oy + 10 * s, 8 * s, 4 * s);
      ctx.fillStyle = P[1];
      // reflets robe
      ctx.fillRect(ox + 4 * s, oy + 10 * s, 4 * s, 3 * s);
      // bas robe √©vas√©
      ctx.fillStyle = P[0];
      ctx.fillRect(ox + 1 * s, oy + 13 * s, 10 * s, s);
      // motif dor√© robe
      ctx.fillStyle = P[8];
      ctx.fillRect(ox + 5 * s, oy + 11 * s, 2 * s, s);

      // --- JAMBES ---
      const legOff = legFrame === 0 ? 0 : legFrame === 1 ? -s : s;
      ctx.fillStyle = P[0];
      ctx.fillRect(ox + 3 * s + legOff, oy + 14 * s, 2 * s, 2 * s);
      ctx.fillRect(ox + 7 * s - legOff, oy + 14 * s, 2 * s, 2 * s);
      // chaussures
      ctx.fillStyle = P[4];
      ctx.fillRect(ox + 3 * s + legOff - s, oy + 15 * s, 3 * s, s);
      ctx.fillRect(ox + 7 * s - legOff, oy + 15 * s, 3 * s, s);

      // --- BATON ---
      ctx.fillStyle = P[5];
      ctx.fillRect(ox + 0 * s, oy + 5 * s, s, 11 * s);
      // orbe b√¢ton
      ctx.fillStyle = P[6];
      ctx.fillRect(ox + 0 * s, oy + 4 * s, 2 * s, 2 * s);
      // brillance orbe (pulse)
      const pulse = (Math.sin(GS.frame * 0.12) + 1) / 2;
      ctx.globalAlpha *= (0.5 + 0.5 * pulse);
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(ox + 0 * s, oy + 4 * s, s, s);
      ctx.globalAlpha = ctx.globalAlpha / (0.5 + 0.5 * pulse) || 1;

      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ LOUP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawWolf(ctx, cx, cy, dir, frame, scale = 2, alpha = 1) {
      const s = scale;
      const flip = dir < 0; // dir=-1 va √† gauche
      ctx.save();
      ctx.translate(cx, cy);
      ctx.globalAlpha *= alpha;
      if (flip) { ctx.scale(-1, 1); }

      const ox = -10 * s, oy = -10 * s;

      const legOff = frame === 0 ? 0 : 2 * s;
      const runBob = frame === 1 ? -s : 0;

      // Corps
      ctx.fillStyle = '#5a4030';
      ctx.fillRect(ox + 3*s, oy + 5*s + runBob, 12*s, 7*s);
      // Ventre plus clair
      ctx.fillStyle = '#7a6050';
      ctx.fillRect(ox + 5*s, oy + 8*s + runBob, 7*s, 3*s);
      // Queue
      ctx.fillStyle = '#4a3020';
      ctx.fillRect(ox + 15*s, oy + 3*s + runBob, 3*s, 5*s);
      ctx.fillRect(ox + 16*s, oy + 2*s + runBob, 2*s, 3*s);

      // T√™te
      ctx.fillStyle = '#4a3020';
      ctx.fillRect(ox + 0*s, oy + 2*s + runBob, 8*s, 7*s);
      // Museau
      ctx.fillStyle = '#6a5040';
      ctx.fillRect(ox + 0*s, oy + 6*s + runBob, 5*s, 3*s);
      // Truffe
      ctx.fillStyle = '#1a0808';
      ctx.fillRect(ox + 0*s, oy + 6*s + runBob, 2*s, 2*s);
      // Oreilles
      ctx.fillStyle = '#3a2010';
      ctx.fillRect(ox + 3*s, oy + 0*s + runBob, 3*s, 3*s);
      ctx.fillRect(ox + 6*s, oy + 0*s + runBob, 3*s, 3*s);
      // Yeux
      ctx.fillStyle = '#ffdd00';
      ctx.fillRect(ox + 2*s, oy + 3*s + runBob, 2*s, 2*s);
      ctx.fillRect(ox + 5*s, oy + 3*s + runBob, 2*s, 2*s);
      ctx.fillStyle = '#000';
      ctx.fillRect(ox + 3*s, oy + 3*s + runBob, s, s);
      ctx.fillRect(ox + 6*s, oy + 3*s + runBob, s, s);

      // Pattes avant
      ctx.fillStyle = '#4a3020';
      ctx.fillRect(ox + 3*s, oy + 11*s + legOff, 3*s, 3*s);
      ctx.fillRect(ox + 8*s, oy + 11*s - legOff, 3*s, 3*s);
      // Pattes arri√®re
      ctx.fillRect(ox + 11*s, oy + 11*s + legOff, 3*s, 3*s);
      ctx.fillRect(ox + 14*s, oy + 11*s - legOff, 3*s, 3*s);
      // Griffes
      ctx.fillStyle = '#aaa';
      ctx.fillRect(ox + 3*s, oy + 13*s + legOff, s, s);
      ctx.fillRect(ox + 5*s, oy + 13*s + legOff, s, s);
      ctx.fillRect(ox + 8*s, oy + 13*s - legOff, s, s);
      ctx.fillRect(ox + 10*s, oy + 13*s - legOff, s, s);

      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ CHAUVE-SOURIS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawBat(ctx, cx, cy, frame, scale = 2, alpha = 1) {
      const s = scale;
      ctx.save();
      ctx.translate(cx, cy);
      ctx.globalAlpha *= alpha;

      const ox = -10 * s, oy = -8 * s;
      const wingUp = frame === 0;

      // Ombre port√©e
      ctx.fillStyle = 'rgba(0,0,0,0.18)';
      ctx.beginPath(); ctx.ellipse(cx - cx + 0, oy + 18*s - cy + cy, 8*s, 2*s, 0, 0, Math.PI*2); ctx.fill();
      ctx.translate(-cx + cx, -cy + cy);

      // Ailes
      ctx.fillStyle = '#2a1848';
      if (wingUp) {
        // Ailes lev√©es
        ctx.beginPath();
        ctx.moveTo(ox + 6*s, oy + 6*s); ctx.lineTo(ox - 2*s, oy + 0*s);
        ctx.lineTo(ox + 0*s, oy + 2*s); ctx.lineTo(ox + 2*s, oy + 0*s);
        ctx.lineTo(ox + 4*s, oy + 3*s); ctx.closePath(); ctx.fill();
        ctx.beginPath();
        ctx.moveTo(ox + 14*s, oy + 6*s); ctx.lineTo(ox + 22*s, oy + 0*s);
        ctx.lineTo(ox + 20*s, oy + 2*s); ctx.lineTo(ox + 18*s, oy + 0*s);
        ctx.lineTo(ox + 16*s, oy + 3*s); ctx.closePath(); ctx.fill();
      } else {
        // Ailes baiss√©es
        ctx.beginPath();
        ctx.moveTo(ox + 6*s, oy + 6*s); ctx.lineTo(ox - 2*s, oy + 10*s);
        ctx.lineTo(ox + 0*s, oy + 9*s); ctx.lineTo(ox + 2*s, oy + 10*s);
        ctx.lineTo(ox + 4*s, oy + 8*s); ctx.closePath(); ctx.fill();
        ctx.beginPath();
        ctx.moveTo(ox + 14*s, oy + 6*s); ctx.lineTo(ox + 22*s, oy + 10*s);
        ctx.lineTo(ox + 20*s, oy + 9*s); ctx.lineTo(ox + 18*s, oy + 10*s);
        ctx.lineTo(ox + 16*s, oy + 8*s); ctx.closePath(); ctx.fill();
      }
      // Membrane aile (d√©tail)
      ctx.fillStyle = '#3a2860';
      if (wingUp) {
        ctx.fillRect(ox + 1*s, oy + 1*s, 4*s, s); ctx.fillRect(ox + 15*s, oy + 1*s, 4*s, s);
      }
      // Corps
      ctx.fillStyle = '#2a1848';
      ctx.beginPath(); ctx.arc(ox + 10*s, oy + 7*s, 5*s, 0, Math.PI*2); ctx.fill();
      // Fourrure ventre
      ctx.fillStyle = '#3a2868';
      ctx.fillRect(ox + 7*s, oy + 6*s, 6*s, 3*s);
      // Oreilles pointues
      ctx.fillStyle = '#1a0c30';
      ctx.beginPath();
      ctx.moveTo(ox + 7*s, oy + 3*s); ctx.lineTo(ox + 6*s, oy - 1*s); ctx.lineTo(ox + 9*s, oy + 3*s); ctx.closePath(); ctx.fill();
      ctx.beginPath();
      ctx.moveTo(ox + 11*s, oy + 3*s); ctx.lineTo(ox + 14*s, oy - 1*s); ctx.lineTo(ox + 13*s, oy + 3*s); ctx.closePath(); ctx.fill();
      // Yeux rouges brillants
      ctx.fillStyle = '#ff2200';
      ctx.fillRect(ox + 8*s, oy + 5*s, 2*s, 2*s);
      ctx.fillRect(ox + 11*s, oy + 5*s, 2*s, 2*s);
      ctx.fillStyle = '#ff8866';
      ctx.fillRect(ox + 8*s, oy + 5*s, s, s);
      ctx.fillRect(ox + 11*s, oy + 5*s, s, s);
      // Crocs
      ctx.fillStyle = '#eee';
      ctx.fillRect(ox + 9*s, oy + 9*s, s, 2*s);
      ctx.fillRect(ox + 11*s, oy + 9*s, s, 2*s);

      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ ARAIGN√âE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawSpider(ctx, cx, cy, frame, scale = 2, alpha = 1) {
      const s = scale;
      ctx.save();
      ctx.translate(cx, cy);
      ctx.globalAlpha *= alpha;

      const ox = -9 * s, oy = -8 * s;
      const legOff = frame === 0 ? 0 : s;

      // Toile (fond)
      ctx.strokeStyle = 'rgba(200,200,200,0.3)';
      ctx.lineWidth = 0.5;
      for (let i = 0; i < 3; i++) {
        ctx.beginPath(); ctx.arc(0, oy + 2*s, (4 + i*3)*s, 0, Math.PI*2); ctx.stroke();
      }

      // Pattes (8 pattes)
      ctx.strokeStyle = '#1a1a1a'; ctx.lineWidth = s;
      const legAngles = [-0.7, -0.4, -0.15, 0.15, 0.4, 0.7, 1.0, 1.3].map((a, i) => i < 4 ? -Math.PI/2 - a*0.8 : Math.PI/2 + (a-0.7)*0.8);
      for (let i = 0; i < 8; i++) {
        const side = i < 4 ? -1 : 1;
        const li = i % 4;
        const ang = (i < 4 ? [-0.8, -0.4, 0.0, 0.4][li] : [0.0, 0.4, 0.8, 1.2][li]);
        const baseX = side * 3 * s;
        const lLen = (7 + li) * s;
        const bendY = legOff * (li % 2 === 0 ? 1 : -1);
        ctx.beginPath();
        ctx.moveTo(baseX, 0);
        const midX = baseX + side * lLen * 0.5;
        const midY = -4*s + ang * 3*s + bendY;
        const endX = baseX + side * lLen;
        const endY = 3*s + ang * 2*s - bendY;
        ctx.quadraticCurveTo(midX, midY, endX, endY);
        ctx.stroke();
      }

      // Corps (abdomen)
      ctx.fillStyle = '#181818';
      ctx.beginPath(); ctx.ellipse(0, 3*s, 6*s, 5*s, 0, 0, Math.PI*2); ctx.fill();
      // Motif abdomen
      ctx.fillStyle = '#cc2200';
      ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-2*s, 5*s); ctx.lineTo(0, 7*s); ctx.lineTo(2*s, 5*s); ctx.closePath(); ctx.fill();
      ctx.fillStyle = '#ff4400';
      ctx.fillRect(-s, 3*s, 2*s, 2*s);

      // C√©phalothorax
      ctx.fillStyle = '#222';
      ctx.beginPath(); ctx.ellipse(0, -3*s, 4*s, 4*s, 0, 0, Math.PI*2); ctx.fill();
      // 8 yeux
      ctx.fillStyle = '#44ffaa';
      const eyePos = [[-2,-5],[0,-5],[2,-5],[-3,-3],[3,-3],[-1,-2],[1,-2],[0,-4]];
      for (const [ex, ey] of eyePos) {
        ctx.fillRect(ex*s, ey*s, s, s);
      }
      // Crochets
      ctx.fillStyle = '#ff2200';
      ctx.fillRect(-2*s, -8*s, s, 3*s);
      ctx.fillRect(s, -8*s, s, 3*s);

      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ MONSTRE FEUILLE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawLeafMonster(ctx, cx, cy, frame, scale = 2, alpha = 1) {
      const s = scale;
      ctx.save();
      ctx.translate(cx, cy);
      ctx.globalAlpha *= alpha;

      const ox = -9 * s, oy = -12 * s;
      const sway = frame === 0 ? 0 : s;

      // Feuilles de fond (d√©cor)
      ctx.fillStyle = '#1a5c2a';
      for (let i = 0; i < 3; i++) {
        ctx.save();
        ctx.rotate((i - 1) * 0.3 + sway * 0.05);
        ctx.beginPath();
        ctx.ellipse((-2 + i * 2) * s, -10*s, 4*s, 7*s, (i-1)*0.4, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      // Corps principal (feuille g√©ante)
      ctx.fillStyle = '#2a8040';
      ctx.beginPath();
      ctx.moveTo(0, oy + 0*s);
      ctx.bezierCurveTo(-8*s + sway, oy + 6*s, -6*s - sway, oy + 16*s, 0, oy + 22*s);
      ctx.bezierCurveTo(6*s + sway, oy + 16*s, 8*s - sway, oy + 6*s, 0, oy + 0*s);
      ctx.fill();
      // Nervure centrale
      ctx.strokeStyle = '#1a6030'; ctx.lineWidth = s;
      ctx.beginPath();
      ctx.moveTo(0, oy); ctx.lineTo(0, oy + 22*s); ctx.stroke();
      // Nervures lat√©rales
      ctx.lineWidth = 0.5;
      for (let i = 1; i < 5; i++) {
        ctx.beginPath();
        ctx.moveTo(0, oy + i*4*s);
        ctx.lineTo(-4*s, oy + i*4*s + 2*s);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, oy + i*4*s);
        ctx.lineTo(4*s, oy + i*4*s + 2*s);
        ctx.stroke();
      }
      // Reflets
      ctx.fillStyle = '#4ab060';
      ctx.beginPath();
      ctx.ellipse(-2*s, oy + 8*s, 2*s, 5*s, -0.2, 0, Math.PI*2);
      ctx.fill();

      // Yeux rouges brillants
      ctx.fillStyle = '#cc0000';
      ctx.beginPath(); ctx.arc(-3*s, oy + 9*s, 2*s, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(3*s, oy + 9*s, 2*s, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#ff4444';
      ctx.fillRect(-4*s, oy + 8*s, 2*s, 2*s);
      ctx.fillRect(2*s, oy + 8*s, 2*s, 2*s);
      // Pupilles
      ctx.fillStyle = '#000';
      ctx.fillRect(-3*s, oy + 9*s, s, s);
      ctx.fillRect(3*s, oy + 9*s, s, s);

      // Bouche dentel√©e
      ctx.fillStyle = '#0a3010';
      ctx.fillRect(-3*s, oy + 13*s, 6*s, 2*s);
      ctx.fillStyle = '#eee';
      for (let i = 0; i < 3; i++) {
        ctx.fillRect((-2 + i*2)*s, oy + 13*s, s, 2*s);
      }

      // Petites griffes
      ctx.fillStyle = '#1a4020';
      ctx.fillRect(-4*s, oy + 20*s - sway, 2*s, 3*s);
      ctx.fillRect(2*s, oy + 20*s + sway, 2*s, 3*s);
      ctx.fillStyle = '#aad060';
      ctx.fillRect(-5*s, oy + 22*s - sway, s, 2*s);
      ctx.fillRect(-3*s, oy + 22*s - sway, s, 2*s);
      ctx.fillRect(2*s, oy + 22*s + sway, s, 2*s);
      ctx.fillRect(4*s, oy + 22*s + sway, s, 2*s);

      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ D√âMON RAGE (boss 1) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawDemon(ctx, cx, cy, dir, frame, scale = 2.2, alpha = 1, rageMode = false) {
      const s = scale;
      ctx.save();
      ctx.translate(cx, cy);
      ctx.globalAlpha *= alpha;
      const flip = dir === 1;
      if (flip) ctx.scale(-1, 1);

      const ox = -12 * s, oy = -14 * s;
      const legOff = frame === 0 ? 0 : frame === 1 ? -s : s;
      const pulse = (Math.sin(GS.frame * 0.15) + 1) / 2;

      // Aura de rage
      if (rageMode) {
        const grad = ctx.createRadialGradient(0, 0, 2, 0, 0, 20*s);
        grad.addColorStop(0, `rgba(255,50,0,${0.3 + 0.2*pulse})`);
        grad.addColorStop(1, 'rgba(255,0,0,0)');
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(0, 0, 20*s, 0, Math.PI*2); ctx.fill();
      }

      // Ombres/contours
      ctx.fillStyle = '#2a0000';
      ctx.fillRect(ox + 3*s, oy + 2*s, 18*s, 4*s); // ombre cornes
      ctx.fillRect(ox + 2*s, oy + 6*s, 20*s, 20*s); // ombre corps

      // Cornes
      ctx.fillStyle = '#1a0000';
      ctx.beginPath();
      ctx.moveTo(ox + 5*s, oy + 6*s); ctx.lineTo(ox + 3*s, oy + 0*s); ctx.lineTo(ox + 9*s, oy + 6*s);
      ctx.closePath(); ctx.fill();
      ctx.beginPath();
      ctx.moveTo(ox + 15*s, oy + 6*s); ctx.lineTo(ox + 21*s, oy + 0*s); ctx.lineTo(ox + 19*s, oy + 6*s);
      ctx.closePath(); ctx.fill();
      // Pointes cornes
      ctx.fillStyle = rageMode ? '#ff4400' : '#3a0000';
      ctx.fillRect(ox + 3*s, oy + 0*s, 2*s, 2*s);
      ctx.fillRect(ox + 21*s, oy + 0*s, 2*s, 2*s);

      // T√™te
      ctx.fillStyle = '#8b0000';
      ctx.fillRect(ox + 5*s, oy + 6*s, 14*s, 10*s);
      // Joues
      ctx.fillStyle = '#6a0000';
      ctx.fillRect(ox + 4*s, oy + 10*s, 3*s, 4*s);
      ctx.fillRect(ox + 17*s, oy + 10*s, 3*s, 4*s);

      // Yeux ‚Äî brillants selon rage
      const eyeCol = rageMode ? '#ff8800' : '#ff2200';
      ctx.fillStyle = eyeCol;
      ctx.fillRect(ox + 7*s, oy + 9*s, 4*s, 3*s);
      ctx.fillRect(ox + 13*s, oy + 9*s, 4*s, 3*s);
      ctx.fillStyle = '#fff';
      ctx.fillRect(ox + 7*s, oy + 9*s, 2*s, s);
      ctx.fillRect(ox + 13*s, oy + 9*s, 2*s, s);
      // Glow yeux
      if (rageMode || pulse > 0.6) {
        ctx.fillStyle = `rgba(255,100,0,${0.4 * pulse})`;
        ctx.fillRect(ox + 6*s, oy + 8*s, 6*s, 5*s);
        ctx.fillRect(ox + 12*s, oy + 8*s, 6*s, 5*s);
      }

      // Bouche avec crocs
      ctx.fillStyle = '#3a0000';
      ctx.fillRect(ox + 7*s, oy + 13*s, 10*s, 3*s);
      ctx.fillStyle = '#cc2200';
      ctx.fillRect(ox + 8*s, oy + 13*s, 2*s, s); // langue
      ctx.fillRect(ox + 12*s, oy + 13*s, 2*s, s);
      ctx.fillStyle = '#eeeeee';
      ctx.fillRect(ox + 7*s, oy + 13*s, 2*s, 2*s); // crocs
      ctx.fillRect(ox + 10*s, oy + 13*s, 2*s, 2*s);
      ctx.fillRect(ox + 14*s, oy + 13*s, 2*s, 2*s);

      // Corps massif
      ctx.fillStyle = '#6a0000';
      ctx.fillRect(ox + 3*s, oy + 16*s, 18*s, 10*s);
      // Abdomen
      ctx.fillStyle = '#8b1a00';
      ctx.fillRect(ox + 5*s, oy + 18*s, 14*s, 6*s);
      // D√©tails corps (segments)
      ctx.fillStyle = '#4a0000';
      for (let i = 0; i < 3; i++) {
        ctx.fillRect(ox + 5*s, oy + (18 + i*2)*s, 14*s, s);
      }

      // √âpaules / aura instable
      ctx.fillStyle = rageMode ? `rgba(255,80,0,${0.5 + 0.3*pulse})` : `rgba(200,0,0,${0.2 + 0.15*pulse})`;
      ctx.fillRect(ox + 1*s, oy + 14*s, 4*s, 4*s);
      ctx.fillRect(ox + 19*s, oy + 14*s, 4*s, 4*s);

      // Bras
      ctx.fillStyle = '#7a0000';
      ctx.fillRect(ox + 0*s, oy + 16*s, 4*s, 8*s);
      ctx.fillRect(ox + 20*s, oy + 16*s, 4*s, 8*s);
      // Griffes
      ctx.fillStyle = '#1a0000';
      ctx.fillRect(ox + 0*s, oy + 23*s, 2*s, 3*s);
      ctx.fillRect(ox + 2*s, oy + 24*s, 2*s, 2*s);
      ctx.fillRect(ox + 20*s, oy + 23*s, 2*s, 3*s);
      ctx.fillRect(ox + 22*s, oy + 24*s, 2*s, 2*s);

      // Jambes
      ctx.fillStyle = '#6a0000';
      ctx.fillRect(ox + 5*s, oy + 26*s + legOff, 5*s, 5*s);
      ctx.fillRect(ox + 14*s, oy + 26*s - legOff, 5*s, 5*s);
      // Sabots
      ctx.fillStyle = '#1a0000';
      ctx.fillRect(ox + 4*s, oy + 30*s + legOff, 6*s, 2*s);
      ctx.fillRect(ox + 13*s, oy + 30*s - legOff, 6*s, 2*s);

      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ ROI DOUTE (boss 2) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawKingDoubt(ctx, cx, cy, dir, frame, scale = 2.2, alpha = 1, rageMode = false) {
      const s = scale;
      ctx.save();
      ctx.translate(cx, cy);
      ctx.globalAlpha *= alpha;
      const flip = dir === 1;
      if (flip) ctx.scale(-1, 1);

      const ox = -12 * s, oy = -16 * s;
      const legOff = frame === 0 ? 0 : frame === 1 ? -s : s;
      const pulse = (Math.sin(GS.frame * 0.1) + 1) / 2;

      // Aura violet/noir
      const auraCol = rageMode ? `rgba(180,0,255,${0.35+0.2*pulse})` : `rgba(80,0,150,${0.2+0.1*pulse})`;
      ctx.fillStyle = auraCol;
      ctx.beginPath(); ctx.ellipse(0, 4*s, 18*s, 10*s, 0, 0, Math.PI*2); ctx.fill();

      // Cape flottante
      ctx.fillStyle = rageMode ? '#4a0080' : '#1a0040';
      ctx.beginPath();
      ctx.moveTo(ox + 2*s, oy + 14*s);
      ctx.lineTo(ox - 3*s, oy + 32*s + legOff*0.5);
      ctx.lineTo(ox + 12*s, oy + 34*s);
      ctx.lineTo(ox + 26*s, oy + 32*s - legOff*0.5);
      ctx.lineTo(ox + 22*s, oy + 14*s);
      ctx.closePath(); ctx.fill();
      // Liser√© cape
      ctx.strokeStyle = rageMode ? '#cc00ff' : '#6600aa';
      ctx.lineWidth = s; ctx.stroke();

      // Couronne
      ctx.fillStyle = '#ffd700';
      ctx.fillRect(ox + 5*s, oy + 2*s, 14*s, 4*s);
      // Pointes couronne
      for (let i = 0; i < 5; i++) {
        const h = [3,5,6,5,3][i];
        ctx.fillRect(ox + (5 + i*3)*s, oy + (2-h)*s, 2*s, h*s);
      }
      // Gemmes couronne
      ctx.fillStyle = rageMode ? '#ff00ff' : '#aa00ff';
      ctx.fillRect(ox + 11*s, oy - 2*s, 2*s, 2*s);
      ctx.fillStyle = '#ff4444';
      ctx.fillRect(ox + 8*s, oy + 0*s, 2*s, 2*s);
      ctx.fillRect(ox + 14*s, oy + 0*s, 2*s, 2*s);

      // T√™te
      ctx.fillStyle = '#2a0a2a';
      ctx.fillRect(ox + 5*s, oy + 6*s, 14*s, 10*s);
      // Masque
      ctx.fillStyle = '#1a0028';
      ctx.fillRect(ox + 7*s, oy + 8*s, 10*s, 5*s);
      // Yeux
      const eyeCol2 = rageMode ? '#ff00ff' : '#aa00ff';
      ctx.fillStyle = eyeCol2;
      ctx.fillRect(ox + 8*s, oy + 9*s, 3*s, 3*s);
      ctx.fillRect(ox + 13*s, oy + 9*s, 3*s, 3*s);
      ctx.fillStyle = '#fff';
      ctx.fillRect(ox + 8*s, oy + 9*s, s, s);
      ctx.fillRect(ox + 13*s, oy + 9*s, s, s);
      // Ombre yeux glow
      ctx.fillStyle = `rgba(180,0,255,${0.4*pulse})`;
      ctx.fillRect(ox + 6*s, oy + 8*s, 6*s, 5*s);
      ctx.fillRect(ox + 12*s, oy + 8*s, 6*s, 5*s);
      // Bouche
      ctx.fillStyle = '#000';
      ctx.fillRect(ox + 8*s, oy + 14*s, 8*s, 2*s);
      ctx.fillStyle = '#cc00cc';
      ctx.fillRect(ox + 9*s, oy + 14*s, 2*s, s);
      ctx.fillRect(ox + 13*s, oy + 14*s, 2*s, s);

      // Corps avec armure
      ctx.fillStyle = '#1a0a30';
      ctx.fillRect(ox + 4*s, oy + 16*s, 16*s, 10*s);
      // Plaques armure
      ctx.fillStyle = '#3a1a60';
      ctx.fillRect(ox + 5*s, oy + 17*s, 14*s, 4*s);
      ctx.fillRect(ox + 5*s, oy + 22*s, 14*s, 3*s);
      // Brillance armure
      ctx.fillStyle = rageMode ? '#cc00ff' : '#6600aa';
      ctx.fillRect(ox + 6*s, oy + 17*s, s, 3*s);
      ctx.fillRect(ox + 17*s, oy + 17*s, s, 3*s);
      // Orbe central
      ctx.fillStyle = rageMode ? '#ff00ff' : '#8800cc';
      ctx.beginPath(); ctx.arc(ox + 12*s, oy + 21*s, 3*s, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = `rgba(255,100,255,${0.6*pulse})`;
      ctx.beginPath(); ctx.arc(ox + 12*s, oy + 21*s, 2*s, 0, Math.PI*2); ctx.fill();

      // Bras avec √©pauli√®res
      ctx.fillStyle = '#2a0a40';
      ctx.fillRect(ox + 0*s, oy + 16*s, 5*s, 10*s);
      ctx.fillRect(ox + 19*s, oy + 16*s, 5*s, 10*s);
      ctx.fillStyle = '#4a2080';
      ctx.fillRect(ox + 0*s, oy + 16*s, 5*s, 3*s); // √©pauli√®re
      ctx.fillRect(ox + 19*s, oy + 16*s, 5*s, 3*s);
      // Mains/magie
      ctx.fillStyle = rageMode ? '#ff00ff' : '#8800cc';
      ctx.fillRect(ox + 0*s, oy + 25*s, 4*s, 3*s);
      ctx.fillRect(ox + 20*s, oy + 25*s, 4*s, 3*s);

      // Jambes
      ctx.fillStyle = '#1a0a30';
      ctx.fillRect(ox + 5*s, oy + 26*s + legOff, 5*s, 6*s);
      ctx.fillRect(ox + 14*s, oy + 26*s - legOff, 5*s, 6*s);
      // Bottes
      ctx.fillStyle = '#0a0018';
      ctx.fillRect(ox + 4*s, oy + 31*s + legOff, 6*s, 2*s);
      ctx.fillRect(ox + 13*s, oy + 31*s - legOff, 6*s, 2*s);

      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ DRAGON DU TEMPS (boss 3) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawDragon(ctx, cx, cy, dir, frame, scale = 2.5, alpha = 1, rageMode = false, aerialYOff = 0) {
      const s = scale;
      ctx.save();
      ctx.translate(cx, cy + (aerialYOff || 0));
      ctx.globalAlpha *= alpha;
      const flip = dir === 1;
      if (flip) ctx.scale(-1, 1);

      const ox = -16 * s, oy = -16 * s;
      const legOff = frame === 0 ? 0 : frame === 1 ? -s*1.5 : s*1.5;
      const pulse = (Math.sin(GS.frame * 0.12) + 1) / 2;
      const wingFlap = frame === 0 ? 0 : frame === 1 ? -4*s : 2*s;

      // Aura temporelle
      ctx.fillStyle = rageMode
        ? `rgba(255,100,0,${0.25+0.15*pulse})`
        : `rgba(80,180,255,${0.15+0.1*pulse})`;
      ctx.beginPath(); ctx.ellipse(0, 4*s, 26*s, 14*s, 0, 0, Math.PI*2); ctx.fill();

      // Ailes (derri√®re)
      ctx.fillStyle = rageMode ? '#8b2200' : '#1a3060';
      // Aile gauche
      ctx.beginPath();
      ctx.moveTo(ox + 12*s, oy + 12*s);
      ctx.lineTo(ox - 6*s, oy + 8*s + wingFlap);
      ctx.lineTo(ox + 0*s, oy + 4*s + wingFlap);
      ctx.lineTo(ox + 4*s, oy + 0*s + wingFlap*0.5);
      ctx.lineTo(ox + 8*s, oy + 8*s + wingFlap*0.3);
      ctx.lineTo(ox + 12*s, oy + 10*s);
      ctx.closePath(); ctx.fill();
      // Membrane aile g
      ctx.fillStyle = rageMode ? 'rgba(180,50,0,0.5)' : 'rgba(40,80,140,0.5)';
      ctx.beginPath();
      ctx.moveTo(ox + 10*s, oy + 12*s);
      ctx.lineTo(ox - 4*s, oy + 9*s + wingFlap);
      ctx.lineTo(ox + 2*s, oy + 5*s + wingFlap);
      ctx.lineTo(ox + 8*s, oy + 9*s + wingFlap*0.3);
      ctx.closePath(); ctx.fill();
      // Aile droite
      ctx.fillStyle = rageMode ? '#8b2200' : '#1a3060';
      ctx.beginPath();
      ctx.moveTo(ox + 20*s, oy + 12*s);
      ctx.lineTo(ox + 38*s, oy + 8*s + wingFlap);
      ctx.lineTo(ox + 32*s, oy + 4*s + wingFlap);
      ctx.lineTo(ox + 28*s, oy + 0*s + wingFlap*0.5);
      ctx.lineTo(ox + 24*s, oy + 8*s + wingFlap*0.3);
      ctx.lineTo(ox + 20*s, oy + 10*s);
      ctx.closePath(); ctx.fill();
      ctx.fillStyle = rageMode ? 'rgba(180,50,0,0.5)' : 'rgba(40,80,140,0.5)';
      ctx.beginPath();
      ctx.moveTo(ox + 22*s, oy + 12*s);
      ctx.lineTo(ox + 36*s, oy + 9*s + wingFlap);
      ctx.lineTo(ox + 30*s, oy + 5*s + wingFlap);
      ctx.lineTo(ox + 24*s, oy + 9*s + wingFlap*0.3);
      ctx.closePath(); ctx.fill();

      // Queue
      ctx.fillStyle = rageMode ? '#6a1800' : '#102040';
      ctx.beginPath();
      ctx.moveTo(ox + 22*s, oy + 24*s);
      ctx.lineTo(ox + 30*s, oy + 28*s + legOff*0.3);
      ctx.lineTo(ox + 34*s, oy + 24*s);
      ctx.lineTo(ox + 36*s, oy + 20*s);
      ctx.lineTo(ox + 32*s, oy + 22*s);
      ctx.lineTo(ox + 28*s, oy + 26*s + legOff*0.3);
      ctx.lineTo(ox + 24*s, oy + 22*s);
      ctx.closePath(); ctx.fill();
      // pointe queue
      ctx.fillStyle = rageMode ? '#ff4400' : '#3060a0';
      ctx.beginPath();
      ctx.moveTo(ox + 34*s, oy + 24*s);
      ctx.lineTo(ox + 38*s, oy + 18*s);
      ctx.lineTo(ox + 36*s, oy + 24*s);
      ctx.closePath(); ctx.fill();

      // Corps principal
      ctx.fillStyle = rageMode ? '#6a0000' : '#0d2040';
      ctx.fillRect(ox + 8*s, oy + 12*s, 16*s, 14*s);
      // √âcailles dos
      ctx.fillStyle = rageMode ? '#8b1000' : '#1a3a60';
      ctx.fillRect(ox + 9*s, oy + 12*s, 14*s, 4*s);
      // Ventre
      ctx.fillStyle = rageMode ? '#cc3300' : '#1a4a80';
      ctx.fillRect(ox + 10*s, oy + 18*s, 12*s, 6*s);
      // √âcailles ventre
      ctx.fillStyle = rageMode ? '#aa2200' : '#0d3060';
      for (let i = 0; i < 3; i++) {
        ctx.fillRect(ox + (10+i*4)*s, oy + 19*s, 3*s, s);
        ctx.fillRect(ox + (10+i*4)*s, oy + 22*s, 3*s, s);
      }
      // Cr√™te dos
      ctx.fillStyle = rageMode ? '#ff4400' : '#2080ff';
      for (let i = 0; i < 4; i++) {
        ctx.beginPath();
        ctx.moveTo(ox + (10+i*3)*s, oy + 12*s);
        ctx.lineTo(ox + (11+i*3)*s, oy + (8 - i%2*2)*s);
        ctx.lineTo(ox + (12+i*3)*s, oy + 12*s);
        ctx.closePath(); ctx.fill();
      }

      // Cou et t√™te
      ctx.fillStyle = rageMode ? '#7a0000' : '#0f2a50';
      ctx.fillRect(ox + 4*s, oy + 8*s, 10*s, 8*s);

      // T√™te
      ctx.fillStyle = rageMode ? '#9b0000' : '#152840';
      ctx.fillRect(ox + 0*s, oy + 4*s, 14*s, 10*s);
      // M√¢choire
      ctx.fillStyle = rageMode ? '#7a0000' : '#0d2030';
      ctx.fillRect(ox + 0*s, oy + 11*s, 12*s, 5*s);
      // Crocs
      ctx.fillStyle = '#eeeeee';
      for (let i = 0; i < 4; i++) {
        ctx.fillRect(ox + (1+i*3)*s, oy + 14*s, 2*s, 3*s);
      }
      // Yeux
      ctx.fillStyle = rageMode ? '#ffaa00' : '#00ccff';
      ctx.fillRect(ox + 3*s, oy + 6*s, 4*s, 3*s);
      ctx.fillRect(ox + 9*s, oy + 6*s, 3*s, 3*s);
      ctx.fillStyle = '#000';
      ctx.fillRect(ox + 4*s, oy + 6*s, 2*s, 3*s);
      ctx.fillRect(ox + 10*s, oy + 6*s, 2*s, 2*s);
      // Glow yeux
      ctx.fillStyle = rageMode ? `rgba(255,150,0,${0.5*pulse})` : `rgba(0,200,255,${0.4*pulse})`;
      ctx.fillRect(ox + 2*s, oy + 5*s, 6*s, 5*s);
      ctx.fillRect(ox + 8*s, oy + 5*s, 5*s, 5*s);
      // Narines
      ctx.fillStyle = rageMode ? '#ff4400' : '#002a50';
      ctx.fillRect(ox + 1*s, oy + 10*s, 2*s, 2*s);
      ctx.fillRect(ox + 4*s, oy + 10*s, 2*s, 2*s);
      // Flamme (rage)
      if (rageMode) {
        ctx.fillStyle = `rgba(255,${100+Math.floor(100*pulse)},0,0.8)`;
        ctx.beginPath();
        ctx.moveTo(ox + 0*s, oy + 11*s);
        ctx.lineTo(ox - 6*s, oy + 7*s + pulse*3*s);
        ctx.lineTo(ox - 2*s, oy + 9*s);
        ctx.lineTo(ox - 8*s, oy + 4*s + pulse*4*s);
        ctx.lineTo(ox + 0*s, oy + 8*s);
        ctx.closePath(); ctx.fill();
      }

      // Pattes avant
      ctx.fillStyle = rageMode ? '#6a0000' : '#0d2040';
      ctx.fillRect(ox + 8*s, oy + 22*s + legOff, 5*s, 6*s);
      ctx.fillRect(ox + 16*s, oy + 22*s - legOff, 5*s, 6*s);
      // Griffes
      ctx.fillStyle = '#888';
      for (let i = 0; i < 3; i++) {
        ctx.fillRect(ox + (8+i)*s, oy + 27*s + legOff, s, 3*s);
        ctx.fillRect(ox + (16+i)*s, oy + 27*s - legOff, s, 3*s);
      }

      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ SQUELETTE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawSkeleton(ctx, cx, cy, dir, frame, scale = 1.8, alpha = 1) {
      const s = scale; ctx.save(); ctx.translate(cx, cy); ctx.globalAlpha *= alpha;
      if (dir < 0) { ctx.scale(-1,1); }
      const ox = -7*s, oy = -12*s;
      const legOff = frame===0?0:frame===1?-s:s;
      // Os cr√¢ne
      ctx.fillStyle = '#e8e0c8';
      ctx.fillRect(ox+2*s, oy+0*s, 10*s, 8*s);
      ctx.fillRect(ox+1*s, oy+2*s, 12*s, 6*s);
      // Yeux noirs
      ctx.fillStyle = '#000';
      ctx.fillRect(ox+3*s, oy+2*s, 3*s, 3*s);
      ctx.fillRect(ox+8*s, oy+2*s, 3*s, 3*s);
      // Nez
      ctx.fillRect(ox+6*s, oy+5*s, 2*s, s);
      // Dents
      ctx.fillStyle = '#e8e0c8';
      ctx.fillRect(ox+3*s, oy+7*s, 8*s, 2*s);
      ctx.fillStyle = '#222';
      for(let i=0;i<3;i++) ctx.fillRect(ox+(4+i*2)*s, oy+7*s, s, 2*s);
      // Colonne
      ctx.fillStyle = '#d4ccb0';
      for(let i=0;i<3;i++) ctx.fillRect(ox+6*s, oy+(9+i*2)*s, 2*s, s);
      // C√¥tes
      ctx.strokeStyle = '#d4ccb0'; ctx.lineWidth = s*0.7;
      for(let i=0;i<2;i++){
        ctx.beginPath(); ctx.moveTo(ox+6*s,oy+(10+i*2)*s); ctx.lineTo(ox+2*s,oy+(11+i*2)*s); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(ox+8*s,oy+(10+i*2)*s); ctx.lineTo(ox+12*s,oy+(11+i*2)*s); ctx.stroke();
      }
      // Bras
      ctx.fillStyle = '#d4ccb0';
      ctx.fillRect(ox+0*s, oy+9*s, 2*s, 6*s);
      ctx.fillRect(ox+12*s, oy+9*s, 2*s, 6*s);
      // Mains
      ctx.fillRect(ox-s, oy+14*s, 3*s, 2*s);
      ctx.fillRect(ox+12*s, oy+14*s, 3*s, 2*s);
      // Jambes
      ctx.fillRect(ox+3*s, oy+17*s+legOff, 2*s, 5*s);
      ctx.fillRect(ox+9*s, oy+17*s-legOff, 2*s, 5*s);
      // Pieds
      ctx.fillRect(ox+2*s, oy+21*s+legOff, 4*s, s);
      ctx.fillRect(ox+8*s, oy+21*s-legOff, 4*s, s);
      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ ZOMBIE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawZombie(ctx, cx, cy, dir, frame, scale = 1.8, alpha = 1) {
      const s = scale; ctx.save(); ctx.translate(cx, cy); ctx.globalAlpha *= alpha;
      if (dir < 0) { ctx.scale(-1,1); }
      const ox = -8*s, oy = -13*s;
      const legOff = frame===1?-s:frame===2?s:0;
      // Corps
      ctx.fillStyle = '#3a6a2a';
      ctx.fillRect(ox+2*s, oy+9*s, 12*s, 10*s);
      // D√©chirures
      ctx.fillStyle = '#2a5020';
      ctx.fillRect(ox+4*s, oy+10*s, 2*s, 5*s);
      ctx.fillRect(ox+10*s, oy+12*s, 2*s, 4*s);
      // T√™te
      ctx.fillStyle = '#4a7a38';
      ctx.fillRect(ox+3*s, oy+1*s, 10*s, 9*s);
      // Plaie
      ctx.fillStyle = '#8b0000';
      ctx.fillRect(ox+5*s, oy+4*s, 6*s, 2*s);
      // Yeux jaunes
      ctx.fillStyle = '#aaff00';
      ctx.fillRect(ox+4*s, oy+2*s, 3*s, 3*s);
      ctx.fillRect(ox+9*s, oy+2*s, 3*s, 3*s);
      ctx.fillStyle = '#000';
      ctx.fillRect(ox+5*s, oy+3*s, s, s);
      ctx.fillRect(ox+10*s, oy+3*s, s, s);
      // Bouche
      ctx.fillStyle = '#1a0000';
      ctx.fillRect(ox+4*s, oy+7*s, 8*s, 2*s);
      ctx.fillStyle = '#cc2200'; ctx.fillRect(ox+6*s, oy+7*s, 4*s, s);
      // Bras tendus (zombie!)
      ctx.fillStyle = '#3a6a2a';
      ctx.fillRect(ox-2*s, oy+9*s, 4*s, 3*s); // bras gauche tendu
      ctx.fillRect(ox+14*s, oy+8*s, 4*s, 3*s);// bras droit tendu
      ctx.fillRect(ox-4*s, oy+10*s, 3*s, s);   // main g
      ctx.fillRect(ox+16*s, oy+9*s, 3*s, s);   // main d
      // Jambes lentes
      ctx.fillStyle = '#2a5020';
      ctx.fillRect(ox+3*s, oy+19*s+legOff, 4*s, 4*s);
      ctx.fillRect(ox+9*s, oy+19*s-legOff, 4*s, 4*s);
      ctx.fillStyle = '#1a3010';
      ctx.fillRect(ox+2*s, oy+22*s+legOff, 5*s, 2*s);
      ctx.fillRect(ox+8*s, oy+22*s-legOff, 5*s, 2*s);
      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ FANT√îME ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawGhost(ctx, cx, cy, frame, scale = 1.7, alpha = 1) {
      const s = scale; ctx.save(); ctx.translate(cx, cy); ctx.globalAlpha *= alpha;
      const ox = -7*s, oy = -11*s;
      const float = Math.sin(GS.frame * 0.08) * 3;
      const pulse = (Math.sin(GS.frame*0.12)+1)/2;
      // Corps translucide
      ctx.fillStyle = `rgba(180,200,255,${0.65+0.15*pulse})`;
      ctx.beginPath();
      ctx.arc(ox+7*s, oy+6*s+float, 7*s, Math.PI, 0);
      ctx.lineTo(ox+14*s, oy+14*s+float);
      // bord ondul√© bas
      for(let i=0;i<3;i++){
        ctx.lineTo(ox+(12-i*4)*s, oy+(12+i%2*3)*s+float);
      }
      ctx.lineTo(ox+0*s, oy+14*s+float);
      ctx.closePath(); ctx.fill();
      // Yeux
      ctx.fillStyle = `rgba(40,0,120,${0.9})`;
      ctx.fillRect(ox+3*s, oy+4*s+float, 3*s, 4*s);
      ctx.fillRect(ox+8*s, oy+4*s+float, 3*s, 4*s);
      // reflet yeux
      ctx.fillStyle = `rgba(150,150,255,0.8)`;
      ctx.fillRect(ox+3*s, oy+4*s+float, s, s);
      ctx.fillRect(ox+8*s, oy+4*s+float, s, s);
      // Bouche
      ctx.fillStyle = `rgba(40,0,120,0.7)`;
      ctx.fillRect(ox+4*s, oy+9*s+float, 6*s, 2*s);
      // tra√Æn√© fant√¥me
      ctx.fillStyle = `rgba(180,200,255,${0.12*pulse})`;
      ctx.fillRect(ox+2*s, oy+14*s+float, 10*s, 4*s);
      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ CHEVALIER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawKnight(ctx, cx, cy, dir, frame, scale = 1.8, alpha = 1) {
      const s = scale; ctx.save(); ctx.translate(cx, cy); ctx.globalAlpha *= alpha;
      if (dir < 0) ctx.scale(-1,1);
      const ox = -8*s, oy = -14*s;
      const legOff = frame===1?-s:frame===2?s:0;
      // Bouclier
      ctx.fillStyle = '#c8a020';
      ctx.fillRect(ox-2*s, oy+9*s, 5*s, 8*s);
      ctx.fillStyle = '#8b5e00'; ctx.fillRect(ox-s, oy+10*s, 3*s, 6*s);
      ctx.fillStyle = '#ffd700'; ctx.fillRect(ox, oy+12*s, s, 2*s);
      // Corps armure
      ctx.fillStyle = '#888888';
      ctx.fillRect(ox+3*s, oy+8*s, 12*s, 12*s);
      ctx.fillStyle = '#aaaaaa'; ctx.fillRect(ox+4*s, oy+9*s, 10*s, 5*s);
      // D√©tails armure
      ctx.fillStyle = '#666'; ctx.fillRect(ox+4*s, oy+13*s, 10*s, s);
      ctx.fillStyle = '#c8a020'; ctx.fillRect(ox+8*s, oy+10*s, 2*s, 3*s);
      // Casque
      ctx.fillStyle = '#777';
      ctx.fillRect(ox+3*s, oy+1*s, 12*s, 8*s);
      ctx.fillStyle = '#999'; ctx.fillRect(ox+4*s, oy+2*s, 10*s, 4*s);
      // Visi√®re
      ctx.fillStyle = '#333'; ctx.fillRect(ox+5*s, oy+5*s, 8*s, 3*s);
      // Yeux (fente)
      ctx.fillStyle = '#ff6600';
      ctx.fillRect(ox+5*s, oy+5*s, 3*s, s);
      ctx.fillRect(ox+10*s, oy+5*s, 3*s, s);
      // Plumet
      ctx.fillStyle = '#cc0000';
      ctx.fillRect(ox+7*s, oy-2*s, 4*s, 4*s);
      ctx.fillRect(ox+8*s, oy-4*s, 2*s, 3*s);
      // Bras + √©p√©e
      ctx.fillStyle = '#777';
      ctx.fillRect(ox+15*s, oy+8*s, 3*s, 6*s);
      // √âp√©e
      ctx.fillStyle = '#ccc'; ctx.fillRect(ox+17*s, oy+2*s, 2*s, 10*s);
      ctx.fillStyle = '#c8a020'; ctx.fillRect(ox+15*s, oy+8*s, 6*s, 2*s);
      ctx.fillStyle = '#888'; ctx.fillRect(ox+17*s, oy+11*s, 2*s, s);
      // Jambes
      ctx.fillStyle = '#666';
      ctx.fillRect(ox+4*s, oy+20*s+legOff, 4*s, 5*s);
      ctx.fillRect(ox+10*s, oy+20*s-legOff, 4*s, 5*s);
      ctx.fillStyle = '#444';
      ctx.fillRect(ox+3*s, oy+24*s+legOff, 5*s, 2*s);
      ctx.fillRect(ox+9*s, oy+24*s-legOff, 5*s, 2*s);
      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ G√âANT DE GLACE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawIceGiant(ctx, cx, cy, dir, frame, scale = 2.0, alpha = 1) {
      const s = scale; ctx.save(); ctx.translate(cx, cy); ctx.globalAlpha *= alpha;
      if (dir < 0) ctx.scale(-1,1);
      const ox = -11*s, oy = -16*s;
      const legOff = frame===1?-s*1.5:frame===2?s*1.5:0;
      const pulse = (Math.sin(GS.frame*0.08)+1)/2;
      // Aura glace
      ctx.fillStyle = `rgba(100,200,255,${0.1+0.08*pulse})`;
      ctx.beginPath(); ctx.ellipse(0, 4*s, 18*s, 10*s, 0, 0, Math.PI*2); ctx.fill();
      // Corps massif glace
      ctx.fillStyle = '#4488cc';
      ctx.fillRect(ox+3*s, oy+10*s, 16*s, 16*s);
      // Cristaux dos
      ctx.fillStyle = '#88ccff';
      ctx.fillRect(ox+5*s, oy+10*s, 12*s, 3*s);
      // Ventre
      ctx.fillStyle = '#66aaee';
      ctx.fillRect(ox+5*s, oy+16*s, 12*s, 7*s);
      // Craquelures glace
      ctx.strokeStyle = '#aaddff'; ctx.lineWidth = s*0.5;
      ctx.beginPath(); ctx.moveTo(ox+6*s, oy+14*s); ctx.lineTo(ox+10*s, oy+20*s); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(ox+14*s, oy+13*s); ctx.lineTo(ox+11*s, oy+19*s); ctx.stroke();
      // Cristaux √©paules
      ctx.fillStyle = '#aaddff';
      ctx.beginPath(); ctx.moveTo(ox+2*s, oy+10*s); ctx.lineTo(ox, oy+6*s); ctx.lineTo(ox+4*s, oy+10*s); ctx.closePath(); ctx.fill();
      ctx.beginPath(); ctx.moveTo(ox+18*s, oy+10*s); ctx.lineTo(ox+22*s, oy+6*s); ctx.lineTo(ox+20*s, oy+10*s); ctx.closePath(); ctx.fill();
      // Bras
      ctx.fillStyle = '#3377bb';
      ctx.fillRect(ox+0*s, oy+10*s, 4*s, 10*s);
      ctx.fillRect(ox+18*s, oy+10*s, 4*s, 10*s);
      // Poings
      ctx.fillStyle = '#4488cc'; ctx.fillRect(ox-s, oy+19*s, 5*s, 4*s);
      ctx.fillStyle = '#4488cc'; ctx.fillRect(ox+18*s, oy+19*s, 5*s, 4*s);
      // Cristaux poings
      ctx.fillStyle = '#88ddff'; ctx.fillRect(ox-2*s, oy+18*s, 2*s, 3*s); ctx.fillRect(ox+22*s, oy+18*s, 2*s, 3*s);
      // T√™te
      ctx.fillStyle = '#3377bb';
      ctx.fillRect(ox+4*s, oy+3*s, 14*s, 8*s);
      // Cr√™te cristaux
      ctx.fillStyle = '#aaddff';
      for(let i=0;i<3;i++) { ctx.beginPath(); ctx.moveTo(ox+(5+i*4)*s, oy+3*s); ctx.lineTo(ox+(6+i*4)*s, oy, oy+0*s); ctx.lineTo(ox+(7+i*4)*s, oy+3*s); ctx.closePath(); ctx.fill(); }
      // Yeux
      ctx.fillStyle = '#00ccff';
      ctx.fillRect(ox+5*s, oy+5*s, 4*s, 3*s);
      ctx.fillRect(ox+13*s, oy+5*s, 4*s, 3*s);
      ctx.fillStyle = `rgba(0,200,255,${0.5*pulse})`;
      ctx.fillRect(ox+4*s, oy+4*s, 6*s, 5*s); ctx.fillRect(ox+12*s, oy+4*s, 6*s, 5*s);
      // Bouche
      ctx.fillStyle = '#002244';
      ctx.fillRect(ox+6*s, oy+9*s, 10*s, 2*s);
      ctx.fillStyle = '#aaddff'; for(let i=0;i<3;i++) ctx.fillRect(ox+(7+i*3)*s, oy+9*s, 2*s, 2*s);
      // Jambes
      ctx.fillStyle = '#3377bb';
      ctx.fillRect(ox+4*s, oy+26*s+legOff, 5*s, 6*s);
      ctx.fillRect(ox+13*s, oy+26*s-legOff, 5*s, 6*s);
      ctx.fillStyle = '#2266aa';
      ctx.fillRect(ox+3*s, oy+31*s+legOff, 6*s, 2*s); ctx.fillRect(ox+12*s, oy+31*s-legOff, 6*s, 2*s);
      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ GRIFFON (montagne) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawGriffon(ctx, cx, cy, dir, frame, scale = 1.7, alpha = 1) {
      const s = scale; ctx.save(); ctx.translate(cx, cy); ctx.globalAlpha *= alpha;
      if (dir < 0) ctx.scale(-1,1);
      const ox = -10*s, oy = -10*s;
      const wingOff = frame===1?-2*s:frame===2?2*s:0;
      const legOff = frame===1?-s:frame===2?s:0;
      // Ailes
      ctx.fillStyle = '#8b6a10';
      ctx.beginPath(); ctx.moveTo(ox+10*s,oy+5*s); ctx.lineTo(ox-4*s,oy+0*s+wingOff); ctx.lineTo(ox+0*s,oy+5*s+wingOff); ctx.lineTo(ox+6*s,oy+8*s); ctx.closePath(); ctx.fill();
      ctx.beginPath(); ctx.moveTo(ox+12*s,oy+5*s); ctx.lineTo(ox+24*s,oy+0*s+wingOff); ctx.lineTo(ox+20*s,oy+5*s+wingOff); ctx.lineTo(ox+16*s,oy+8*s); ctx.closePath(); ctx.fill();
      ctx.fillStyle = '#c8a020';
      ctx.fillRect(ox-3*s, oy+s+wingOff, 4*s, s); ctx.fillRect(ox+21*s, oy+s+wingOff, 4*s, s);
      // Corps
      ctx.fillStyle = '#c8a020';
      ctx.fillRect(ox+4*s, oy+5*s, 14*s, 9*s);
      ctx.fillStyle = '#eecc44';
      ctx.fillRect(ox+6*s, oy+6*s, 10*s, 4*s);
      // T√™te d'aigle
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(ox+1*s, oy+1*s, 10*s, 8*s);
      ctx.fillStyle = '#dddddd'; ctx.fillRect(ox+2*s, oy+2*s, 7*s, 5*s);
      // Bec
      ctx.fillStyle = '#cc8800'; ctx.fillRect(ox, oy+5*s, 3*s, 3*s); ctx.fillRect(ox-s, oy+7*s, 3*s, s);
      // Oeil
      ctx.fillStyle = '#ffcc00'; ctx.fillRect(ox+5*s, oy+3*s, 3*s, 3*s);
      ctx.fillStyle = '#000'; ctx.fillRect(ox+6*s, oy+3*s, 2*s, 2*s);
      // Oreilles/huppe
      ctx.fillStyle = '#c8a020'; ctx.fillRect(ox+7*s, oy, 3*s, 2*s); ctx.fillRect(ox+6*s, oy-2*s, s, 3*s); ctx.fillRect(ox+10*s, oy-2*s, s, 3*s);
      // Queue
      ctx.fillStyle = '#c8a020';
      ctx.fillRect(ox+18*s, oy+5*s, 4*s, 4*s);
      ctx.fillRect(ox+20*s, oy+3*s+legOff, 2*s, 4*s);
      ctx.fillRect(ox+21*s, oy+1*s+legOff, s, 3*s);
      // Pattes avec griffes
      ctx.fillStyle = '#aa8810';
      ctx.fillRect(ox+5*s, oy+13*s+legOff, 3*s, 4*s);
      ctx.fillRect(ox+13*s, oy+13*s-legOff, 3*s, 4*s);
      ctx.fillStyle = '#888';
      ctx.fillRect(ox+4*s, oy+16*s+legOff, s, 2*s); ctx.fillRect(ox+6*s, oy+17*s+legOff, s, 2*s); ctx.fillRect(ox+8*s, oy+16*s+legOff, s, 2*s);
      ctx.fillRect(ox+12*s, oy+16*s-legOff, s, 2*s); ctx.fillRect(ox+14*s, oy+17*s-legOff, s, 2*s); ctx.fillRect(ox+16*s, oy+16*s-legOff, s, 2*s);
      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ GOLEM (montagne) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawGolem(ctx, cx, cy, dir, frame, scale = 2.0, alpha = 1) {
      const s = scale; ctx.save(); ctx.translate(cx, cy); ctx.globalAlpha *= alpha;
      if (dir < 0) ctx.scale(-1,1);
      const ox = -12*s, oy = -16*s;
      const legOff = frame===1?-s:frame===2?s:0;
      const pulse = (Math.sin(GS.frame*0.06)+1)/2;
      // Corps massif
      ctx.fillStyle = '#5a5a5a';
      ctx.fillRect(ox+2*s, oy+8*s, 20*s, 18*s);
      ctx.fillStyle = '#707070'; ctx.fillRect(ox+3*s, oy+9*s, 18*s, 8*s);
      // Fissures lumineuses
      ctx.strokeStyle = `rgba(255,${100+Math.floor(100*pulse)},0,${0.6+0.3*pulse})`; ctx.lineWidth = s;
      ctx.beginPath(); ctx.moveTo(ox+8*s, oy+12*s); ctx.lineTo(ox+12*s, oy+20*s); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(ox+15*s, oy+11*s); ctx.lineTo(ox+13*s, oy+18*s); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(ox+6*s, oy+18*s); ctx.lineTo(ox+10*s, oy+24*s); ctx.stroke();
      // √âpauli√®res rocheuses
      ctx.fillStyle = '#444';
      ctx.fillRect(ox, oy+8*s, 4*s, 6*s); ctx.fillRect(ox+20*s, oy+8*s, 4*s, 6*s);
      ctx.fillRect(ox-2*s, oy+6*s, 4*s, 4*s); ctx.fillRect(ox+22*s, oy+6*s, 4*s, 4*s);
      // Bras
      ctx.fillStyle = '#5a5a5a';
      ctx.fillRect(ox-2*s, oy+9*s, 4*s, 12*s); ctx.fillRect(ox+22*s, oy+9*s, 4*s, 12*s);
      // Poings
      ctx.fillStyle = '#444';
      ctx.fillRect(ox-3*s, oy+20*s, 5*s, 5*s); ctx.fillRect(ox+22*s, oy+20*s, 5*s, 5*s);
      // T√™te
      ctx.fillStyle = '#4a4a4a';
      ctx.fillRect(ox+4*s, oy+0*s, 16*s, 9*s);
      ctx.fillStyle = '#606060'; ctx.fillRect(ox+5*s, oy+s, 14*s, 4*s);
      // Yeux de magma
      ctx.fillStyle = `rgba(255,${80+Math.floor(120*pulse)},0,1)`;
      ctx.fillRect(ox+5*s, oy+2*s, 5*s, 4*s); ctx.fillRect(ox+14*s, oy+2*s, 5*s, 4*s);
      ctx.fillStyle = '#fff'; ctx.fillRect(ox+5*s, oy+2*s, 2*s, s); ctx.fillRect(ox+14*s, oy+2*s, 2*s, s);
      // Bouche
      ctx.fillStyle = `rgba(255,60,0,${0.7+0.2*pulse})`;
      ctx.fillRect(ox+6*s, oy+7*s, 12*s, 2*s);
      for(let i=0;i<3;i++) { ctx.fillStyle='#333'; ctx.fillRect(ox+(7+i*3)*s, oy+7*s, 2*s, 2*s); }
      // Jambes
      ctx.fillStyle = '#4a4a4a';
      ctx.fillRect(ox+4*s, oy+26*s+legOff, 6*s, 6*s); ctx.fillRect(ox+14*s, oy+26*s-legOff, 6*s, 6*s);
      ctx.fillStyle = '#333'; ctx.fillRect(ox+3*s, oy+31*s+legOff, 7*s, 2*s); ctx.fillRect(ox+13*s, oy+31*s-legOff, 7*s, 2*s);
      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ √âL√âMENTAL DE NEIGE (montagne) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawElemental(ctx, cx, cy, frame, scale = 1.7, alpha = 1) {
      const s = scale; ctx.save(); ctx.translate(cx, cy); ctx.globalAlpha *= alpha;
      const ox = -8*s, oy = -12*s;
      const pulse = (Math.sin(GS.frame*0.1)+1)/2;
      const spin = GS.frame * 0.05;
      // Tourbillon neige ext√©rieur
      ctx.strokeStyle = `rgba(180,220,255,${0.3+0.2*pulse})`; ctx.lineWidth = s;
      for(let i=0;i<3;i++){
        ctx.beginPath(); ctx.arc(0, 0, (8+i*4)*s, spin+i*Math.PI*0.6, spin+i*Math.PI*0.6+Math.PI*1.4); ctx.stroke();
      }
      // Corps neige/glace
      ctx.fillStyle = `rgba(180,220,255,${0.75+0.15*pulse})`;
      ctx.beginPath(); ctx.arc(ox+8*s, oy+8*s, 8*s, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = `rgba(220,240,255,${0.5+0.2*pulse})`;
      ctx.beginPath(); ctx.arc(ox+8*s, oy+6*s, 6*s, 0, Math.PI*2); ctx.fill();
      // Cristaux internes
      ctx.fillStyle = '#aaddff';
      for(let i=0;i<4;i++){
        const a2 = spin*2 + i*Math.PI/2;
        ctx.fillRect(ox+8*s+Math.cos(a2)*4*s-s, oy+8*s+Math.sin(a2)*4*s-s, 2*s, 2*s);
      }
      // Yeux
      ctx.fillStyle = '#0044aa';
      ctx.fillRect(ox+4*s, oy+5*s, 3*s, 4*s); ctx.fillRect(ox+9*s, oy+5*s, 3*s, 4*s);
      ctx.fillStyle = '#00aaff'; ctx.fillRect(ox+4*s, oy+5*s, s, s); ctx.fillRect(ox+9*s, oy+5*s, s, s);
      // Bouche
      ctx.fillStyle = '#0044aa';
      ctx.fillRect(ox+5*s, oy+10*s, 6*s, s);
      for(let i=0;i<3;i++) { ctx.fillStyle='#88ccff'; ctx.fillRect(ox+(5+i*2)*s, oy+10*s, s, s); }
      // Bras cristaux flottants
      ctx.fillStyle = `rgba(140,200,255,${0.7+0.2*pulse})`;
      ctx.fillRect(ox-2*s, oy+6*s, 3*s, 6*s); ctx.fillRect(ox+15*s, oy+6*s, 3*s, 6*s);
      ctx.fillStyle = '#aaddff'; ctx.fillRect(ox-3*s, oy+5*s, 2*s, 2*s); ctx.fillRect(ox+17*s, oy+5*s, 2*s, 2*s);
      // Bas du corps (fondu en particules)
      for(let i=0;i<5;i++){
        ctx.fillStyle = `rgba(180,220,255,${(0.5-i*0.08)*pulse})`;
        ctx.fillRect(ox+(3+i*2)*s, oy+(14+i)*s, 2*s, 2*s);
      }
      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ Fonctions utilitaires pour obtenir frame/dir par monstre ‚îÄ
    function getMonFrame(m) {
      if (!m._animFrame) { m._animFrame = 0; m._animTimer = 0; }
      m._animTimer++;
      const spd = m.spd > 1.5 ? 6 : m.spd > 0.8 ? 10 : 14;
      if (m._animTimer >= spd) { m._animFrame = (m._animFrame + 1) % 3; m._animTimer = 0; }
      return (m.state === 'idle' || m.state === 'wander') && m.spd < 0.5 ? 0 : m._animFrame;
    }
    function getMonDir(m) {
      // -1=gauche, 1=droite  (pour flip)
      if (!m._dir) m._dir = 1;
      if (m.vx < -0.1) m._dir = -1;
      else if (m.vx > 0.1) m._dir = 1;
      return m._dir;
    }
    function getPlayerDir(p) {
      // 0=bas 1=haut 2=gauche 3=droite
      if (p.fy > 0.3) return 0;
      if (p.fy < -0.3) return 1;
      if (p.fx < 0) return 2;
      return 3;
    }

    // ‚îÄ‚îÄ‚îÄ Sprite picking par type de monstre ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function getMonsterType(m) {
      const n = m.name;
      if (n === 'Loup') return 'wolf';
      if (n === 'Chauve-souris') return 'bat';
      if (n === 'Araign√©e') return 'spider';
      if (n === 'Entit√©') return 'leaf';
      if (n === 'Squelette') return 'skeleton';
      if (n === 'Zombie') return 'zombie';
      if (n === 'Fant√¥me') return 'ghost';
      if (n === 'Chevalier') return 'knight';
      if (n === 'G√©ant de Glace') return 'iceGiant';
      if (n === 'Griffon') return 'griffon';
      if (n === 'Golem') return 'golem';
      if (n === '√âl√©mental') return 'elemental';
      return null;
    }
    function getBossType(lvl) {
      if (lvl === 0) return 'demon';
      if (lvl === 1) return 'king';
      return 'dragon';
    }

    // ============================================================
    // TITLE ANIMATION
    // ============================================================
    let titleFrame = 0;
    function animateTitle() {
      if (document.getElementById('title').style.display === 'none') return;
      TC.fillStyle = 'rgba(0,0,0,0.03)'; TC.fillRect(0, 0, tc.width, tc.height); titleFrame++;
      for (let i = 0; i < 3; i++) {
        const x = Math.random() * tc.width, y = Math.random() * tc.height;
        TC.fillStyle = `rgba(255,215,0,${0.2 + Math.random() * 0.4})`; TC.fillRect(x, y, 1 + Math.random() * 2, 1 + Math.random() * 2);
      }
      requestAnimationFrame(animateTitle);
    }
    animateTitle();

    // ============================================================
    // FIREWORKS
    // ============================================================
    function fireworks() {
      const em = ['üéÜ', 'üéá', '‚≠ê', '‚ú®', 'üåü', 'üí´', 'üéâ', '‚ù§Ô∏è', 'üèÜ', 'üéä', 'üí•'];
      for (let i = 0; i < 36; i++)setTimeout(() => {
        const p = document.createElement('div'); p.className = 'particle';
        p.textContent = em[Math.floor(Math.random() * em.length)];
        p.style.left = Math.random() * 100 + 'vw'; p.style.top = Math.random() * 100 + 'vh';
        p.style.setProperty('--dx', (Math.random() - 0.5) * 400 + 'px');
        p.style.setProperty('--dy', (Math.random() - 0.5) * 400 + 'px');
        p.style.setProperty('--rot', (Math.random() * 720 - 360) + 'deg');
        p.style.setProperty('--dur', (1 + Math.random() * 1.2) + 's');
        document.body.appendChild(p); setTimeout(() => p.remove(), 2500);
      }, i * 70);
    }

    // ============================================================
    // MAIN LOOP
    // ============================================================
    function loop() {
      if (!gRun) { requestAnimationFrame(loop); return; }
      GS.frame++;
      let shkX = 0, shkY = 0;
      if (GS.shake > 0) { shkX = (Math.random() - 0.5) * GS.shake; shkY = (Math.random() - 0.5) * GS.shake; GS.shake *= 0.75; if (GS.shake < 0.1) GS.shake = 0; }
      C.fillStyle = LEVELS[curLvl].bgA; C.fillRect(0, 0, canvas.width, canvas.height);
      C.save(); C.translate(Math.round(shkX), Math.round(shkY));
      updPlayer(); updMons(); updProjectiles();
      renderMap(); renderAmbient(); renderDecos(); renderQItems();
      renderBossWarnings();
      renderProjectiles(); renderMons(); renderPlayer(); renderAtks();
      renderBossBeam();
      renderLighting();
      C.restore();
      renderMinimap();
      updSkillBar();
      requestAnimationFrame(loop);
    }

    // ============================================================
    // DETECT MOBILE
    // ============================================================
    function isMobile() { return ('ontouchstart' in window) || navigator.maxTouchPoints > 0 || window.innerWidth < 900; }

    // ============================================================
    // GAME START
    // ============================================================
    function startGame() {
      document.getElementById('title').style.display = 'none';
      document.getElementById('game').style.display = 'block';
      document.getElementById('hud').style.display = 'flex';
      document.getElementById('minimap-wrap').style.display = 'block';
      // Toujours afficher les contr√¥les (mobile ET PC)
      document.getElementById('mobilecontrols').style.display = 'block';
      gRun = true; isDead = false; curLvl = 0;
      const p = GS.p; p.hp = 6; p.maxHp = 6; p.xp = 0; p.lvl = 1; p.wPow = 1;
      p.weapon = '‚öîÔ∏è √âp√©e Rouill√©e'; p.atkCDs = [0, 0, 0, 0];
      p.dashCD = 0; p.invincible = false; p.invincibleTimer = 0;
      loadLevel(0); loop();
    }

  </script>
</body>

</html>
