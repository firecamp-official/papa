<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
  <title>Anniversaire Papa ‚öîÔ∏è ULTIMATE</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323:wght@400&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      image-rendering: pixelated;
      -webkit-tap-highlight-color: transparent;
    }

    html,
    body {
      background: #000;
      overflow: hidden;
      font-family: 'Press Start 2P', monospace;
      touch-action: none;
      width: 100%;
      height: 100%;
    }

    /* ====== TITLE ====== */
    #title {
      position: fixed;
      inset: 0;
      z-index: 300;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: radial-gradient(ellipse at 50% 60%, #0d1a0a 0%, #050a03 100%);
    }

    #title-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
    }

    .title-content {
      position: relative;
      z-index: 2;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding: 0 20px;
      width: 100%;
    }

    .title-logo {
      font-size: clamp(13px, 3.5vw, 26px);
      color: #ffd700;
      text-align: center;
      line-height: 2.2;
      text-shadow: 0 0 20px #ffd700aa, 4px 4px 0 #8b5e00, 8px 8px 0 #3a2500;
      animation: logoPulse 3s ease-in-out infinite;
      letter-spacing: 2px;
    }

    .title-tagline {
      font-family: 'VT323', monospace;
      font-size: clamp(18px, 4vw, 32px);
      color: #e8d890;
      text-shadow: 2px 2px 0 #553300;
      letter-spacing: 3px;
    }

    .title-sword {
      font-size: clamp(50px, 10vw, 80px);
      animation: swordFloat 2.5s ease-in-out infinite;
      filter: drop-shadow(0 0 20px #ffd700);
    }

    .start-btn {
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(9px, 2vw, 13px);
      background: linear-gradient(180deg, #c8a020 0%, #8b5e00 100%);
      color: #000;
      border: none;
      padding: 14px 32px;
      cursor: pointer;
      box-shadow: 0 0 0 3px #ffd700, 0 0 0 5px #000, 4px 4px 0 #000;
      margin-top: 6px;
      letter-spacing: 1px;
    }

    .start-btn:active {
      transform: translate(3px, 3px);
      box-shadow: 0 0 0 3px #ffd700, 0 0 0 5px #000, 1px 1px 0 #000;
    }

    .title-features {
      font-family: 'VT323', monospace;
      font-size: clamp(13px, 3vw, 19px);
      color: #9a8a60;
      text-align: center;
      line-height: 1.9;
      margin-top: 4px;
    }

    @keyframes logoPulse {

      0%,
      100% {
        text-shadow: 0 0 20px #ffd700aa, 4px 4px 0 #8b5e00, 8px 8px 0 #3a2500;
      }

      50% {
        text-shadow: 0 0 40px #ffd700, 4px 4px 0 #ffd700, 8px 8px 0 #8b5e00, 0 0 80px #ffd70066;
      }
    }

    @keyframes swordFloat {

      0%,
      100% {
        transform: translateY(0) rotate(-30deg);
      }

      50% {
        transform: translateY(-12px) rotate(-38deg);
      }
    }

    @keyframes blinkAnim {
      50% {
        opacity: 0;
      }
    }

    /* ====== GAME ====== */
    #game {
      position: fixed;
      inset: 0;
      display: none;
    }

    #gc {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* ====== HUD ====== */
    #hud {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 64px;
      z-index: 100;
      pointer-events: none;
      background: linear-gradient(180deg, rgba(2, 2, 10, 0.99) 0%, rgba(3, 3, 14, 0.92) 100%);
      border-bottom: 2px solid rgba(255, 215, 0, 0.35);
      box-shadow: 0 3px 0 rgba(255, 215, 0, 0.08), 0 6px 20px rgba(0, 0, 0, 0.9);
    }

    .hud-inner {
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: 100%;
      padding: 0 14px;
      gap: 8px;
    }

    .hud-block {
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .hud-label {
      font-size: clamp(5px, 1.5vw, 7px);
      color: rgba(255, 215, 0, 0.7);
      letter-spacing: 2px;
      text-transform: uppercase;
    }

    .hud-val {
      font-size: clamp(7px, 2vw, 11px);
      color: #ffd700;
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
    }

    .hearts-row {
      display: flex;
      gap: 3px;
      align-items: center;
      flex-wrap: wrap;
      max-width: 180px;
    }

    .heart-full {
      width: 16px;
      height: 16px;
      background: linear-gradient(135deg, #ff4444, #cc1111);
      border: 1.5px solid #ff6666;
      clip-path: polygon(50% 90%, 0% 35%, 15% 10%, 50% 25%, 85% 10%, 100% 35%);
      box-shadow: 0 0 8px rgba(255, 50, 50, 0.7), inset 0 1px 0 rgba(255, 180, 180, 0.3);
    }

    .heart-empty {
      width: 16px;
      height: 16px;
      background: #1c0808;
      border: 1.5px solid #441818;
      clip-path: polygon(50% 90%, 0% 35%, 15% 10%, 50% 25%, 85% 10%, 100% 35%);
    }

    .xp-bar-wrap {
      width: 90px;
      height: 6px;
      background: #080818;
      border: 1px solid rgba(40, 80, 200, 0.4);
      border-radius: 3px;
      overflow: hidden;
    }

    .xp-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #1166ff, #00eeff);
      transition: width .3s;
      border-radius: 3px;
      box-shadow: inset 0 0 6px rgba(0, 200, 255, 0.4);
    }

    .weapon-badge {
      font-size: clamp(5px, 1.5vw, 8px);
      color: #ffdd55;
      background: rgba(255, 200, 0, 0.07);
      border: 1px solid rgba(255, 215, 0, 0.25);
      padding: 3px 7px;
      text-shadow: 0 0 8px rgba(255, 200, 0, 0.4);
    }

    .hud-quest-text {
      font-size: clamp(5px, 1.4vw, 7.5px);
      color: #ccbbaa;
      max-width: 140px;
      line-height: 1.7;
      text-align: right;
    }

    .lvl-badge {
      font-size: clamp(6px, 1.6vw, 9px);
      color: #44ddff;
      text-shadow: 0 0 8px rgba(0, 200, 255, 0.6);
    }

    /* ====== BOSS HP BAR ====== */
    #boss-hud {
      position: fixed;
      top: 64px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
      width: min(400px, 88vw);
      display: none;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      padding: 7px 14px 8px;
      background: rgba(2, 2, 10, 0.97);
      border: 1.5px solid rgba(255, 60, 60, 0.4);
      border-top: none;
      box-shadow: 0 8px 28px rgba(255, 0, 0, 0.2), inset 0 -1px 0 rgba(255, 50, 50, 0.1);
    }

    #boss-hud-name {
      font-size: clamp(7px, 2vw, 11px);
      color: #ff9999;
      letter-spacing: 3px;
      text-align: center;
      text-shadow: 0 0 12px rgba(255, 60, 60, 0.5);
    }

    #boss-hp-wrap {
      width: 100%;
      height: 14px;
      background: #100000;
      border: 1px solid rgba(255, 50, 50, 0.2);
      border-radius: 2px;
      overflow: hidden;
      position: relative;
    }

    #boss-hp-fill {
      height: 100%;
      background: linear-gradient(90deg, #bb0000, #ff4400, #ff8800);
      transition: width .15s;
      border-radius: 2px;
      box-shadow: inset 0 2px 0 rgba(255, 200, 200, 0.2), 0 0 8px rgba(255, 60, 0, 0.4);
    }

    #boss-hp-wrap::after {
      content: '';
      position: absolute;
      inset: 0;
      background: repeating-linear-gradient(90deg, transparent, transparent 24px, rgba(0, 0, 0, 0.25) 24px, rgba(0, 0, 0, 0.25) 25px);
    }

    #boss-phase-wrap {
      width: 100%;
      display: flex;
      justify-content: center;
      gap: 8px;
      margin-top: 2px;
    }

    .boss-phase-pip {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #160000;
      border: 1.5px solid rgba(255, 50, 50, 0.3);
    }

    .boss-phase-pip.active {
      background: #ff2222;
      box-shadow: 0 0 10px #ff2222, 0 0 20px rgba(255, 0, 0, 0.4);
    }

    /* ====== MINIMAP ====== */
    #minimap-wrap {
      position: fixed;
      top: 80px;
      right: 10px;
      z-index: 90;
      background: rgba(2, 2, 10, 0.96);
      border: 2px solid rgba(255, 215, 0, 0.55);
      box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.9), 0 6px 20px rgba(0, 0, 0, 0.8),
        0 0 16px rgba(255, 215, 0, 0.1), inset 0 0 10px rgba(0, 0, 0, 0.5);
    }

    #minimap-wrap::before {
      content: 'CARTE';
      position: absolute;
      top: -16px;
      left: 0;
      right: 0;
      text-align: center;
      font-size: 7px;
      color: rgba(255, 215, 0, 0.8);
      letter-spacing: 3px;
      text-shadow: 0 0 8px rgba(255, 215, 0, 0.4);
    }

    #mmc {
      display: block;
      width: 110px;
      height: 74px;
    }

    /* ====== DIALOG ====== */
    #dialog {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      z-index: 200;
      display: none;
      background: linear-gradient(0deg, rgba(5, 5, 15, 0.99) 0%, rgba(8, 8, 25, 0.96) 100%);
      border-top: 2px solid #ffd70066;
      box-shadow: 0 -10px 40px rgba(0, 0, 0, 0.9);
    }

    .dlg-inner {
      display: grid;
      grid-template-columns: 64px 1fr;
      min-height: 80px;
      padding: 10px 14px 10px 0;
    }

    .dlg-portrait-wrap {
      display: flex;
      align-items: flex-start;
      justify-content: center;
    }

    .dlg-portrait-box {
      width: 50px;
      height: 50px;
      background: linear-gradient(135deg, #0d0d1a, #1a1a35);
      border: 2px solid #ffd70066;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      flex-shrink: 0;
    }

    .dlg-body {
      padding-left: 10px;
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .dlg-name {
      font-size: clamp(5px, 1.5vw, 7px);
      color: #ffd700;
      letter-spacing: 2px;
      border-bottom: 1px solid #ffd70022;
      padding-bottom: 3px;
      margin-bottom: 2px;
    }

    #dlg-text {
      font-family: 'VT323', monospace;
      font-size: clamp(16px, 4vw, 21px);
      color: #e8e0c0;
      line-height: 1.5;
      min-height: 40px;
    }

    .dlg-actions {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-top: 4px;
    }

    .dlg-continue {
      font-size: 7px;
      color: #ffd70088;
      animation: blinkAnim 0.8s step-end infinite;
    }

    .dlg-btn {
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(5px, 1.4vw, 7px);
      background: linear-gradient(180deg, #8b5e00, #4a3000);
      color: #ffd700;
      border: none;
      padding: 7px 14px;
      cursor: pointer;
      box-shadow: 0 0 0 1px #ffd70055, 2px 2px 0 #000;
      pointer-events: all;
    }

    .dlg-btn:active {
      transform: translate(1px, 1px);
    }

    /* ====== DEATH SCREEN ====== */
    #deathscreen {
      position: fixed;
      inset: 0;
      z-index: 270;
      display: none;
      background: rgba(80, 0, 0, 0.97);
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 16px;
    }

    .death-icon {
      font-size: 70px;
      animation: deathPulse 1.5s ease-in-out infinite;
    }

    .death-title {
      font-size: clamp(14px, 3.5vw, 28px);
      color: #ff4444;
      text-align: center;
      text-shadow: 3px 3px 0 #600, 0 0 40px #ff0000;
      line-height: 1.8;
    }

    .death-msg {
      font-family: 'VT323', monospace;
      font-size: clamp(16px, 4vw, 26px);
      color: #ff9988;
      text-align: center;
      max-width: 420px;
      padding: 0 20px;
      line-height: 1.7;
    }

    .death-btn {
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(9px, 2vw, 12px);
      background: linear-gradient(180deg, #cc2020, #8b0000);
      color: #fff;
      border: none;
      padding: 13px 26px;
      cursor: pointer;
      box-shadow: 0 0 0 2px #ff4444, 0 0 0 4px #000, 4px 4px 0 #000;
    }

    .death-btn:active {
      transform: translate(3px, 3px);
    }

    @keyframes deathPulse {

      0%,
      100% {
        transform: scale(1);
      }

      50% {
        transform: scale(1.12);
      }
    }

    /* ====== LEVEL TRANSITION ====== */
    #leveltrans {
      position: fixed;
      inset: 0;
      z-index: 250;
      display: none;
      background: rgba(0, 0, 0, 0.97);
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 14px;
    }

    .lt-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      text-align: center;
      padding: 0 20px;
    }

    .lt-icon {
      font-size: 56px;
      filter: drop-shadow(0 0 30px #ffd700);
    }

    .lt-title {
      font-size: clamp(11px, 3vw, 20px);
      color: #ffd700;
      text-shadow: 3px 3px 0 #8b5e00;
      line-height: 1.8;
    }

    .lt-zone {
      font-family: 'VT323', monospace;
      font-size: clamp(16px, 4vw, 26px);
      color: #e8d890;
    }

    .lt-reward {
      font-size: clamp(7px, 1.8vw, 10px);
      color: #88ccff;
      line-height: 2;
      background: rgba(0, 100, 200, 0.1);
      border: 1px solid #88ccff33;
      padding: 8px 16px;
    }

    .lt-next-btn {
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(8px, 2vw, 11px);
      background: linear-gradient(180deg, #c8a020, #8b5e00);
      color: #000;
      border: none;
      padding: 12px 24px;
      cursor: pointer;
      box-shadow: 0 0 0 2px #ffd700, 0 0 0 4px #000, 4px 4px 0 #000;
    }

    .lt-next-btn:active {
      transform: translate(3px, 3px);
    }

    /* ====== VICTORY ====== */
    #victory {
      position: fixed;
      inset: 0;
      z-index: 260;
      display: none;
      background: rgba(0, 0, 0, 0.97);
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
    }

    .vic-title {
      font-size: clamp(12px, 3.5vw, 24px);
      color: #ffd700;
      text-align: center;
      text-shadow: 3px 3px 0 #8b5e00;
      animation: logoPulse 2s infinite;
      line-height: 1.8;
    }

    .vic-msg {
      font-family: 'VT323', monospace;
      font-size: clamp(15px, 4vw, 26px);
      color: #e8d890;
      text-align: center;
      max-width: 500px;
      padding: 0 20px;
      line-height: 1.7;
    }

    .vic-btn {
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(8px, 2vw, 11px);
      background: linear-gradient(180deg, #c8a020, #8b5e00);
      color: #000;
      border: none;
      padding: 12px 22px;
      cursor: pointer;
      box-shadow: 0 0 0 2px #ffd700, 0 0 0 4px #000, 4px 4px 0 #000;
    }

    /* ====== PARTICLES ====== */
    .particle {
      position: fixed;
      pointer-events: none;
      z-index: 280;
      font-size: 20px;
      animation: particleFly var(--dur) ease-out forwards;
    }

    @keyframes particleFly {
      0% {
        opacity: 1;
        transform: translate(0, 0) scale(1) rotate(0deg);
      }

      100% {
        opacity: 0;
        transform: translate(var(--dx), var(--dy)) scale(0) rotate(var(--rot));
      }
    }

    /* ====== DAMAGE NUMBERS ====== */
    .dmg {
      position: fixed;
      pointer-events: none;
      z-index: 180;
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(8px, 2vw, 12px);
      animation: dmgAnim 0.85s ease-out forwards;
    }

    .dmg.heal {
      color: #44ff88;
      text-shadow: 0 0 8px #44ff88;
    }

    .dmg.crit {
      color: #ffff00;
      font-size: clamp(11px, 2.8vw, 17px);
      text-shadow: 0 0 12px #ffff00;
    }

    .dmg.normal {
      color: #ff4444;
      text-shadow: 0 0 8px #ff4444;
    }

    .dmg.ice {
      color: #88ccff;
      text-shadow: 0 0 8px #88ccff;
    }

    .dmg.fire {
      color: #ff8822;
      text-shadow: 0 0 8px #ff8822;
    }

    .dmg.spin {
      color: #cc44ff;
      text-shadow: 0 0 8px #cc44ff;
    }

    .dmg.boss {
      color: #ff0000;
      font-size: clamp(13px, 3.5vw, 20px);
      text-shadow: 0 0 15px #ff0000, 0 0 30px #ff000088;
    }

    @keyframes dmgAnim {
      0% {
        opacity: 1;
        transform: translateY(0) scale(1);
      }

      30% {
        opacity: 1;
        transform: translateY(-20px) scale(1.2);
      }

      100% {
        opacity: 0;
        transform: translateY(-65px) scale(0.6);
      }
    }

    /* ====== SCANLINES ====== */
    #scanlines {
      position: fixed;
      inset: 0;
      z-index: 500;
      pointer-events: none;
      background: repeating-linear-gradient(0deg, transparent, transparent 3px, rgba(0, 0, 0, 0.04) 3px, rgba(0, 0, 0, 0.04) 4px);
    }

    #atkflash {
      position: fixed;
      inset: 0;
      z-index: 170;
      pointer-events: none;
      opacity: 0;
      background: radial-gradient(ellipse at center, rgba(255, 255, 255, 0.25) 0%, transparent 70%);
      transition: opacity 0.1s;
    }

    /* ====== WARNING OVERLAY ====== */
    #warn-overlay {
      position: fixed;
      inset: 0;
      z-index: 165;
      pointer-events: none;
      opacity: 0;
      background: rgba(255, 0, 0, 0.08);
      border: 4px solid rgba(255, 0, 0, 0);
      transition: opacity 0.08s, border-color 0.08s;
    }

    /* ====== MOBILE CONTROLS ====== */
    /* Zone enti√®re ‚Äî fixe en bas, jamais superpos√©e au jeu */
    #mobilecontrols {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 180px;
      z-index: 96;
      pointer-events: none;
      display: none;
      background: linear-gradient(0deg, rgba(2, 2, 10, 0.26) 0%, rgba(2, 2, 10, 0.144) 65%, transparent 100%);
    }

    /* ‚îÄ‚îÄ JOYSTICK (moiti√© gauche) ‚îÄ‚îÄ */
    #joystick-col {
      position: absolute;
      left: 0;
      bottom: 0;
      width: 48%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: all;
    }

    #joystick-zone {
      width: 144px;
      height: 144px;
      position: relative;
      pointer-events: all;
    }

    #joystick-base {
      position: absolute;
      inset: 0;
      border-radius: 50%;
      background: rgba(255, 215, 0, 0.05);
      border: 2px solid rgba(255, 215, 0, 0.22);
      /* cercles concentriques d√©coratifs via box-shadow */
      box-shadow: inset 0 0 0 42px rgba(255, 215, 0, 0.03),
        inset 0 0 0 70px rgba(0, 0, 0, 0.1);
    }

    /* croix directionnelle subtile */
    #joystick-base::before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 50%;
      background:
        linear-gradient(rgba(255, 215, 0, 0.07) 0, rgba(255, 215, 0, 0.07) 100%) center/2px 70% no-repeat,
        linear-gradient(rgba(255, 215, 0, 0.07) 0, rgba(255, 215, 0, 0.07) 100%) center/70% 2px no-repeat;
    }

    #joystick-knob {
      position: absolute;
      width: 56px;
      height: 56px;
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: radial-gradient(circle at 38% 32%, rgba(255, 245, 150, 0.96), rgba(210, 140, 0, 0.88));
      border: 2.5px solid rgba(255, 215, 0, 1);
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.55), 0 4px 10px rgba(0, 0, 0, 0.7),
        inset 0 2px 5px rgba(255, 255, 200, 0.3);
    }

    /* ‚îÄ‚îÄ BARRE DE COMP√âTENCES (moiti√© droite) ‚îÄ‚îÄ */
    #skills-col {
      position: absolute;
      right: 0;
      bottom: 0;
      width: 52%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: all;
    }

    /* Disposition : 1 grand bouton ATK central + 3 skills en arc */
    #skills-layout {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding-bottom: 8px;
    }

    /* ‚îÄ Rang√©e haute : 3 skills ‚îÄ */
    #skills-top {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    /* ‚îÄ Rang√©e basse : ESQUIVE + (espace) + CHARGE ‚îÄ */
    #skills-bot {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    /* Bouton de skill g√©n√©rique */
    .sk {
      position: relative;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      background: rgba(10, 10, 26, 0.96);
      pointer-events: all;
      transition: transform 0.06s, filter 0.05s;
      -webkit-user-select: none;
      user-select: none;
      /* pas de font-size ici ‚Äî g√©r√© par .sk-ico */
    }

    .sk:active {
      transform: scale(0.82);
      filter: brightness(1.4);
    }

    .sk.cd {
      opacity: 0.45;
    }

    .sk-ico {
      font-size: 22px;
      line-height: 1;
      display: block;
      pointer-events: none;
      margin-bottom: 1px;
    }

    .sk-lbl {
      font-family: 'VT323', monospace;
      font-size: 10px;
      line-height: 1;
      pointer-events: none;
      letter-spacing: 0.3px;
    }

    /* Tailles */
    .sk.sm {
      width: 58px;
      height: 58px;
      border: 2px solid rgba(255, 215, 0, 0.3);
    }

    .sk.md {
      width: 64px;
      height: 64px;
      border: 2px solid rgba(255, 215, 0, 0.3);
    }

    /* Couleurs */
    #bsk-spin {
      border-color: rgba(180, 70, 255, 0.6);
    }

    #bsk-spin .sk-lbl {
      color: rgba(210, 130, 255, 0.9);
    }

    #bsk-proj {
      border-color: rgba(60, 170, 255, 0.6);
    }

    #bsk-proj .sk-lbl {
      color: rgba(120, 200, 255, 0.9);
    }

    #bsk-charge {
      border-color: rgba(255, 110, 30, 0.6);
    }

    #bsk-charge .sk-lbl {
      color: rgba(255, 160, 80, 0.9);
    }

    #bsk-dash {
      border-color: rgba(0, 225, 175, 0.65);
    }

    #bsk-dash .sk-lbl {
      color: rgba(0, 225, 175, 0.95);
    }

    #bsk-dash .sk-ico {
      font-size: 20px;
    }

    /* Anneau de cooldown conic */
    .sk-ring {
      position: absolute;
      inset: -3px;
      border-radius: 50%;
      pointer-events: none;
      background: conic-gradient(rgba(0, 0, 0, 0) var(--p, 0%), rgba(0, 0, 0, 0.78) var(--p, 0%));
      display: none;
    }

    .sk-ring.on {
      display: block;
    }

    /* Dash invincible */
    #bsk-dash.inv {
      border-color: rgba(0, 255, 200, 1);
      background: rgba(0, 170, 130, 0.22);
      animation: invGlow 0.36s ease-in-out infinite alternate;
    }

    @keyframes invGlow {
      from {
        box-shadow: 0 0 12px rgba(0, 255, 200, 0.5);
      }

      to {
        box-shadow: 0 0 28px rgba(0, 255, 200, 1), 0 0 55px rgba(0, 255, 200, 0.3);
      }
    }

    /* Overlay invincible plein √©cran */
    #invincible-overlay {
      position: fixed;
      inset: 0;
      z-index: 164;
      pointer-events: none;
      opacity: 0;
      background: radial-gradient(ellipse at center, rgba(0, 255, 200, 0.09) 0%, transparent 65%);
      border: 3px solid transparent;
      transition: opacity 0.08s;
    }

    #invincible-overlay.active {
      opacity: 1;
      border-color: rgba(0, 255, 200, 0.4);
      animation: invBorder 0.25s step-end infinite;
    }

    @keyframes invBorder {
      50% {
        border-color: transparent;
      }
    }
  </style>
</head>

<body>
  <div id="scanlines"></div>
  <div id="atkflash"></div>
  <div id="warn-overlay"></div>

  <!-- TITLE -->
  <div id="title">
    <canvas id="title-canvas"></canvas>
    <div class="title-content">
      <div class="title-sword">‚öîÔ∏è</div>
      <div class="title-logo">ANNIVERSAIRE<br>PAPA</div>
      <div class="title-tagline">‚Äî L√©gende du Royaume ‚Äî</div>
      <div class="title-features">
        Sauvez le royaume en incarnant un h√©ros d'exception !<br>
        Explorez des donjons p√©rilleux, affrontez des monstres redoutables,<br>
        Atteignez "l'√©toile" et confiez lui le voeu pour lequel vous vous √™tes battu durant ces 365 jours !<br>
        Bonne chance, H√©ro !
      </div>
      <button class="start-btn" onclick="startGame()">‚ñ∫ COMMENCER L'AVENTURE</button>
    </div>
  </div>

  <!-- GAME -->
  <div id="game"><canvas id="gc"></canvas></div>

  <!-- HUD -->
  <div id="hud" style="display:none">
    <div class="hud-inner">
      <div class="hud-block">
        <div class="hud-label">H√©ros</div>
        <div class="hud-val">üßô Papa</div>
        <div class="lvl-badge" id="hud-lvl">Niv. 1</div>
      </div>
      <div class="hud-block" style="align-items:center">
        <div class="hud-label">Vie</div>
        <div class="hearts-row" id="hearts"></div>
        <div class="xp-bar-wrap">
          <div class="xp-bar-fill" id="xpbar" style="width:0%"></div>
        </div>
      </div>
      <div class="hud-block" style="align-items:center">
        <div class="hud-label">Arme</div>
        <div class="weapon-badge" id="hud-weapon">‚öîÔ∏è √âp√©e</div>
      </div>
      <div class="hud-block" style="align-items:flex-end">
        <div class="hud-label" style="text-align:right">Qu√™te</div>
        <div class="hud-quest-text" id="hud-quest">Explore...</div>

      </div>

    </div>
  </div>

  <!-- BOSS HP BAR -->
  <div id="boss-hud">
    <div id="boss-hud-name">BOSS</div>
    <div id="boss-hp-wrap">
      <div id="boss-hp-fill" style="width:100%"></div>
    </div>
    <div id="boss-phase-wrap"></div>
  </div>

  <!-- MINIMAP -->
  <div id="minimap-wrap" style="display:none"><canvas id="mmc"></canvas></div>

  <div id="invincible-overlay"></div>

  <!-- MOBILE CONTROLS ‚Äî barre fixe en bas -->
  <div id="mobilecontrols">
    <!-- GAUCHE : Joystick directionnel -->
    <div id="joystick-col">
      <div id="joystick-zone">
        <div id="joystick-base"></div>
        <div id="joystick-knob"></div>
      </div>
    </div>

    <!-- DROITE : Barre de comp√©tences
       TOP :   üåÄ SPIN  |  üîÆ TIR  |  üõ°Ô∏è DASH
       BOT :   (vide)   |  üí• CHARG
  -->
    <div id="skills-col">
      <div id="skills-layout">
        <div id="skills-top">
          <button class="sk sm" id="bsk-spin">
            <span class="sk-ico">üåÄ</span><span class="sk-lbl">SPIN</span>
            <div class="sk-ring" id="ring-spin"></div>
          </button>
          <button class="sk sm" id="bsk-proj">
            <span class="sk-ico">üîÆ</span><span class="sk-lbl">TIR</span>
            <div class="sk-ring" id="ring-proj"></div>
          </button>
          <button class="sk sm" id="bsk-dash">
            <span class="sk-ico">üõ°Ô∏è</span><span class="sk-lbl">ESQUIVE</span>
            <div class="sk-ring" id="ring-dash"></div>
          </button>
        </div>
        <div id="skills-bot">
          <button class="sk md" id="bsk-charge">
            <span class="sk-ico">üí•</span><span class="sk-lbl">CHARGE</span>
            <div class="sk-ring" id="ring-charge"></div>
          </button>
        </div>

      </div>
    </div>
  </div>

  <!-- DIALOG -->
  <div id="dialog">
    <div class="dlg-inner">
      <div class="dlg-portrait-wrap">
        <div class="dlg-portrait-box" id="dlg-portrait">üßô</div>
      </div>
      <div class="dlg-body">
        <div class="dlg-name" id="dlg-name">???</div>
        <div id="dlg-text">...</div>
        <div class="dlg-actions">
          <div class="dlg-continue" id="dlg-cont">‚ñº Continuer</div>
          <button class="dlg-btn" id="dlg-btn" onclick="nextLine()" style="display:none">SUITE ‚ñ∂</button>
        </div>
      </div>
    </div>
  </div>

  <!-- DEATH SCREEN -->
  <div id="deathscreen">
    <div class="death-icon">üíÄ</div>
    <div class="death-title">GAME OVER</div>
    <div class="death-msg" id="death-msg">Le h√©ros est tomb√©...<br>Courage, on recommence !</div>
    <button class="death-btn" onclick="restartLevel()">‚Ü∫ RECOMMENCER</button>
  </div>

  <!-- LEVEL TRANSITION -->
  <div id="leveltrans">
    <div class="lt-content">
      <div class="lt-icon" id="lt-icon">üèÜ</div>
      <div class="lt-title" id="lt-title">NIVEAU ACCOMPLI !</div>
      <div class="lt-zone" id="lt-zone">‚Äî</div>
      <div class="lt-reward" id="lt-reward">R√©compense !</div>
      <button class="lt-next-btn" id="lt-btn" onclick="goNextLevel()">NIVEAU SUIVANT ‚ñ∫</button>
    </div>
  </div>

  <!-- VICTORY -->
  <div id="victory">
    <div style="font-size:clamp(50px,12vw,75px);filter:drop-shadow(0 0 30px #ffd700);animation:swordFloat 2s infinite">
      üåü</div>
    <div class="vic-title">QU√äTE ACCOMPLIE !<br>üéâ JOYEUX ANNIVERSAIRE ! üéâ</div>
    <div class="vic-msg">Papa,<br><br>
      Tu as travers√© la For√™t des Souvenirs,<br>
      Le Ch√¢teau des √âpreuves,<br>
      Et le Sommet de la Sagesse.<br><br>
      Comme dans la vie ‚Äî jamais tu n'as l√¢ch√©. ‚ù§Ô∏è<br><br>
      On t'aime. Merci d'√™tre notre h√©ros. üèÜ</div>
    <button class="vic-btn" onclick="fireworks()">üéÜ C√âL√âBRER !</button>
  </div>

  <script>
    'use strict';
    // ============================================================
    // AUDIO
    // ============================================================
    let actx;
    function ac() { if (!actx) actx = new (window.AudioContext || window.webkitAudioContext)(); if (actx.state === 'suspended') actx.resume(); return actx; }
    function note(f, d, tp = 'square', v = 0.07, dl = 0) {
      try {
        const c = ac(), o = c.createOscillator(), g = c.createGain();
        o.connect(g); g.connect(c.destination); o.type = tp; o.frequency.value = f;
        g.gain.setValueAtTime(0, c.currentTime + dl);
        g.gain.linearRampToValueAtTime(v, c.currentTime + dl + 0.01);
        g.gain.linearRampToValueAtTime(0, c.currentTime + dl + d);
        o.start(c.currentTime + dl); o.stop(c.currentTime + dl + d + 0.1);
      } catch (e) { }
    }
    function seq(ns) { let t = 0; ns.forEach(([f, d]) => { if (f > 0) note(f, d * .85, 'square', 0.065, t); t += d; }); }
    function sHit() { note(180, 0.07, 'sawtooth', 0.09); }
    function sSwing() { note(440, 0.05, 'square', 0.07); note(330, 0.05, 'square', 0.04, 0.06); }
    function sDie() { seq([[220, 0.1], [165, 0.1], [110, 0.2]]); }
    function sPick() { seq([[784, 0.07], [1047, 0.10], [1319, 0.16]]); }
    function sLvlUp() { seq([[523, 0.09], [659, 0.09], [784, 0.09], [1047, 0.20], [1319, 0.32]]); }
    function sBeep() { if (Math.random() < 0.35) note(880, 0.022, 'square', 0.018); }
    function sWalk() { if (Math.random() < 0.15) note(165 + Math.random() * 20, 0.03, 'square', 0.014); }
    function sDmg() { note(85, 0.14, 'sawtooth', 0.14); }
    function sSpin() { note(600, 0.04, 'sawtooth', 0.07); note(500, 0.04, 'sawtooth', 0.055, 0.055); note(400, 0.09, 'sawtooth', 0.045, 0.11); }
    function sProj() { note(800, 0.04, 'square', 0.07); note(1000, 0.09, 'square', 0.055, 0.04); }
    function sCharge() { note(200, 0.04, 'sawtooth', 0.09); note(300, 0.04, 'sawtooth', 0.09, 0.04); note(500, 0.18, 'sawtooth', 0.11, 0.09); }
    function sDeath() { seq([[200, 0.15], [160, 0.15], [120, 0.2], [80, 0.4]]); }
    function sVic() { seq([[523, 0.14], [523, 0.14], [523, 0.14], [415, 0.09], [523, 0.38], [784, 0.14], [784, 0.14], [784, 0.14], [698, 0.09], [784, 0.38], [1047, 0.09], [988, 0.09], [932, 0.09], [880, 0.09], [1047, 0.48]]); }
    function sBossDash() { note(1200, 0.06, 'sawtooth', 0.18); note(200, 0.12, 'sawtooth', 0.2, 0.04); }
    function sBossBeam() { note(300, 0.05, 'sawtooth', 0.15); note(400, 0.05, 'sawtooth', 0.12, 0.05); note(1800, 0.4, 'sine', 0.07, 0.08); }
    function sBossWave() { note(100, 0.2, 'sawtooth', 0.18); note(150, 0.2, 'sawtooth', 0.15, 0.1); }
    function sBossSpawn() { seq([[440, 0.08], [350, 0.08], [280, 0.08], [200, 0.15]]); }
    function sBossRage() { note(80, 0.3, 'sawtooth', 0.25); note(120, 0.3, 'sawtooth', 0.2, 0.15); note(60, 0.5, 'sawtooth', 0.28, 0.3); }

    // ============================================================
    // CANVAS
    // ============================================================
    const canvas = document.getElementById('gc');
    const C = canvas.getContext('2d');
    const mm = document.getElementById('mmc');
    const MC = mm.getContext('2d');
    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; mm.width = 110; mm.height = 74; }
    window.addEventListener('resize', resize); resize();
    const tc = document.getElementById('title-canvas');
    const TC = tc.getContext('2d');
    function resizeTitle() { tc.width = window.innerWidth; tc.height = window.innerHeight; }
    window.addEventListener('resize', resizeTitle); resizeTitle();

    // ============================================================
    // NOISE
    // ============================================================
    function smoothNoise(x, y) {
      const ix = Math.floor(x), iy = Math.floor(y);
      const fx = x - ix, fy = y - iy;
      const u = fx * fx * (3 - 2 * fx), v = fy * fy * (3 - 2 * fy);
      const h = (a, b) => Math.abs(Math.sin(a * 127.1 + b * 311.7) * 43758.5453) % 1;
      return h(ix, iy) * (1 - u) * (1 - v) + h(ix + 1, iy) * u * (1 - v) + h(ix, iy + 1) * (1 - u) * v + h(ix + 1, iy + 1) * u * v;
    }
    function fbm(x, y, oct = 4) {
      let v = 0, amp = 1, freq = 1, max = 0;
      for (let i = 0; i < oct; i++) { v += smoothNoise(x * freq, y * freq) * amp; max += amp; amp *= 0.5; freq *= 2; }
      return v / max;
    }

    // ============================================================
    // TILES
    // ============================================================
    const TSIZ = 32;
    const tileCache = new Map();
    const TB = {
      GRASS: 0, PATH: 1, WATER: 2, ROCK: 3, TREE: 4, FLOWER: 5, MUSHROOM: 6,
      FLOOR: 7, WALL: 8, SNOW: 9, ICE: 10, LAVA: 11, DARK: 12, BRIDGE: 13, TALL_GRASS: 14,
      HILL: 15, SAND: 16, MOSS: 17
    };
    const BLOCK = { 2: true, 3: true, 4: true, 8: true, 11: true };
    const PASSABLE = t => !BLOCK[t];
    function buildTile(id, frame = 0) {
      const key = `${id}_${frame % 4}`;
      if (tileCache.has(key)) return tileCache.get(key);
      const off = new OffscreenCanvas(TSIZ, TSIZ);
      drawTileTexture(off.getContext('2d'), id, frame);
      tileCache.set(key, off); return off;
    }
    function rand(a, b, c) { return Math.abs(Math.sin(a + b * 127.1 + c * 311.7) * 43758.5453) % 1; }
    function drawTileTexture(cx, id, f) {
      cx.clearRect(0, 0, TSIZ, TSIZ); const T = TSIZ;
      switch (id) {
        case TB.GRASS: { cx.fillStyle = '#2a7a2a'; cx.fillRect(0, 0, T, T);['#2e8834', '#267326', '#1e7025', '#338a33', '#3a9a3a'].forEach((c, i) => { cx.fillStyle = c; cx.fillRect(rand(i * 7, f, i) * T | 0, rand(i * 11, f, i) * T | 0, 3 + (i % 2), 2 + (i % 2)); }); cx.strokeStyle = '#4ab04a'; cx.lineWidth = 1; for (let i = 0; i < 7; i++) { const x = rand(i * 17, f, i) * T, y = rand(i * 23, f, i) * T; cx.beginPath(); cx.moveTo(x, y + 3); cx.lineTo(x + Math.sin(f * 0.08) * 1.5, y - 3); cx.stroke(); } break; }
        case TB.PATH: { cx.fillStyle = '#a07830'; cx.fillRect(0, 0, T, T);['#b08040', '#906820', '#c09040', '#8a6018'].forEach((c, i) => { cx.fillStyle = c; cx.fillRect(rand(i * 3, f, 1) * T | 0, rand(i * 7, 2, i) * T | 0, 2 + (i % 3), 2 + (i % 2)); }); break; }
        case TB.WATER: { cx.fillStyle = '#0d3a6e'; cx.fillRect(0, 0, T, T); for (let w = 0; w < 4; w++) { const y = 4 + w * 7 + Math.sin(f * 0.05 + w * 1.2) * 2; cx.fillStyle = `rgba(80,160,255,${0.12 + w * 0.06})`; cx.beginPath(); cx.moveTo(0, y); for (let x = 0; x <= T; x += 3)cx.lineTo(x, y + Math.sin((x + f * 2) * 0.3 + w) * 2.5); cx.lineTo(T, y + 8); cx.lineTo(0, y + 8); cx.closePath(); cx.fill(); } break; }
        case TB.ROCK: { cx.fillStyle = '#4a4a55'; cx.fillRect(0, 0, T, T); cx.fillStyle = '#6a6a78'; cx.fillRect(3, 3, 26, 23); cx.fillStyle = '#7a7a88'; cx.fillRect(5, 5, 14, 12); cx.fillStyle = 'rgba(255,255,255,0.14)'; cx.fillRect(5, 5, 8, 3); break; }
        case TB.TREE: { cx.fillStyle = '#12280e'; cx.fillRect(0, 0, T, T); cx.fillStyle = '#1a4015'; cx.fillRect(4, 3, 24, 22); cx.fillStyle = '#257830'; cx.fillRect(7, 5, 18, 16); cx.fillStyle = '#4a2e10'; cx.fillRect(13, 21, 6, 11); break; }
        case TB.FLOWER: { cx.fillStyle = '#2a7a2a'; cx.fillRect(0, 0, T, T); const fp = [[7, 22], [19, 17], [14, 27], [25, 21]]; fp.forEach(([x, y], i) => { cx.fillStyle = ['#ff6688', '#ffcc44', '#ff88aa', '#cc66ff'][i]; for (let p2 = 0; p2 < 5; p2++) { const a = p2 / 5 * 6.28; cx.beginPath(); cx.arc(x + Math.cos(a) * 2.5, y - 8 + Math.sin(a) * 2.5, 2, 0, 6.28); cx.fill(); } }); break; }
        case TB.MUSHROOM: { cx.fillStyle = '#1e5a2a'; cx.fillRect(0, 0, T, T);[[8, 25], [20, 21], [26, 27]].forEach(([x, y]) => { cx.fillStyle = '#bb3333'; cx.beginPath(); cx.arc(x, y - 5, 5, Math.PI, 0); cx.fill(); cx.fillStyle = '#e8d0b0'; cx.fillRect(x - 2, y - 5, 4, 6); }); break; }
        case TB.FLOOR: { cx.fillStyle = '#252440'; cx.fillRect(0, 0, T, T); const g2 = T / 2; cx.fillStyle = '#2e2d50'; cx.fillRect(0, 0, g2 - 1, g2 - 1); cx.fillRect(g2 + 1, g2 + 1, g2 - 1, g2 - 1); cx.fillStyle = '#1e1d3a'; cx.fillRect(g2 + 1, 0, g2 - 1, g2 - 1); cx.fillRect(0, g2 + 1, g2 - 1, g2 - 1); cx.fillStyle = '#14132a'; cx.fillRect(0, g2, T, 2); cx.fillRect(g2, 0, 2, T); break; }
        case TB.WALL: { cx.fillStyle = '#16163a'; cx.fillRect(0, 0, T, T); cx.fillStyle = '#22224a'; cx.fillRect(2, 2, 12, 9); cx.fillRect(18, 2, 12, 9); cx.fillStyle = '#2a2a58'; cx.fillRect(10, 13, 16, 9); cx.fillRect(2, 22, 8, 8); cx.fillRect(22, 22, 8, 8); cx.fillStyle = '#0a0a20'; cx.fillRect(0, 0, T, 2); cx.fillRect(0, 11, T, 2); cx.fillRect(0, 22, T, 2); break; }
        case TB.SNOW: { cx.fillStyle = '#d0e8f8'; cx.fillRect(0, 0, T, T); for (let i = 0; i < 8; i++) { cx.fillStyle = i % 2 ? 'rgba(255,255,255,0.45)' : 'rgba(180,200,220,0.3)'; cx.fillRect(rand(i * 5, 1, f) * T | 0, rand(i * 11, f, 2) * T | 0, 4 + i % 3, 2 + i % 3); } break; }
        case TB.ICE: { cx.fillStyle = '#7aaac8'; cx.fillRect(0, 0, T, T); cx.fillStyle = 'rgba(220,240,255,0.42)'; cx.fillRect(2, 2, 22, 5); cx.fillRect(5, 11, 12, 3); cx.fillStyle = 'rgba(255,255,255,0.55)'; cx.fillRect(3, 3, 10, 2); break; }
        case TB.LAVA: { cx.fillStyle = '#380e00'; cx.fillRect(0, 0, T, T); for (let i = 0; i < 3; i++) { const y = 5 + i * 9 + Math.sin(f * 0.06 + i * 1.8) * 2.5; cx.fillStyle = `rgba(${175 - i * 28},${55 - i * 10},0,0.75)`; cx.beginPath(); cx.moveTo(0, y); for (let x = 0; x <= T; x += 3)cx.lineTo(x, y + Math.sin((x + f * 3) * 0.4 + i) * 3.5); cx.lineTo(T, y + 9); cx.lineTo(0, y + 9); cx.closePath(); cx.fill(); } break; }
        case TB.DARK: { cx.fillStyle = '#090914'; cx.fillRect(0, 0, T, T); cx.fillStyle = 'rgba(25,25,55,0.5)'; cx.fillRect(3, 3, T - 6, T - 6); break; }
        case TB.BRIDGE: { cx.fillStyle = '#0c3a6a'; cx.fillRect(0, 0, T, T);['#8b5e2a', '#a06830', '#7a5020', '#9a6828'].forEach((c, i) => { const y = 4 + i * 7; cx.fillStyle = c; cx.fillRect(1, y, T - 2, 6); }); break; }
        case TB.TALL_GRASS: { cx.fillStyle = '#2a7a2a'; cx.fillRect(0, 0, T, T); cx.strokeStyle = '#44b044'; cx.lineWidth = 1.5; for (let i = 0; i < 10; i++) { const x = 3 + i * 2.8, h = 9 + Math.sin(i * 2.3) * 3, sw = Math.sin(f * 0.04 + i * 0.7) * 2; cx.beginPath(); cx.moveTo(x, T - 2); cx.quadraticCurveTo(x + sw, T - h * 0.5, x + sw * 1.5, T - h); cx.stroke(); } break; }
        case TB.HILL: { cx.fillStyle = '#3a8c30'; cx.fillRect(0, 0, T, T); const hg = cx.createLinearGradient(0, 0, 0, T); hg.addColorStop(0, 'rgba(120,200,80,0.28)'); hg.addColorStop(1, 'rgba(0,0,0,0.22)'); cx.fillStyle = hg; cx.fillRect(0, 0, T, T); break; }
        case TB.SAND: { cx.fillStyle = '#c8a060'; cx.fillRect(0, 0, T, T);['#d4aa70', '#b89050', '#dcb878', '#c8a458'].forEach((c, i) => { cx.fillStyle = c; cx.fillRect(rand(i * 3, f, 1) * T | 0, rand(i * 7, 2, i) * T | 0, 2 + i % 3, 1 + i % 2); }); break; }
        case TB.MOSS: { cx.fillStyle = '#1e5a2a'; cx.fillRect(0, 0, T, T); for (let i = 0; i < 14; i++) { cx.fillStyle = i % 3 === 0 ? '#2a7a30' : i % 3 === 1 ? '#163820' : '#3a8a3a'; cx.beginPath(); cx.arc(rand(i * 5, f, i) * T, rand(i * 9, i, f) * T, 2 + rand(i, f, i) * 3, 0, 6.28); cx.fill(); } break; }
      }
    }
    const ANIM_TILES = [TB.WATER, TB.LAVA, TB.TALL_GRASS];
    let tileFrame = 0;
    setInterval(() => { tileFrame++; ANIM_TILES.forEach(id => { for (let f = 0; f < 4; f++)tileCache.delete(`${id}_${f}`); }); }, 120);

    // ============================================================
    // WORLD CONSTANTS
    // ============================================================
    const COLS = 80, ROWS = 60, WW = COLS * TSIZ, WH = ROWS * TSIZ;

    // ============================================================
    // LEVELS DATA
    // ============================================================
    const LEVELS = [{
      name: ["La For√™t des Souvenirs", "brrr...", "Un frisson vous traverse", "une pr√©sence sinistre du nord semble vous en vouloir..."], biome: "forest",
      quest: "Retrouve 3 M√©daillons", questCount: 3, questType: "collect", questItem: "ü•á",
      questMsgs: [
        ["ü•á", "M√âDAILLON", "Un m√©daillon en or... vous rappelant des moments pass√©s √† tes c√¥t√©s.", "Ces moments du quotidien ‚Äî les repas, les rires, les balades...", "Ce sont les tr√©sors les plus pr√©cieux.", "Vous r√©cup√©rez le m√©daillon"],
        ["ü•á", "M√âDAILLON", "Un... m√©daillon ?", " Il semble repr√©senter la patience.", "Elle est d√©sormais votre, une patience √† toutes √©preuves", "Peut √™tre au final, que vous l'avez toujours √©t√©", "Vous r√©cup√©rez le m√©daillon de sagesse"],
        ["ü•á", "M√âDAILLON", "Un m√©daillon brille d'or pur.", "Une vision vous assaillit.", "Une famille... aimante... est-ce la votre", "M√©daillon de Famille r√©cup√©r√© !"]
      ],
      bossName: "Vorgath le Br√ªl√©", bossIcon: "üëπ", bossHP: 40, bossPhases: 2,
      bossPatterns: ['slash', 'poison_ring', 'enrage'],
      bossDialog: ["Je suis le Vorgath le Br√ªl√© ! D√©voreur de souvenir !", "Je ne peux pas perdre la vie de cette fa√ßon !!!", "(Un cri strident retenti)", "BOSS VAINCU ! ‚öîÔ∏è √âp√©e de Vorgath d√©bloqu√©e !"],
      weapon: "‚öîÔ∏è √âp√©e de Vorgath le Br√ªl√©", wPow: 3,
      reward: "‚öîÔ∏è √âp√©e de Vorgath le Br√ªl√© ! +50 XP", rewardIcon: "‚öîÔ∏è", bgA: '#0d1f0d'
    }, {
      name: "Le Ch√¢teau des √âpreuves", biome: "castle",
      quest: "Vaincs 5 Gardiens", questCount: 5, questType: "kill", questItem: "üíÄ",
      questMsgs: [
        ["üíÄ", "GARDIEN VAINCU", "Un gardien vaincu. üìú 1/5"],
        ["üíÄ", "GARDIEN VAINCU", "Deux de moins ! üìú 2/5", "Est-ce la preuve d'une force infini ?"],
        ["üíÄ", "GARDIEN VAINCU", "La moiti√© du chemin. üìú 3/5", "ou peut-√™tre une pers√©v√©rance sans nom."],
        ["üíÄ", "GARDIEN VAINCU", "Presque l√† ! üìú 4/5", "..."],
        ["üíÄ", "TOUS VAINCUS !", "D√©sormais votre force n'a plus de doute.", "Un grincement se fait entendre... Vos sens sont en alerte", "Un nom apparait dans votre esprit", "Nytherion, le Revenant..."]
      ],
      bossName: "Nytherion, le Revenant", bossIcon: "üëë", bossHP: 60, bossPhases: 3,
      bossSpeed: 0.42, bossAggroR: 280, bossWarnR: 380,
      bossPatterns: ['teleport_strike', 'shadow_wave', 'death_beam', 'enrage'],
      bossDialog: ["Je suis Nytherion, le Revenant !", "Moi ? Vaincu par un simple voyageur...", "Toi... Qui ne doutes plus... D'OU SORT TU CETTE ASSURANCE ?!", "La lumi√®re fantomatique se tarit dans un sifflement l√©ger, et vous vous sentez plus l√©ger", "BOSS VAINCU ! üîÆ B√¢ton de Nytherion d√©bloqu√© !"],
      weapon: "üîÆ B√¢ton de Nytherion", wPow: 6,
      reward: "üîÆ B√¢ton de Nytherion ! +100 XP", rewardIcon: "üîÆ", bgA: '#0d0d22'
    }, {
      name: "Le Sommet de la Sagesse", biome: "mountain",
      quest: ["Atteins l'√âtoile Finale, au sommet de la montagne", "Une pr√©sence pesante vous glace le sang..."], questCount: 1, questType: "collect", questItem: "‚≠ê",
      questMsgs: [["‚≠ê", "L'√âTOILE FINALE", "Vous l'avez donc trouv√©e... l'\"√âtoile\"", "Elle brille pour vous depuis les t√©n√®bres de l'univers.", "Vous sentez une √©nergie puissante vous envahir", "et une voix r√©sonne dans votre esprit :", "\"Tu as fait du chemin pour venir jusqu'ici... mais tu n'es pas encore arriv√©.\"", "Vous faites un voeu...", "Une ann√©e de combat, de pers√©v√©rance, de courage...", "L'√©toile vous octroie le fruit de votre d√©sir."]],
      bossName: "Thyrax, le Souffle Noir", bossIcon: "üêâ", bossHP: 100, bossPhases: 3,
      bossPatterns: ['fireball_burst', 'aerial_slam', 'time_stop', 'meteor', 'dash_slam', 'enrage'],
      bossDialog: ["Je suis Thyrax le Grand ! Les ann√©es passent, personne ne m'arr√™te !", "PERSONNE N'ETAIT CENSE DEROGER CET ORDRE", "\"vous avez mis fin au r√®gne temporel de Thyrax.\"", "üêâ DRAGON VAINCU ! ‚≠ê √âtoile de Sagesse ! VICTOIRE !"],
      weapon: "‚≠ê √âtoile de Sagesse", wPow: 10,
      reward: "‚≠ê √âtoile de Sagesse ! +200 XP", rewardIcon: "‚≠ê", bgA: '#080812'
    }];

    // ============================================================
    // MONSTERS
    // ============================================================
    const MONS = {
      forest: [{ icon: 'üê∫', name: 'Loup', hp: 4, maxHp: 4, spd: 1.1, dmg: 1, xp: 10, r: 13 },
      { icon: 'üï∑Ô∏è', name: 'Araign√©e', hp: 2, maxHp: 2, spd: 1.6, dmg: 1, xp: 8, r: 11 },
      { icon: 'ü¶á', name: 'Chauve-souris', hp: 2, maxHp: 2, spd: 2.0, dmg: 1, xp: 12, r: 11 },
      { icon: 'üåø', name: 'Entit√©', hp: 6, maxHp: 6, spd: 0.7, dmg: 2, xp: 15, r: 13 }],
      castle: [{ icon: 'üíÄ', name: 'Squelette', hp: 7, maxHp: 7, spd: 0.8, dmg: 2, xp: 20, r: 13 },
      { icon: 'üßü', name: 'Zombie', hp: 12, maxHp: 12, spd: 0.45, dmg: 2, xp: 28, r: 15 },
      { icon: 'üëª', name: 'Fant√¥me', hp: 4, maxHp: 4, spd: 2.2, dmg: 2, xp: 18, r: 11 },
      { icon: 'ü™ñ', name: 'Chevalier', hp: 10, maxHp: 10, spd: 1.0, dmg: 3, xp: 30, r: 14 }],
      mountain: [{ icon: 'üßä', name: 'G√©ant de Glace', hp: 16, maxHp: 16, spd: 0.38, dmg: 4, xp: 40, r: 17 },
      { icon: 'ü¶Ö', name: 'Griffon', hp: 8, maxHp: 8, spd: 1.6, dmg: 3, xp: 32, r: 13 },
      { icon: 'ü™®', name: 'Golem', hp: 20, maxHp: 20, spd: 0.28, dmg: 5, xp: 50, r: 18 },
      { icon: 'üå®Ô∏è', name: '√âl√©mental', hp: 11, maxHp: 11, spd: 1.3, dmg: 3, xp: 38, r: 13 }]
    };

    // ============================================================
    // MAP GENERATION HELPERS
    // ============================================================
    function fillR(map, r0, c0, r1, c1, t) { for (let r = r0; r < r1; r++)for (let c = c0; c < c1; c++)if (r >= 0 && r < ROWS && c >= 0 && c < COLS) map[r][c] = t; }
    function fillE(map, cr, cc, rr, rc, t) { for (let r = Math.max(0, cr - rr); r <= Math.min(ROWS - 1, cr + rr); r++)for (let c = Math.max(0, cc - rc); c <= Math.min(COLS - 1, cc + rc); c++) { const dr = (r - cr) / rr, dc = (c - cc) / rc; if (dr * dr + dc * dc <= 1) map[r][c] = t; } }
    function carveLine(map, r0, c0, r1, c1, t) { const dr = Math.abs(r1 - r0), dc = Math.abs(c1 - c0); const sr = r0 < r1 ? 1 : -1, sc = c0 < c1 ? 1 : -1; let err = dr - dc, r = r0, c = c0; for (; ;) { if (r >= 0 && r < ROWS && c >= 0 && c < COLS) map[r][c] = t; if (r === r1 && c === c1) break; const e2 = 2 * err; if (e2 > -dc) { err -= dc; r += sr; } if (e2 < dr) { err += dr; c += sc; } } }
    function carveT(map, r0, c0, r1, c1, t, w = 1) { for (let dr = -w; dr <= w; dr++)for (let dc = -w; dc <= w; dc++)carveLine(map, r0 + dr, c0 + dc, r1 + dr, c1 + dc, t); }
    function ri(lo, hi) { return lo + Math.floor(Math.random() * (hi - lo + 1)); }
    function bfsPassable(map, startR, startC, limit = 2000) {
      const visited = new Set(); const queue = [[startR, startC]];
      const key = (r, c) => r * COLS + c; visited.add(key(startR, startC)); const cells = [];
      while (queue.length && cells.length < limit) {
        const [r, c] = queue.shift(); if (PASSABLE(map[r][c])) cells.push([r, c]);
        for (const [dr, dc] of [[-1, 0], [1, 0], [0, -1], [0, 1]]) {
          const nr = r + dr, nc = c + dc;
          if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) continue; const k = key(nr, nc);
          if (!visited.has(k) && PASSABLE(map[nr][nc])) { visited.add(k); queue.push([nr, nc]); }
        }
      }
      return cells;
    }
    function safeSpawnCell(cells, avoidX, avoidY, minDist = 80) {
      const far = cells.filter(([r, c]) => { const wx = c * TSIZ + TSIZ / 2, wy = r * TSIZ + TSIZ / 2; return Math.hypot(wx - avoidX, wy - avoidY) > minDist; });
      const pool = far.length > 0 ? far : cells; if (!pool.length) return null;
      const [r, c] = pool[Math.floor(Math.random() * pool.length)]; return { x: c * TSIZ + TSIZ / 2, y: r * TSIZ + TSIZ / 2 };
    }
    function ensurePassable(map, wx, wy) {
      const c0 = Math.floor(wx / TSIZ), r0 = Math.floor(wy / TSIZ);
      if (r0 >= 0 && r0 < ROWS && c0 >= 0 && c0 < COLS && PASSABLE(map[r0][c0])) return { x: wx, y: wy };
      for (let d = 1; d < 10; d++)for (let dr = -d; dr <= d; dr++)for (let dc = -d; dc <= d; dc++) {
        const r = r0 + dr, c = c0 + dc; if (r >= 0 && r < ROWS && c >= 0 && c < COLS && PASSABLE(map[r][c])) return { x: c * TSIZ + TSIZ / 2, y: r * TSIZ + TSIZ / 2 };
      }
      return { x: wx, y: wy };
    }
    function genMap(biome) {
      const seed = Math.random() * 1000;
      const base = biome === 'castle' ? TB.FLOOR : biome === 'mountain' ? TB.SNOW : TB.GRASS;
      const wall = biome === 'castle' ? TB.WALL : biome === 'mountain' ? TB.ROCK : TB.TREE;
      const map = [];
      for (let r = 0; r < ROWS; r++) { map[r] = []; for (let c = 0; c < COLS; c++)map[r][c] = base; }
      fillR(map, 0, 0, 3, COLS, wall); fillR(map, ROWS - 3, 0, ROWS, COLS, wall);
      fillR(map, 0, 0, ROWS, 3, wall); fillR(map, 0, COLS - 3, ROWS, COLS, wall);
      let startPos, bossPos, questPos;
      if (biome === 'forest') {
        for (let r = 3; r < ROWS - 3; r++)for (let c = 3; c < COLS - 3; c++) {
          const n = fbm(c * 0.08 + seed * 0.1, r * 0.08 + seed * 0.1), n2 = fbm(c * 0.15 + 50 + seed * 0.05, r * 0.15 + 50 + seed * 0.05), n3 = fbm(c * 0.05 + 100, r * 0.05 + 100);
          if (n > 0.63) map[r][c] = TB.TREE; else if (n > 0.56 && n2 > 0.55) map[r][c] = TB.MUSHROOM;
          else if (n < 0.35 && n2 < 0.4) map[r][c] = TB.MOSS; else if (n3 > 0.66 && n < 0.5) map[r][c] = TB.HILL;
          else if (n2 > 0.68 && n < 0.52) map[r][c] = TB.FLOWER; else if (n < 0.43 && n2 > 0.5 && n3 < 0.5) map[r][c] = TB.TALL_GRASS;
        }
        const lakeR = ri(28, 36), lakeC = ri(28, 50), lakeRR = ri(5, 8), lakeRC = ri(8, 14);
        fillE(map, lakeR, lakeC, lakeRR + 2, lakeRC + 2, TB.SAND); fillE(map, lakeR, lakeC, lakeRR, lakeRC, TB.WATER);
        const startC = ri(35, 45), startR = ROWS - 5;
        const mid1R = lakeR + lakeRR + 3, mid1C = lakeC, mid2R = lakeR - lakeRR - 3;
        const topR = 5, topC = ri(30, 50), bridgeC = lakeC + ri(-3, 3);
        carveT(map, startR, startC, mid1R, startC, TB.PATH, 1); carveT(map, mid1R, startC, mid1R, mid1C, TB.PATH, 1);
        for (let r = lakeR - lakeRR - 1; r <= lakeR + lakeRR + 1; r++)for (let dc = -1; dc <= 1; dc++) { const cc = bridgeC + dc; if (r >= 0 && r < ROWS && cc >= 0 && cc < COLS) map[r][cc] = map[r][cc] === TB.WATER ? TB.BRIDGE : TB.PATH; }
        carveT(map, mid1R, mid1C, lakeR + lakeRR + 1, bridgeC, TB.PATH, 1); carveT(map, lakeR - lakeRR - 1, bridgeC, mid2R, bridgeC, TB.PATH, 1);
        carveT(map, mid2R, bridgeC, topR, bridgeC, TB.PATH, 1); carveT(map, topR, bridgeC, topR, topC, TB.PATH, 1);
        startPos = ensurePassable(map, startC * TSIZ + TSIZ / 2, (startR - 1) * TSIZ + TSIZ / 2);
        bossPos = ensurePassable(map, topC * TSIZ + TSIZ / 2, (topR + 1) * TSIZ + TSIZ / 2);
        const cells = bfsPassable(map, startR - 1, startC);
        questPos = [safeSpawnCell(cells, startPos.x, startPos.y, 200) || { x: 18 * TSIZ, y: 40 * TSIZ },
        safeSpawnCell(cells, startPos.x, startPos.y, 150) || { x: 60 * TSIZ, y: 35 * TSIZ },
        safeSpawnCell(cells, bossPos.x, bossPos.y, 200) || { x: mid1C * TSIZ, y: mid2R * TSIZ }].map(p => ({ ...p, collected: false }));
      } else if (biome === 'castle') {
        fillR(map, 3, 3, ROWS - 3, COLS - 3, TB.FLOOR);
        fillR(map, 3, 3, 8, COLS - 3, TB.WALL); fillR(map, ROWS - 8, 3, ROWS - 3, COLS - 3, TB.WALL);
        fillR(map, 3, 3, ROWS - 3, 8, TB.WALL); fillR(map, 3, COLS - 8, ROWS - 3, COLS - 3, TB.WALL);
        const rms = [{ r0: 8, c0: 8, r1: 22, c1: 28 }, { r0: 8, c0: 32, r1: 22, c1: 52 }, { r0: 8, c0: 56, r1: 22, c1: 72 },
        { r0: 24, c0: 8, r1: 38, c1: 28 }, { r0: 24, c0: 32, r1: 38, c1: 52 }, { r0: 24, c0: 56, r1: 38, c1: 72 },
        { r0: 40, c0: 8, r1: 55, c1: 28 }, { r0: 40, c0: 32, r1: 55, c1: 52 }, { r0: 40, c0: 56, r1: 55, c1: 72 }];
        for (const rm of rms) { fillR(map, rm.r0, rm.c0, rm.r1, rm.c1, TB.WALL); fillR(map, rm.r0 + 2, rm.c0 + 2, rm.r1 - 2, rm.c1 - 2, TB.FLOOR); fillR(map, rm.r0 + 2, rm.c0 + 2, rm.r0 + 4, rm.c0 + 4, TB.DARK); }
        const cors = [{ r: 15, c0: 28, c1: 32 }, { r: 15, c0: 52, c1: 56 }, { r: 31, c0: 28, c1: 32 }, { r: 31, c0: 52, c1: 56 }, { r: 47, c0: 28, c1: 32 }, { r: 47, c0: 52, c1: 56 }];
        for (const co of cors) fillR(map, co.r - 1, co.c0, co.r + 2, co.c1, TB.FLOOR);
        const eC = 42;
        carveT(map, ROWS - 9, eC, 40, eC, TB.PATH, 1); carveT(map, 40, eC, 31, 42, TB.PATH, 1); carveT(map, 31, 42, 15, 42, TB.PATH, 1); carveT(map, 15, 42, 8, 42, TB.PATH, 1);
        carveT(map, 31, 28, 31, 18, TB.PATH, 0); carveT(map, 31, 52, 31, 64, TB.PATH, 0);
        startPos = ensurePassable(map, eC * TSIZ + TSIZ / 2, (ROWS - 5) * TSIZ + TSIZ / 2);
        bossPos = ensurePassable(map, eC * TSIZ + TSIZ / 2, 9 * TSIZ + TSIZ / 2);
        const cells = bfsPassable(map, ROWS - 5, eC);
        questPos = [safeSpawnCell(cells, startPos.x, startPos.y, 200) || { x: 18 * TSIZ, y: 47 * TSIZ },
        safeSpawnCell(cells, startPos.x, startPos.y, 150) || { x: 64 * TSIZ, y: 47 * TSIZ },
        safeSpawnCell(cells, bossPos.x, bossPos.y, 200) || { x: 18 * TSIZ, y: 15 * TSIZ }].map(p => ({ ...p, collected: false }));
      } else {
        fillR(map, 3, 3, ROWS - 3, COLS - 3, TB.SNOW);
        for (let r = 3; r < ROWS - 3; r++)for (let c = 3; c < COLS - 3; c++) {
          const n = fbm(c * 0.1 + seed * 0.08, r * 0.1 + seed * 0.08), n2 = fbm(c * 0.07 + 30 + seed * 0.05, r * 0.07 + 30 + seed * 0.05);
          if (n > 0.69) map[r][c] = TB.ROCK; else if (n > 0.61 && n2 < 0.45) map[r][c] = TB.HILL;
          else if (n < 0.32) map[r][c] = TB.ICE; else if (n2 > 0.71 && n < 0.55) map[r][c] = TB.LAVA;
        }
        const ridgeR = ri(24, 30), ridge2R = ri(10, 16), lw = ri(12, 16), rw = ri(62, 66);
        for (let c = 3; c < COLS - 3; c++) { const j = Math.round(Math.sin(c * 0.3 + seed) * 2), h = 3 + Math.round(Math.sin(c * 0.15) * 1); for (let r = ridgeR + j; r < ridgeR + j + h && r < ROWS - 3; r++)if (r > 3) map[r][c] = TB.ROCK; }
        for (let c = 3; c < COLS - 3; c++) { const j = Math.round(Math.cos(c * 0.25 + seed) * 2), h = 2 + Math.round(Math.sin(c * 0.2) * 1); for (let r = ridge2R + j; r < ridge2R + j + h && r < ROWS - 3; r++)if (r > 3) map[r][c] = TB.ROCK; }
        for (let r = 3; r < ROWS - 3; r++) { const j = Math.round(Math.sin(r * 0.2 + seed) * 2); for (let c = 3; c < lw + j && c < COLS - 3; c++)if (c > 3) map[r][c] = TB.ROCK; }
        for (let r = 3; r < ROWS - 3; r++) { const j = Math.round(Math.sin(r * 0.2 + seed + 5) * 2); for (let c = rw + j; c < COLS - 3; c++)if (c > 3) map[r][c] = TB.ROCK; }
        const glacR = ri(36, 44), glacC = ri(26, 52);
        fillE(map, glacR, glacC, ri(5, 8), ri(9, 14), TB.ICE); fillE(map, glacR, glacC, ri(2, 4), ri(4, 7), TB.WATER);
        for (let i = 0; i < 4; i++)fillE(map, ri(4, ridge2R - 2), ri(15, 65), ri(1, 3), ri(2, 5), TB.LAVA);
        const pass1C = ri(30, 50), pass2C = ri(28, 52);
        fillR(map, ridgeR - 1, pass1C - 2, ridgeR + 5, pass1C + 3, TB.SNOW); fillR(map, ridge2R - 1, pass2C - 2, ridge2R + 4, pass2C + 3, TB.SNOW);
        const startC = ri(35, 45), startR = ROWS - 5, bossR = 5, bossC = ri(30, 50);
        carveT(map, startR, startC, ridgeR, startC, TB.PATH, 1); carveT(map, ridgeR, startC, ridgeR, pass1C, TB.PATH, 1);
        carveT(map, ridgeR, pass1C, ridge2R, pass1C, TB.PATH, 1); carveT(map, ridge2R, pass1C, ridge2R, pass2C, TB.PATH, 1);
        carveT(map, ridge2R, pass2C, bossR, pass2C, TB.PATH, 1); carveT(map, bossR, pass2C, bossR, bossC, TB.PATH, 1);
        startPos = ensurePassable(map, startC * TSIZ + TSIZ / 2, (startR - 1) * TSIZ + TSIZ / 2);
        bossPos = ensurePassable(map, bossC * TSIZ + TSIZ / 2, (bossR + 1) * TSIZ + TSIZ / 2);
        const cells = bfsPassable(map, startR - 1, startC);
        questPos = [safeSpawnCell(cells, startPos.x, startPos.y, 200) || { x: (lw + 5) * TSIZ, y: ridgeR * TSIZ },
        safeSpawnCell(cells, startPos.x, startPos.y, 150) || { x: glacC * TSIZ, y: glacR * TSIZ },
        safeSpawnCell(cells, bossPos.x, bossPos.y, 200) || { x: pass2C * TSIZ, y: (ridge2R - 4) * TSIZ }].map(p => ({ ...p, collected: false }));
      }
      return { map, questPos, bossPos, startPos };
    }

    function genDecos(mapD, biome) {
      const d = [];
      const icons = {
        forest: ['üå≤', 'üåø', 'üçÑ', 'üå∏', 'üå∫', 'üíé', 'ü™®', 'üå≥', 'ü¶ã', 'üåæ', 'üçÉ'],
        castle: ['üíé', 'ü™¶', 'üï∏Ô∏è', '‚öîÔ∏è', 'üõ°Ô∏è', 'üß±'],
        mountain: ['üèîÔ∏è', '‚ùÑÔ∏è', 'ü¶Ö', 'ü™®', 'üíé', 'üåü', '‚õ∞Ô∏è', 'üßä', 'üå¨Ô∏è']
      };
      const arr = icons[biome] || icons.forest;
      const { map } = mapD;
      for (let i = 0; i < 100; i++) {
        const c = Math.floor(Math.random() * COLS), r = Math.floor(Math.random() * ROWS);
        if (!map[r] || map[r][c] === undefined) continue;
        const t = map[r][c]; if (t === TB.PATH || BLOCK[t]) continue;
        if (Math.random() < 0.25) d.push({ x: c * TSIZ + TSIZ / 2, y: r * TSIZ + TSIZ / 2, icon: arr[Math.floor(Math.random() * arr.length)], off: Math.random() * Math.PI * 2, scale: 0.65 + Math.random() * 0.5 });
      }
      return d;
    }
    function genAmbient(biome) {
      const p = []; const count = biome === 'forest' ? 40 : biome === 'castle' ? 25 : 30;
      const icons = biome === 'forest' ? ['‚ú®', 'üçÉ'] : biome === 'castle' ? ['üí´', 'üî•'] : ['‚ùÑÔ∏è', '‚ú¶'];
      for (let i = 0; i < count; i++)p.push({ x: Math.random() * WW, y: Math.random() * WH, icon: icons[i % icons.length], spd: 0.3 + Math.random() * 0.5, off: Math.random() * Math.PI * 2, alpha: 0.2 + Math.random() * 0.35, sz: 8 + Math.random() * 8 });
      return p;
    }

    // ============================================================
    // GAME STATE
    // ============================================================
    let gRun = false, curLvl = 0, isDead = false;
    const SKILL_CD = [18, 75, 42, 110];
    const DASH_CD = 180; // 3 secondes √† 60fps
    const GS = {
      p: {
        x: 400, y: 300, vx: 0, vy: 0, hp: 5, maxHp: 5, xp: 0, lvl: 1, wPow: 1,
        weapon: '‚öîÔ∏è √âp√©e Rouill√©e', spd: 3.4, r: 12,
        atkCDs: [0, 0, 0, 0], atkAnim: 0, inv: 0, fx: 1, fy: 0,
        qItems: 0, qKills: 0, charging: false, chargeTime: 0,
        dashCD: 0, invincible: false, invincibleTimer: 0
      },
      cam: { x: 0, y: 0 }, map: null, mons: [], boss: null,
      decos: [], ambient: [], qItems: [],
      bossSpawned: false, bossDefeated: false,
      dlgActive: false, frame: 0, atks: [], shake: 0,
      lightPulse: 0, projectiles: [], spinAnim: null,
      bossProjectiles: [], bossWarnings: [],
      timeStop: false, timeStopTimer: 0,
      screenFlash: { r: 0, g: 0, b: 0, a: 0 }
    };

    // ============================================================
    // INPUT
    // ============================================================
    const K = {};
    document.addEventListener('keydown', e => {
      K[e.code] = true;
      if (['Space', 'KeyX'].includes(e.code)) { doAtk(0); e.preventDefault(); }
      if (e.code === 'KeyE') { doAtk(1); e.preventDefault(); }
      if (e.code === 'KeyR') { doAtk(2); e.preventDefault(); }
      if (e.code === 'KeyG' || e.code === 'ShiftLeft' || e.code === 'ShiftRight') { doDash(); e.preventDefault(); }
      if (e.code === 'KeyF') { if (!GS.p.charging) startCharge(); e.preventDefault(); }
      if (['Enter', 'Space'].includes(e.code) && GS.dlgActive) { nextLine(); e.preventDefault(); }
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) e.preventDefault();
    });
    document.addEventListener('keyup', e => { K[e.code] = false; if (e.code === 'KeyF' && GS.p.charging) releaseCharge(); });

    // ============================================================
    // MOBILE JOYSTICK
    // ============================================================
    const jZone = document.getElementById('joystick-zone');
    const jKnob = document.getElementById('joystick-knob');
    let joystickActive = false, jTouchId = null, jOriginX = 0, jOriginY = 0;
    const J_MAX = 48;
    function jStart(e) {
      e.preventDefault(); const t = e.changedTouches[0]; const rect = jZone.getBoundingClientRect();
      jTouchId = t.identifier; jOriginX = rect.left + rect.width / 2; jOriginY = rect.top + rect.height / 2; joystickActive = true; jMove(e);
    }
    function jMove(e) {
      e.preventDefault(); if (!joystickActive) return; let touch = null;
      for (let i = 0; i < e.changedTouches.length; i++)if (e.changedTouches[i].identifier === jTouchId) touch = e.changedTouches[i];
      if (!touch) return; let dx = touch.clientX - jOriginX, dy = touch.clientY - jOriginY;
      const d = Math.sqrt(dx * dx + dy * dy); if (d > J_MAX) { dx = dx / d * J_MAX; dy = dy / d * J_MAX; }
      jKnob.style.left = (72 + dx - 28) + 'px'; jKnob.style.top = (72 + dy - 28) + 'px';
      const mag = Math.sqrt(dx * dx + dy * dy);
      if (mag > 5) { GS.p.vx = dx / J_MAX; GS.p.vy = dy / J_MAX; GS.p.fx = dx / mag; GS.p.fy = dy / mag; } else { GS.p.vx = 0; GS.p.vy = 0; }
    }
    function jEnd(e) {
      e.preventDefault(); joystickActive = false; jTouchId = null;
      jKnob.style.left = '44px'; jKnob.style.top = '44px'; GS.p.vx = 0; GS.p.vy = 0;
    }
    jZone.addEventListener('touchstart', jStart, { passive: false });
    jZone.addEventListener('touchmove', jMove, { passive: false });
    jZone.addEventListener('touchend', jEnd, { passive: false });
    jZone.addEventListener('touchcancel', jEnd, { passive: false });

    // ‚îÄ‚îÄ‚îÄ Boutons skills mobiles ‚îÄ‚îÄ‚îÄ
    const skMap = [
      ['bsk-spin', () => doAtk(1)],
      ['bsk-proj', () => doAtk(2)],
      ['bsk-dash', () => doDash()],
      ['bsk-charge', 'charge'],
    ];
    for (const [id, action] of skMap) {
      const btn = document.getElementById(id);
      if (!btn) continue;
      if (action === 'charge') {
        btn.addEventListener('touchstart', (e) => { e.preventDefault(); startCharge(); }, { passive: false });
        btn.addEventListener('touchend', (e) => { e.preventDefault(); releaseCharge(); }, { passive: false });
      } else {
        btn.addEventListener('touchstart', (e) => { e.preventDefault(); action(); }, { passive: false });
      }
    }

    // ‚îÄ‚îÄ‚îÄ Canvas : 1 tap = attaque, double-tap = dash ‚îÄ‚îÄ‚îÄ
    let lastTap = 0;
    canvas.addEventListener('touchstart', (e) => {
      if (GS.dlgActive) { e.preventDefault(); nextLine(); return; }
      e.preventDefault();
      const now = Date.now();
      if (now - lastTap < 260) {
        doDash(); // double-tap
      } else {
        doAtk(0); // simple tap
      }
      lastTap = now;
    }, { passive: false });

    // ‚îÄ‚îÄ‚îÄ Clic souris (PC) : 1 clic = attaque, double-clic = dash ‚îÄ‚îÄ‚îÄ
    canvas.addEventListener('click', (e) => {
      if (!GS.dlgActive && !joystickActive) doAtk(0);
    });
    canvas.addEventListener('dblclick', (e) => {
      if (!GS.dlgActive) doDash();
    });

    // ============================================================
    // HELPERS
    // ============================================================
    function dst(a, b) { const dx = a.x - b.x, dy = a.y - b.y; return Math.sqrt(dx * dx + dy * dy); }
    function lerp(a, b, t) { return a + (b - a) * t; }
    function blk(wx, wy, map) { const c = Math.floor(wx / TSIZ), r = Math.floor(wy / TSIZ); if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return true; return !!BLOCK[map[r][c]]; }
    function dmgFx(wx, wy, val, cls) {
      const sx = wx - GS.cam.x, sy = wy - GS.cam.y;
      const d = document.createElement('div'); d.className = `dmg ${cls}`;
      d.textContent = (cls === 'heal' ? '+' : cls === 'crit' ? '‚òÖ' : '') + Math.abs(val);
      d.style.left = (sx + (Math.random() - 0.5) * 30) + 'px'; d.style.top = (sy - 30) + 'px';
      document.body.appendChild(d); setTimeout(() => d.remove(), 900);
    }
    function screenFlash(r, g, b, a, dur = 200) {
      const fl = document.getElementById('atkflash');
      fl.style.background = `radial-gradient(ellipse at center,rgba(${r},${g},${b},${a}) 0%,transparent 70%)`;
      fl.style.opacity = '1'; setTimeout(() => { fl.style.opacity = '0'; }, dur);
    }
    function warnFlash() {
      const w = document.getElementById('warn-overlay');
      w.style.opacity = '0.6'; w.style.borderColor = 'rgba(255,0,0,0.6)';
      setTimeout(() => { w.style.opacity = '0'; w.style.borderColor = 'transparent'; }, 150);
    }
    function hitMon(m, dmg, cls = 'normal') {
      if (m.state === 'dead' || m.state === 'dying') return;
      // Premier coup sur le boss = d√©but du combat
      if (m.boss && typeof BossMusic !== 'undefined' && !BossMusic.engaged) BossMusic.onCombatStart(curLvl);
      m.hp -= dmg; m.hitFlash = 8; m.state = 'chase';
      GS.shake = cls === 'crit' ? 10 : cls === 'boss' ? 4 : 3; sHit(); dmgFx(m.x, m.y, dmg, cls);
      if (m.hp <= 0) killMon(m);
    }
    function killMon(m) {
      m.state = 'dying'; m.dyingTimer = 22; sDie();
      GS.p.xp += m.xp;
      if (GS.p.xp >= GS.p.lvl * 100) { GS.p.lvl++; GS.p.xp = 0; GS.p.maxHp = Math.min(12, GS.p.maxHp + 1); GS.p.hp = GS.p.maxHp; sLvlUp(); dmgFx(GS.p.x, GS.p.y, GS.p.lvl, 'heal'); }
      updHUD();
      if (m.boss) {
        GS.bossDefeated = true;
        if (typeof BossMusic !== 'undefined') BossMusic.stop(2.0);
        document.getElementById('boss-hud').style.display = 'none';
        setTimeout(() => openDlg(m.icon, m.name, LEVELS[curLvl].bossDialog, () => showLT()), 600);
      } else if (LEVELS[curLvl].questType === 'kill') {
        GS.p.qKills++; updHUD();
        const lv = LEVELS[curLvl]; const mi = Math.min(GS.p.qKills - 1, lv.questMsgs.length - 1);
        const msg = lv.questMsgs[mi]; openDlg(msg[0], msg[1], msg.slice(2), null);
        if (GS.p.qKills >= lv.questCount && !GS.bossSpawned) spawnBoss();
      }
    }

    // ============================================================
    // PLAYER DAMAGE
    // ============================================================
    function damagePlayer(dmg, cls = 'normal') {
      const p = GS.p;
      // Invincibilit√© totale pendant le dash ‚Äî aucun d√©g√¢t
      if (p.invincible) return;
      if (p.inv > 0) return;
      // Premier d√©g√¢t boss sur le joueur = d√©but du combat
      if (GS.boss && GS.boss.state !== 'dead' && typeof BossMusic !== 'undefined' && !BossMusic.engaged) BossMusic.onCombatStart(curLvl);
      p.hp -= dmg; p.inv = 60; GS.shake = 6; sDmg();
      dmgFx(p.x, p.y, -dmg, cls); updHUD();
      warnFlash();
      if (p.hp <= 0) playerDie();
    }

    // ============================================================
    // DEATH / RESPAWN
    // ============================================================
    function playerDie() {
      if (isDead) return; isDead = true; gRun = false; sDeath(); GS.shake = 25;
      if (typeof BossMusic !== 'undefined') BossMusic.stop(0.8);
      screenFlash(200, 0, 0, 0.5, 600);
      document.getElementById('boss-hud').style.display = 'none';
      setTimeout(() => document.getElementById('deathscreen').style.display = 'flex', 900);
    }
    function restartLevel() {
      document.getElementById('deathscreen').style.display = 'none';
      isDead = false; gRun = true; loadLevel(curLvl);
    }

    // ============================================================
    // ATTACKS (PLAYER)
    // ============================================================
    function doAtk(type = 0) {
      if (GS.dlgActive || isDead) return;
      const p = GS.p; if (p.atkCDs[type] > 0) return;
      p.atkCDs[type] = SKILL_CD[type]; p.atkAnim = 14;
      if (type === 0) {
        sSwing(); GS.lightPulse = 10;
        screenFlash(255, 255, 255, 0.25, 60);
        const range = 55 + p.wPow * 5, angle = Math.atan2(p.fy, p.fx);
        GS.atks.push({ worldX: p.x + p.fx * 34, worldY: p.y + p.fy * 34, icon: '‚ú®', sz: 18, life: 10, maxLife: 10, vx: p.fx, vy: p.fy });
        const all = [...GS.mons]; if (GS.boss && GS.boss.state !== 'dead') all.push(GS.boss);
        for (const m of all) {
          if (m.state === 'dead' || m.state === 'dying') continue; if (dst(p, m) > range + m.r) continue;
          const ma = Math.atan2(m.y - p.y, m.x - p.x); let da = ma - angle;
          while (da > Math.PI) da -= Math.PI * 2; while (da < -Math.PI) da += Math.PI * 2;
          if (Math.abs(da) > 1.1) continue;
          const crit = Math.random() < 0.2;
          hitMon(m, Math.ceil(p.wPow * (crit ? 2.5 : 1) + (Math.random() < 0.3 ? 1 : 0)), crit ? 'crit' : 'normal');
        }
      } else if (type === 1) {
        sSpin(); GS.shake = 4; screenFlash(200, 100, 255, 0.3, 120);
        const range = 65 + p.wPow * 4;
        for (let i = 0; i < 8; i++) {
          const a = i / 8 * Math.PI * 2;
          GS.atks.push({ worldX: p.x + Math.cos(a) * range * 0.55, worldY: p.y + Math.sin(a) * range * 0.55, icon: 'üí•', sz: 19, life: 15, maxLife: 15, vx: Math.cos(a) * 0.4, vy: Math.sin(a) * 0.4 });
        }
        const all = [...GS.mons]; if (GS.boss && GS.boss.state !== 'dead') all.push(GS.boss);
        for (const m of all) {
          if (m.state === 'dead' || m.state === 'dying') continue; if (dst(p, m) > range + m.r) continue;
          hitMon(m, Math.ceil(p.wPow * 0.9 + (Math.random() < 0.25 ? 1 : 0)), 'spin');
        }
        GS.spinAnim = { timer: 24, maxTimer: 24 };
      } else if (type === 2) {
        sProj(); GS.lightPulse = 8;
        const icon = curLvl === 0 ? '‚ö°' : curLvl === 1 ? 'üîÆ' : '‚ùÑÔ∏è';
        GS.projectiles.push({ x: p.x + p.fx * 20, y: p.y + p.fy * 20, vx: p.fx * 6.2, vy: p.fy * 6.2, power: Math.ceil(p.wPow), icon, sz: 20, life: 85, r: 10, owner: 'player' });
        GS.atks.push({ worldX: p.x + p.fx * 20, worldY: p.y + p.fy * 20, icon, sz: 22, life: 8, maxLife: 8, vx: p.fx * 0.3, vy: p.fy * 0.3 });
      } else if (type === 3) {
        if (p.charging) releaseCharge(); else startCharge();
      }
      updSkillBar();
    }
    function startCharge() { if (GS.dlgActive || isDead) return; GS.p.charging = true; GS.p.chargeTime = 0; }
    function releaseCharge() {
      const p = GS.p; if (!p.charging) return; p.charging = false;
      if (p.atkCDs[3] > 0) { p.chargeTime = 0; return; }
      p.atkCDs[3] = SKILL_CD[3]; const charge = Math.min(1, p.chargeTime / 60); sCharge();
      screenFlash(255, 200, 50, 0.8, 180); GS.shake = 12 + charge * 8; GS.lightPulse = 24;
      const range = (74 + p.wPow * 6) * (1 + charge * 0.8), angle = Math.atan2(p.fy, p.fx);
      for (let i = 0; i < 6; i++) {
        const sp = (Math.random() - 0.5) * 1.8;
        GS.atks.push({ worldX: p.x + p.fx * range * 0.5, worldY: p.y + p.fy * range * 0.5, icon: 'üí´', sz: 30 + charge * 14, life: 22, maxLife: 22, vx: p.fx + sp, vy: p.fy + sp });
      }
      const all = [...GS.mons]; if (GS.boss && GS.boss.state !== 'dead') all.push(GS.boss);
      for (const m of all) {
        if (m.state === 'dead' || m.state === 'dying') continue; if (dst(p, m) > range + m.r) continue;
        const ma = Math.atan2(m.y - p.y, m.x - p.x); let da = ma - angle;
        while (da > Math.PI) da -= Math.PI * 2; while (da < -Math.PI) da += Math.PI * 2;
        if (Math.abs(da) > 1.4) continue;
        const dmg = Math.ceil(p.wPow * (1 + charge * 3.5));
        hitMon(m, dmg, 'crit');
        if (m.state !== 'dying') { const kd = Math.min(70, 100 / (dst(p, m) + 1)); m.x += (m.x - p.x) / (dst(p, m) + 1) * kd; m.y += (m.y - p.y) / (dst(p, m) + 1) * kd; }
      }
      p.chargeTime = 0; updSkillBar();
    }

    // ‚îÄ‚îÄ ESQUIVE / DASH ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const INVINCIBLE_DUR = 36; // ~0.6s √† 60fps
    function doDash() {
      if (GS.dlgActive || isDead) return;
      const p = GS.p; if (p.dashCD > 0) return;
      p.dashCD = DASH_CD;
      // Dash dans la direction du mouvement (ou vers l'avant si immobile)
      const dx = p.vx !== 0 || p.vy !== 0 ? p.vx : p.fx;
      const dy = p.vx !== 0 || p.vy !== 0 ? p.vy : p.fy;
      const mag = Math.sqrt(dx * dx + dy * dy) || 1;
      const nx = dx / mag, ny = dy / mag;
      // Propulser le joueur
      const dashDist = 80; const { map } = GS.map;
      let tx = p.x + nx * dashDist, ty = p.y + ny * dashDist;
      // Pas dans un mur
      if (blk(tx, p.y, map)) tx = p.x;
      if (blk(p.x, ty, map)) ty = p.y;
      p.x = tx; p.y = ty;
      // Invincibilit√©
      p.invincible = true; p.invincibleTimer = INVINCIBLE_DUR;
      p.inv = INVINCIBLE_DUR + 10; // immunit√© d√©g√¢ts normaux aussi
      // Effets visuels
      GS.shake = 3;
      screenFlash(0, 255, 200, 0.35, 180);
      // Train√©e
      for (let i = 0; i < 6; i++) {
        GS.atks.push({
          worldX: p.x - nx * i * 12, worldY: p.y - ny * i * 12,
          icon: 'üí®', sz: 18 - i * 2, life: 14 - i, maxLife: 14, vx: -nx * 0.5, vy: -ny * 0.5
        });
      }
      // Son
      try {
        const c = ac(), o = c.createOscillator(), g = c.createGain();
        o.connect(g); g.connect(c.destination); o.type = 'sine';
        o.frequency.setValueAtTime(800, c.currentTime); o.frequency.linearRampToValueAtTime(400, c.currentTime + 0.12);
        g.gain.setValueAtTime(0.12, c.currentTime); g.gain.linearRampToValueAtTime(0, c.currentTime + 0.14);
        o.start(); o.stop(c.currentTime + 0.16);
      } catch (e) { }
      updDashBtn();
    }
    function updSkillBar() {
      // Skill 1 = SPIN (atkCDs[1])
      _updSkRing('bsk-spin', 'ring-spin', GS.p.atkCDs[1], SKILL_CD[1]);
      // Skill 2 = PROJ (atkCDs[2])
      _updSkRing('bsk-proj', 'ring-proj', GS.p.atkCDs[2], SKILL_CD[2]);
      // Skill 3 = CHARGE (atkCDs[3])
      _updSkRing('bsk-charge', 'ring-charge', GS.p.atkCDs[3], SKILL_CD[3]);
      updDashBtn();
    }
    function _updSkRing(btnId, ringId, cd, max) {
      const btn = document.getElementById(btnId);
      const ring = document.getElementById(ringId);
      if (!btn || !ring) return;
      if (cd > 0) {
        const pct = ((max - cd) / max * 100);
        ring.style.setProperty('--p', pct + '%'); ring.classList.add('on'); btn.classList.add('cd');
      } else { ring.classList.remove('on'); btn.classList.remove('cd'); }
    }
    function updDashBtn() {
      const btn = document.getElementById('bsk-dash');
      const ring = document.getElementById('ring-dash');
      if (!btn || !ring) return;
      const p = GS.p;
      if (p.invincible) {
        btn.classList.add('inv'); btn.classList.remove('cd'); ring.classList.remove('on');
        document.getElementById('invincible-overlay').classList.add('active');
      } else {
        btn.classList.remove('inv');
        document.getElementById('invincible-overlay').classList.remove('active');
        if (p.dashCD > 0) {
          const pct = ((DASH_CD - p.dashCD) / DASH_CD * 100);
          ring.style.setProperty('--p', pct + '%'); ring.classList.add('on'); btn.classList.add('cd');
        } else { ring.classList.remove('on'); btn.classList.remove('cd'); }
      }
    }

    // ============================================================
    // BOSS SPAWN
    // ============================================================
    function spawnBoss() {
      if (GS.bossSpawned) return; GS.bossSpawned = true;
      const lv = LEVELS[curLvl]; const pos = GS.map.bossPos;
      GS.boss = {
        icon: lv.bossIcon, name: lv.bossName, hp: lv.bossHP, maxHp: lv.bossHP,
        spd: lv.bossSpeed || (0.55 + curLvl * 0.12), dmg: 2 + curLvl, x: pos.x, y: pos.y,
        state: 'idle', dyingTimer: 0, atkCD: 0,
        aggroR: lv.bossAggroR || 480, loseR: 700, warnR: lv.bossWarnR || null, wAngle: 0, wTimer: 0,
        hitFlash: 0, r: 24, boss: true, xp: 80 + curLvl * 40,
        // Boss-specific
        phase: 0, phaseTimer: 0, pattern: 0, patternTimer: 0,
        patterns: lv.bossPatterns || [],
        dashTarget: { x: pos.x, y: pos.y }, dashTimer: 0, dashActive: false,
        teleportCooldown: 0, rageMode: false,
        warningTimer: 0, beamAngle: 0, beamActive: false, beamTimer: 0,
        orbiting: false, orbitAngle: 0,
        timeStopActive: false,
        // Boss 2 warning
        warnZone: false, warnZoneTimer: 0, warnZoneAlerted: false,
        // Boss 3 aerial
        aerialActive: false, aerialTimer: 0, aerialTargetX: 0, aerialTargetY: 0
      };
      GS.bossSpawned = true;
      // Setup boss HP bar
      const bossHud = document.getElementById('boss-hud');
      bossHud.style.display = 'flex';
      document.getElementById('boss-hud-name').textContent = lv.bossName.toUpperCase();
      // Phase pips
      const pip = document.getElementById('boss-phase-wrap'); pip.innerHTML = '';
      const phases = lv.bossPhases || 2;
      for (let i = 0; i < phases; i++) { const d = document.createElement('div'); d.className = 'boss-phase-pip' + (i === 0 ? ' active' : ''); d.id = `bpip${i}`; pip.appendChild(d); }
      sBossSpawn();
      if (typeof BossMusic !== 'undefined') BossMusic.onSpawnBoss(curLvl);
      openDlg('‚ö†Ô∏è', 'DANGER !', [`üëπ ${lv.bossName} APPARA√éT !`, 'Attention ! Ce boss a des patterns d√©vastateurs !', 'Esquive et frappe au bon moment !'], null);
    }
    function updBossHPBar() {
      const b = GS.boss; if (!b) return;
      const pct = Math.max(0, b.hp / b.maxHp * 100);
      document.getElementById('boss-hp-fill').style.width = pct + '%';
      // Phase transitions
      const lv = LEVELS[curLvl]; const phases = lv.bossPhases || 2;
      const threshold = 1 / phases;
      const currentPhase = Math.floor((1 - b.hp / b.maxHp) / threshold);
      if (currentPhase !== b.phase && currentPhase < phases) {
        b.phase = currentPhase;
        // Light up phase pip
        for (let i = 0; i < phases; i++) { const pip = document.getElementById(`bpip${i}`); if (pip) pip.classList.toggle('active', i <= currentPhase); }
        // Rage at last phase
        if (currentPhase >= phases - 1) { b.rageMode = true; sBossRage(); screenFlash(255, 50, 0, 0.6, 500); GS.shake = 20; if (typeof BossMusic !== 'undefined') BossMusic.onRageMode(curLvl); }
      }
    }

    // ============================================================
    // BOSS AI ‚Äî Patterns
    // ============================================================
    function doBossPattern(b) {
      const p = GS.p; const lv = LEVELS[curLvl];
      if (!b.patterns || b.patterns.length === 0) return;
      if (b.patternTimer > 0) { b.patternTimer--; return; }
      // Pick next pattern
      const patterns = b.patterns;
      const patIdx = Math.floor(GS.frame / 200) % patterns.length;
      const pattern = patterns[patIdx + (b.rageMode ? 1 : 0) % patterns.length] || patterns[0];
      const cd = b.rageMode ? 140 : 200;
      b.patternTimer = cd;
      executeBossPattern(b, pattern, p);
    }

    function executeBossPattern(b, pattern, p) {
      switch (pattern) {
        // ---- PATTERN 1: Slash (melee dash toward player) ----
        case 'slash': {
          if (dst(b, p) < 200) {
            b.dashActive = true; b.dashTimer = 12;
            const ang = Math.atan2(p.y - b.y, p.x - b.x);
            b.dashVx = Math.cos(ang) * 10; b.dashVy = Math.sin(ang) * 10;
            // Warning indicator
            GS.bossWarnings.push({ x: p.x, y: p.y, r: 60, life: 25, maxLife: 25, type: 'circle', color: '#ff4400' });
            sBossDash();
          }
          break;
        }
        // ---- PATTERN 2: Poison ring ----
        case 'poison_ring': {
          for (let i = 0; i < 8; i++) {
            const ang = i / 8 * Math.PI * 2;
            GS.bossProjectiles.push({ x: b.x, y: b.y, vx: Math.cos(ang) * 2.2, vy: Math.sin(ang) * 2.2, icon: '‚ò†Ô∏è', sz: 18, life: 100, r: 12, dmg: 2, cls: 'spin' });
          }
          GS.bossWarnings.push({ x: b.x, y: b.y, r: 80, life: 20, maxLife: 20, type: 'ring', color: '#44ff44' });
          screenFlash(0, 200, 0, 0.25, 200); sBossWave();
          break;
        }
        // ---- PATTERN 3: Teleport strike ----
        case 'teleport_strike': {
          if (b.teleportCooldown <= 0) {
            // Teleport near player
            const ang = Math.random() * Math.PI * 2; const dist = 80 + Math.random() * 60;
            const nx = p.x + Math.cos(ang) * dist, ny = p.y + Math.sin(ang) * dist;
            // Safety check
            if (!blk(nx, ny, GS.map.map)) {
              // Warning first
              GS.bossWarnings.push({ x: nx, y: ny, r: 50, life: 30, maxLife: 30, type: 'circle', color: '#cc00ff' });
              setTimeout(() => {
                if (b.state === 'dead' || b.state === 'dying') return;
                b.x = nx; b.y = ny; b.hitFlash = 5;
                GS.atks.push({ worldX: b.x, worldY: b.y, icon: 'üåÄ', sz: 40, life: 18, maxLife: 18, vx: 0, vy: 0 });
                screenFlash(150, 0, 255, 0.4, 200); sBossDash();
                // Instant hit if still close
                if (dst(b, p) < 60) damagePlayer(3, 'spin');
              }, 500);
              b.teleportCooldown = 180;
            }
          }
          break;
        }
        // ---- PATTERN 4: Shadow wave (row of projectiles) ----
        case 'shadow_wave': {
          const ang = Math.atan2(p.y - b.y, p.x - b.x);
          for (let i = -2; i <= 2; i++) {
            const a = ang + i * 0.25;
            setTimeout(() => {
              if (b.state === 'dead' || b.state === 'dying') return;
              GS.bossProjectiles.push({ x: b.x, y: b.y, vx: Math.cos(a) * 4, vy: Math.sin(a) * 4, icon: 'üíú', sz: 22, life: 90, r: 14, dmg: 2, cls: 'spin' });
            }, i * 80 + 80);
          }
          GS.bossWarnings.push({ x: b.x, y: b.y, r: 120, life: 24, maxLife: 24, type: 'ring', color: '#8800ff' });
          sBossWave();
          break;
        }
        // ---- PATTERN 5: Death beam (sweeping laser) ----
        case 'death_beam': {
          // Charge-up phase first ‚Äî boss stops, glows, then fires
          b.beamCharging = true; b.beamChargeTimer = 70; // ~1.2s warning
          b.beamTargetAngle = Math.atan2(p.y - b.y, p.x - b.x);
          b.beamSweepDir = 1; b.beamDmgCD = 0;
          // Big visible warnings: multiple expanding rings + screen tint
          for (let i = 0; i < 3; i++) {
            setTimeout(() => {
              if (b.state === 'dead' || b.state === 'dying') return;
              GS.bossWarnings.push({ x: b.x, y: b.y, r: 60 + i * 60, life: 50, maxLife: 50, type: 'ring', color: '#ff0000' });
            }, i * 200);
          }
          // Directional warning line (shows where beam will fire)
          GS.bossWarnings.push({ x: b.x, y: b.y, r: 260, life: 65, maxLife: 65, type: 'beam_warn', angle: b.beamTargetAngle, color: '#ff4400' });
          screenFlash(255, 0, 0, 0.25, 1200); sBossBeam();
          // Actually fire after charge-up delay
          setTimeout(() => {
            if (b.state === 'dead' || b.state === 'dying' || !b.beamCharging) return;
            b.beamCharging = false;
            b.beamActive = true; b.beamTimer = 100;
            b.beamAngle = b.beamTargetAngle - 0.5;
            screenFlash(255, 80, 0, 0.5, 300); GS.shake = 10;
          }, 1150);
          break;
        }
        // ---- PATTERN 6: Fireball burst ----
        case 'fireball_burst': {
          for (let i = 0; i < 12; i++) {
            setTimeout(() => {
              if (b.state === 'dead' || b.state === 'dying') return;
              const ang = Math.atan2(p.y - b.y, p.x - b.x) + (Math.random() - 0.5) * 0.6;
              GS.bossProjectiles.push({ x: b.x, y: b.y, vx: Math.cos(ang) * 4.5, vy: Math.sin(ang) * 4.5, icon: 'üî•', sz: 24, life: 70, r: 14, dmg: 3, cls: 'fire' });
            }, i * 80);
          }
          GS.bossWarnings.push({ x: b.x, y: b.y, r: 150, life: 26, maxLife: 26, type: 'ring', color: '#ff5500' });
          screenFlash(255, 150, 0, 0.4, 300); sBossBeam();
          break;
        }
        // ---- PATTERN 7: Dash slam (fast dash then shockwave) ----
        case 'dash_slam': {
          const ang = Math.atan2(p.y - b.y, p.x - b.x);
          b.dashActive = true; b.dashTimer = 18;
          b.dashVx = Math.cos(ang) * 14; b.dashVy = Math.sin(ang) * 14;
          GS.bossWarnings.push({ x: p.x, y: p.y, r: 90, life: 28, maxLife: 28, type: 'circle', color: '#ff8800' });
          sBossDash();
          // After dash, shockwave
          setTimeout(() => {
            if (b.state === 'dead' || b.state === 'dying') return;
            for (let i = 0; i < 12; i++) {
              const a = i / 12 * Math.PI * 2;
              GS.bossProjectiles.push({ x: b.x, y: b.y, vx: Math.cos(a) * 3.5, vy: Math.sin(a) * 3.5, icon: 'üåä', sz: 20, life: 60, r: 12, dmg: 2, cls: 'ice' });
            }
            GS.shake = 15; screenFlash(255, 200, 50, 0.5, 250);
          }, 350);
          break;
        }
        // ---- PATTERN 8: Time stop ----
        case 'time_stop': {
          GS.timeStop = true; GS.timeStopTimer = 120;
          screenFlash(100, 100, 255, 0.6, 600); GS.shake = 12;
          // During time stop, boss fires a spiral
          for (let i = 0; i < 20; i++) {
            setTimeout(() => {
              if (b.state === 'dead' || b.state === 'dying') return;
              const a = i * 0.5;
              GS.bossProjectiles.push({ x: b.x, y: b.y, vx: Math.cos(a) * 3, vy: Math.sin(a) * 3, icon: '‚è∞', sz: 18, life: 80, r: 12, dmg: 2, cls: 'ice' });
            }, i * 100);
          }
          sBossRage();
          break;
        }
        // ---- PATTERN 9: Meteor shower ----
        case 'meteor': {
          for (let i = 0; i < 6; i++) {
            setTimeout(() => {
              if (b.state === 'dead' || b.state === 'dying') return;
              const tx = p.x + (Math.random() - 0.5) * 200; const ty = p.y + (Math.random() - 0.5) * 200;
              GS.bossWarnings.push({ x: tx, y: ty, r: 55, life: 40, maxLife: 40, type: 'circle', color: '#ff3300' });
              setTimeout(() => {
                if (b.state === 'dead' || b.state === 'dying') return;
                GS.atks.push({ worldX: tx, worldY: ty, icon: '‚òÑÔ∏è', sz: 44, life: 22, maxLife: 22, vx: 0, vy: 0 });
                GS.shake = 10;
                if (dst({ x: tx, y: ty }, p) < 65) damagePlayer(4, 'fire');
              }, 600);
            }, i * 200);
          }
          sBossBeam();
          break;
        }
        // ---- PATTERN 10: Enrage (speed + fire ring) ----
        case 'enrage': {
          b.rageMode = true;
          for (let i = 0; i < 16; i++) {
            const a = i / 16 * Math.PI * 2;
            GS.bossProjectiles.push({ x: b.x, y: b.y, vx: Math.cos(a) * 3, vy: Math.sin(a) * 3, icon: 'üí¢', sz: 16, life: 120, r: 10, dmg: 2, cls: 'fire' });
          }
          GS.shake = 18; screenFlash(255, 0, 0, 0.6, 500); sBossRage();
          break;
        }
        // ---- PATTERN 11: Aerial Slam (Dragon takes flight, picks target, CRASHES DOWN) ----
        case 'aerial_slam': {
          if (b.aerialActive) break; // already in flight
          b.aerialActive = true;
          b.aerialTimer = 0;
          b.aerialTargetX = p.x;
          b.aerialTargetY = p.y;
          b.aerialPhase = 'rising'; // rising ‚Üí hovering ‚Üí warning ‚Üí slamming ‚Üí impact
          // Phase 1: Dragon rises (scale up, glow)
          screenFlash(255, 100, 0, 0.4, 300); GS.shake = 8;
          sBossRage();
          // Store original pos for rendering offset
          b.aerialOriginX = b.x; b.aerialOriginY = b.y;
          b.aerialRiseTimer = 50; // frames rising
          b.patternTimer += 220; // give extra cooldown since this is a long attack
          break;
        }
      }
    }

    // ============================================================
    // MONSTER AI
    // ============================================================
    function updMons() {
      if (GS.timeStop && GS.timeStopTimer > 0) {
        GS.timeStopTimer--; if (GS.timeStopTimer <= 0) { GS.timeStop = false; screenFlash(100, 100, 255, 0.3, 300); }
        // Only update boss during time stop (it attacks)
        if (GS.boss && GS.boss.state !== 'dead' && GS.boss.state !== 'dying') {
          updBoss(GS.boss); updBossHPBar();
        }
        return;
      }
      const p = GS.p; const { map } = GS.map;
      for (const m of GS.mons) {
        if (m.hitFlash > 0) m.hitFlash--; if (m.atkCD > 0) m.atkCD--;
        if (m.state === 'dying') { m.dyingTimer--; if (m.dyingTimer <= 0) m.state = 'dead'; continue; }
        if (m.state === 'dead') continue;
        const d = dst(m, p);
        if (m.state === 'idle' || m.state === 'wander') {
          m.wTimer--; if (m.wTimer <= 0) { m.wAngle += (Math.random() - 0.5) * Math.PI; m.wTimer = 60 + Math.random() * 90; }
          m.vx = Math.cos(m.wAngle) * m.spd * 0.3; m.vy = Math.sin(m.wAngle) * m.spd * 0.3; m.state = 'wander';
          if (d < m.aggroR) m.state = 'chase';
        }
        if (m.state === 'chase') {
          if (d > m.loseR) { m.state = 'idle'; m.vx = 0; m.vy = 0; continue; }
          m.vx = lerp(m.vx, (p.x - m.x) / d * m.spd, 0.12); m.vy = lerp(m.vy, (p.y - m.y) / d * m.spd, 0.12);
          if (d < m.r + p.r + 6 && m.atkCD <= 0) { damagePlayer(m.dmg, 'normal'); m.atkCD = 65; }
        }
        let nx = m.x + m.vx, ny = m.y + m.vy;
        if (!blk(nx, m.y, map)) m.x = nx; else m.vx *= -1;
        if (!blk(m.x, ny, map)) m.y = ny; else m.vy *= -1;
        m.x = Math.max(TSIZ, Math.min(WW - TSIZ, m.x)); m.y = Math.max(TSIZ, Math.min(WH - TSIZ, m.y));
      }
      if (GS.boss && GS.boss.state !== 'dead') { updBoss(GS.boss); updBossHPBar(); }
    }

    function updBoss(b) {
      if (b.hitFlash > 0) b.hitFlash--; if (b.atkCD > 0) b.atkCD--; if (b.teleportCooldown > 0) b.teleportCooldown--;
      if (b.state === 'dying') { b.dyingTimer--; if (b.dyingTimer <= 0) b.state = 'dead'; return; }
      if (b.state === 'dead') return;
      const p = GS.p; const d = dst(b, p); const { map } = GS.map;
      // Boss 2: show "DANGER" warning zone before aggro
      if (b.warnR && b.state === 'idle' && !b.warnZoneAlerted) {
        if (d < b.warnR) {
          b.warnZoneAlerted = true;
          GS.bossWarnings.push({ x: b.x, y: b.y, r: b.warnR, life: 60, maxLife: 60, type: 'warn_zone', color: '#ff8800' });
          screenFlash(255, 120, 0, 0.3, 800); GS.shake = 6;
          // pulse warning to player
          for (let i = 0; i < 3; i++) setTimeout(() => { if (b.state === 'dead') return; GS.bossWarnings.push({ x: b.x, y: b.y, r: b.warnR * 0.6, life: 30, maxLife: 30, type: 'ring', color: '#ff6600' }); }, i * 350);
        }
      }
      if (b.state === 'idle') { if (d < b.aggroR) { b.state = 'chase'; if (b.warnR) { screenFlash(255, 50, 0, 0.5, 400); GS.shake = 12; } } }
      if (b.state === 'chase' || b.state === 'attack') {
        // Dash movement
        if (b.dashActive && b.dashTimer > 0) {
          b.dashTimer--;
          const nx = b.x + b.dashVx, ny = b.y + b.dashVy;
          if (!blk(nx, b.y, map)) b.x = nx; else { b.dashVx *= -0.5; b.x += b.dashVx; }
          if (!blk(b.x, ny, map)) b.y = ny; else { b.dashVy *= -0.5; b.y += b.dashVy; }
          // Damage if hits player during dash
          if (dst(b, p) < b.r + p.r + 10 && b.atkCD <= 0) { damagePlayer(b.dmg + 1, 'boss'); b.atkCD = 40; }
          if (b.dashTimer <= 0) { b.dashActive = false; GS.shake = 8; }
        } else if (b.aerialActive && (b.aerialPhase === 'rising' || b.aerialPhase === 'hovering' || b.aerialPhase === 'frozen')) {
          // During aerial: hover in place, don't move horizontally
          b.vx = 0; b.vy = 0;
        } else {
          // Normal chase ‚Äî boss PHASES through walls (no getting stuck!)
          const spd = b.rageMode ? b.spd * 1.7 : b.spd;
          const tx = (p.x - b.x) / d * spd, ty = (p.y - b.y) / d * spd;
          b.vx = lerp(b.vx || 0, tx, 0.08); b.vy = lerp(b.vy || 0, ty, 0.08);
          // Bosses are too powerful to be stopped by walls ‚Äî they phase through!
          b.x += b.vx || 0; b.y += b.vy || 0;
          // Wall phase visual effect: emit ghostly particles when inside a wall
          if (blk(b.x, b.y, map)) {
            GS.atks.push({ worldX: b.x, worldY: b.y, icon: 'üëÅÔ∏è', sz: 28, life: 12, maxLife: 12, vx: (Math.random() - 0.5) * 1.5, vy: (Math.random() - 0.5) * 1.5 });
          }
        }
        b.x = Math.max(TSIZ, Math.min(WW - TSIZ, b.x)); b.y = Math.max(TSIZ, Math.min(WH - TSIZ, b.y));
        // Melee attack
        if (d < b.r + p.r + 10 && b.atkCD <= 0 && !b.dashActive) { damagePlayer(b.dmg, 'boss'); b.atkCD = 55; }
        // Beam damage
        if (b.beamActive && b.beamTimer > 0) {
          b.beamTimer--;
          // Slow sweep ‚Äî much more dodgeable
          b.beamAngle += 0.008 * b.beamSweepDir * (b.rageMode ? 1.3 : 1);
          if (b.beamDmgCD > 0) b.beamDmgCD--;
          const beamDirX = Math.cos(b.beamAngle), beamDirY = Math.sin(b.beamAngle);
          const toPX = p.x - b.x, toPY = p.y - b.y;
          const dot = toPX * beamDirX + toPY * beamDirY;
          const cross = Math.abs(toPX * beamDirY - toPY * beamDirX);
          // Damage only every 30 frames (0.5s) and only if truly in beam
          if (dot > 0 && cross < 24 && dst(b, p) < 450 && b.beamDmgCD <= 0) {
            damagePlayer(b.rageMode ? 2 : 1, 'fire');
            b.beamDmgCD = 30;
          }
          if (b.beamTimer <= 0) { b.beamActive = false; }
        }
        // Pattern trigger
        doBossPattern(b);
        // ---- AERIAL SLAM (Boss 3) state machine ----
        if (b.aerialActive) {
          b.aerialTimer++;
          const t = b.aerialTimer;
          if (b.aerialPhase === 'rising') {
            // Move upward visually (we store aerialY offset)
            b.aerialYOff = (b.aerialYOff || 0) - 2.5;
            if (b.aerialYOff < -80) b.aerialYOff = -80;
            if (t >= b.aerialRiseTimer) {
              b.aerialPhase = 'hovering';
              b.aerialTimer = 0;
              // Lock onto current player position for slam
              b.aerialTargetX = p.x; b.aerialTargetY = p.y;
            }
          } else if (b.aerialPhase === 'hovering') {
            // 40 frames: dragon hovers above, shadow + warning circle grows below
            const progress = t / 40;
            if (t % 8 === 0) GS.bossWarnings.push({ x: b.aerialTargetX, y: b.aerialTargetY, r: 20 + progress * 80, life: 18, maxLife: 18, type: 'slam_zone', color: '#ff3300' });
            if (t === 15) { screenFlash(255, 50, 0, 0.3, 200); GS.shake = 4; }
            if (t >= 40) {
              b.aerialPhase = 'frozen'; // freeze moment before slam
              b.aerialTimer = 0;
              // Big final warning
              GS.bossWarnings.push({ x: b.aerialTargetX, y: b.aerialTargetY, r: 90, life: 20, maxLife: 20, type: 'slam_zone', color: '#ff0000' });
              screenFlash(255, 0, 0, 0.6, 300); GS.shake = 10;
            }
          } else if (b.aerialPhase === 'frozen') {
            // Freeze in air for dramatic effect (20 frames)
            b.aerialYOff = (b.aerialYOff || -80); // stay up
            if (t >= 20) {
              b.aerialPhase = 'slamming';
              b.aerialTimer = 0;
              sBossRage();
            }
          } else if (b.aerialPhase === 'slamming') {
            // Fast crash down (15 frames)
            const progress = Math.min(1, t / 15);
            b.aerialYOff = -80 * (1 - progress);
            b.x = lerp(b.x, b.aerialTargetX, 0.18);
            b.y = lerp(b.y, b.aerialTargetY, 0.08);
            if (t >= 15 || (b.aerialYOff >= -5)) {
              b.aerialYOff = 0;
              b.x = b.aerialTargetX; b.y = b.aerialTargetY;
              b.aerialPhase = 'impact';
              b.aerialTimer = 0;
              // IMPACT ‚Äî massive damage, shockwave, screen shake
              GS.shake = 30; screenFlash(255, 100, 0, 0.9, 400);
              const impDist = dst(b, p);
              if (impDist < 110) { damagePlayer(b.rageMode ? 7 : 5, 'fire'); }
              else if (impDist < 180) { damagePlayer(b.rageMode ? 4 : 2, 'fire'); }
              // Shockwave projectiles radially
              for (let i = 0; i < 16; i++) {
                const a = i / 16 * Math.PI * 2;
                GS.bossProjectiles.push({ x: b.x, y: b.y, vx: Math.cos(a) * 5, vy: Math.sin(a) * 5, icon: 'üî•', sz: 22, life: 55, r: 13, dmg: b.rageMode ? 3 : 2, cls: 'fire' });
              }
              // Big impact visuals
              for (let i = 0; i < 10; i++) {
                GS.atks.push({ worldX: b.x + (Math.random() - 0.5) * 80, worldY: b.y + (Math.random() - 0.5) * 80, icon: 'üí•', sz: 34 + Math.random() * 20, life: 22, maxLife: 22, vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2 });
              }
              sBossBeam();
            }
          } else if (b.aerialPhase === 'impact') {
            if (t >= 30) { b.aerialActive = false; b.aerialYOff = 0; b.aerialPhase = null; }
          }
        }
      }
    }

    // ============================================================
    // PROJECTILE UPDATE
    // ============================================================
    function updProjectiles() {
      const { map } = GS.map; const p = GS.p;
      // Player projectiles
      for (let i = GS.projectiles.length - 1; i >= 0; i--) {
        const pr = GS.projectiles[i]; pr.life--; pr.x += pr.vx; pr.y += pr.vy;
        if (blk(pr.x, pr.y, map) || pr.life <= 0) { GS.projectiles.splice(i, 1); continue; }
        let hit = false;
        const all = [...GS.mons]; if (GS.boss && GS.boss.state !== 'dead') all.push(GS.boss);
        for (const m of all) {
          if (m.state === 'dead' || m.state === 'dying') continue;
          if (dst(pr, m) < m.r + pr.r) {
            const cls = curLvl === 2 ? 'ice' : curLvl === 1 ? 'fire' : 'normal';
            hitMon(m, pr.power, cls);
            GS.atks.push({ worldX: pr.x, worldY: pr.y, icon: 'üí•', sz: 24, life: 12, maxLife: 12, vx: 0, vy: 0 });
            GS.projectiles.splice(i, 1); hit = true; break;
          }
        }
      }
      // Boss projectiles
      for (let i = GS.bossProjectiles.length - 1; i >= 0; i--) {
        const pr = GS.bossProjectiles[i]; pr.life--; pr.x += pr.vx; pr.y += pr.vy;
        if (blk(pr.x, pr.y, map) || pr.life <= 0) { GS.bossProjectiles.splice(i, 1); continue; }
        if (dst(pr, p) < p.r + pr.r) {
          damagePlayer(pr.dmg, pr.cls || 'normal');
          GS.atks.push({ worldX: pr.x, worldY: pr.y, icon: 'üí•', sz: 22, life: 10, maxLife: 10, vx: 0, vy: 0 });
          GS.bossProjectiles.splice(i, 1);
        }
      }
      // Boss warnings
      for (let i = GS.bossWarnings.length - 1; i >= 0; i--) { GS.bossWarnings[i].life--; if (GS.bossWarnings[i].life <= 0) GS.bossWarnings.splice(i, 1); }
    }

    // ============================================================
    // PLAYER UPDATE
    // ============================================================
    function updPlayer() {
      const p = GS.p; if (GS.dlgActive) return;
      if (GS.timeStop && GS.timeStopTimer > 0) {
        // Slowed movement during time stop
        let mx = 0, my = 0;
        if (K['ArrowLeft'] || K['KeyA']) mx = -1; if (K['ArrowRight'] || K['KeyD']) mx = 1;
        if (K['ArrowUp'] || K['KeyW']) my = -1; if (K['ArrowDown'] || K['KeyS']) my = 1;
        if (p.vx !== 0 || p.vy !== 0) { mx = p.vx; my = p.vy; }
        if (mx !== 0 || my !== 0) { const mg = Math.sqrt(mx * mx + my * my); mx /= mg; my /= mg; }
        const { map } = GS.map; const slow = 0.4;
        let nx = p.x + mx * p.spd * slow, ny = p.y + my * p.spd * slow;
        if (!blk(nx, p.y, map)) p.x = nx; if (!blk(p.x, ny, map)) p.y = ny;
        GS.cam.x = lerp(GS.cam.x, p.x - canvas.width / 2, 0.1); GS.cam.y = lerp(GS.cam.y, p.y - canvas.height / 2, 0.1);
        GS.cam.x = Math.max(0, Math.min(WW - canvas.width, GS.cam.x)); GS.cam.y = Math.max(0, Math.min(WH - canvas.height, GS.cam.y));
        for (let i = 0; i < 4; i++)if (p.atkCDs[i] > 0) p.atkCDs[i]--;
        if (p.inv > 0) p.inv--;
        if (p.dashCD > 0) { p.dashCD--; updDashBtn(); }
        if (p.invincible) { p.invincibleTimer--; if (p.invincibleTimer <= 0) { p.invincible = false; updDashBtn(); } }
        return;
      }
      for (let i = 0; i < 4; i++)if (p.atkCDs[i] > 0) p.atkCDs[i]--;
      if (p.atkAnim > 0) p.atkAnim--; if (p.inv > 0) p.inv--;
      // Dash cooldown
      if (p.dashCD > 0) { p.dashCD--; updDashBtn(); }
      // Invincibilit√©
      if (p.invincible) {
        p.invincibleTimer--;
        if (p.invincibleTimer <= 0) { p.invincible = false; updDashBtn(); }
      }
      if (p.charging) { p.chargeTime++; if (p.chargeTime > 90) p.chargeTime = 90; }
      let mx = 0, my = 0;
      if (K['ArrowLeft'] || K['KeyA']) mx = -1; if (K['ArrowRight'] || K['KeyD']) mx = 1;
      if (K['ArrowUp'] || K['KeyW']) my = -1; if (K['ArrowDown'] || K['KeyS']) my = 1;
      if (p.vx !== 0 || p.vy !== 0) { mx = p.vx; my = p.vy; }
      if (mx !== 0 || my !== 0) { const mg = Math.sqrt(mx * mx + my * my); mx /= mg; my /= mg; p.fx = mx; p.fy = my; if (GS.frame % 8 === 0) sWalk(); }
      const { map } = GS.map;
      let nx = p.x + mx * p.spd, ny = p.y + my * p.spd;
      if (!blk(nx, p.y, map)) p.x = nx; if (!blk(p.x, ny, map)) p.y = ny;
      p.x = Math.max(TSIZ, Math.min(WW - TSIZ, p.x)); p.y = Math.max(TSIZ, Math.min(WH - TSIZ, p.y));
      if (LEVELS[curLvl].questType === 'collect') {
        const lv = LEVELS[curLvl];
        for (let i = 0; i < GS.qItems.length; i++) {
          const qi = GS.qItems[i];
          if (!qi.collected && dst(p, qi) < 38) {
            qi.collected = true; p.qItems++; sPick(); updHUD();
            const mi = Math.min(i, lv.questMsgs.length - 1); const msg = lv.questMsgs[mi];
            openDlg(msg[0], msg[1], msg.slice(2), null);
            if (p.qItems >= lv.questCount && !GS.bossSpawned) spawnBoss();
          }
        }
      }
      GS.cam.x = lerp(GS.cam.x, p.x - canvas.width / 2, 0.11); GS.cam.y = lerp(GS.cam.y, p.y - canvas.height / 2, 0.11);
      GS.cam.x = Math.max(0, Math.min(WW - canvas.width, GS.cam.x)); GS.cam.y = Math.max(0, Math.min(WH - canvas.height, GS.cam.y));
    }

    // ============================================================
    // RENDER MAP
    // ============================================================
    function renderMap() {
      const { cam, map: { map } } = GS;
      const sc = Math.max(0, Math.floor(cam.x / TSIZ) - 1), ec = Math.min(COLS - 1, Math.ceil((cam.x + canvas.width) / TSIZ) + 1);
      const sr = Math.max(0, Math.floor(cam.y / TSIZ) - 1), er = Math.min(ROWS - 1, Math.ceil((cam.y + canvas.height) / TSIZ) + 1);
      for (let r = sr; r <= er; r++)for (let c = sc; c <= ec; c++) {
        const px = Math.round(c * TSIZ - cam.x), py = Math.round(r * TSIZ - cam.y);
        C.drawImage(buildTile(map[r][c], tileFrame), px, py, TSIZ, TSIZ);
      }
    }

    // ============================================================
    // AMBIENT + DECOS ‚Äî pixel art par biome
    // ============================================================

    // ‚îÄ‚îÄ‚îÄ Particules ambiantes pixel art ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawAmbientParticle(ctx, sx, sy, type, sz, alpha) {
      ctx.save(); ctx.globalAlpha = alpha;
      const f = GS.frame;
      if (type === 'firefly') {
        // Luciole for√™t ‚Äî petit carr√© jaune-vert pulsant
        const p = (Math.sin(f * 0.18) + 1) / 2;
        ctx.fillStyle = `rgba(200,255,80,${0.6 + 0.4 * p})`;
        ctx.shadowColor = '#aaff44'; ctx.shadowBlur = 6 + p * 6;
        ctx.fillRect(sx - sz * 0.4, sy - sz * 0.4, sz * 0.8, sz * 0.8);
        // Trail
        ctx.shadowBlur = 0; ctx.globalAlpha *= 0.3;
        ctx.fillRect(sx - sz * 0.3, sy + sz * 0.3, sz * 0.5, sz * 0.3);
      } else if (type === 'leaf_fall') {
        // Feuille qui tombe ‚Äî losange vert pivotant
        const rot = f * 0.04;
        ctx.translate(sx, sy); ctx.rotate(rot);
        ctx.fillStyle = `rgba(${60 + Math.floor(Math.random() * 20)},160,60,0.8)`;
        ctx.fillRect(-sz * 0.4, -sz * 0.15, sz * 0.8, sz * 0.3);
        ctx.fillRect(-sz * 0.15, -sz * 0.4, sz * 0.3, sz * 0.8);
      } else if (type === 'spark') {
        // √âtincelle ch√¢teau ‚Äî pixel blanc-bleu
        ctx.fillStyle = '#aabbff';
        ctx.shadowColor = '#6688ff'; ctx.shadowBlur = 8;
        ctx.fillRect(sx - 1, sy - 1, 2, 2);
        // croisillon
        ctx.fillRect(sx - 3, sy, 6, 1); ctx.fillRect(sx, sy - 3, 1, 6);
      } else if (type === 'candle') {
        // Flamme chandelle ch√¢teau
        const flicker = Math.sin(f * 0.3 + sz) * 2;
        ctx.fillStyle = '#ffaa00'; ctx.fillRect(sx - 2, sy - 4 + flicker, 4, 6);
        ctx.fillStyle = '#ffee44'; ctx.fillRect(sx - 1, sy - 6 + flicker, 2, 4);
        ctx.fillStyle = 'rgba(255,150,0,0.3)'; ctx.fillRect(sx - 4, sy - 4 + flicker, 8, 8);
      } else if (type === 'snowflake') {
        // Flocon montagne
        ctx.strokeStyle = `rgba(200,230,255,0.8)`; ctx.lineWidth = 1;
        for (let a = 0; a < Math.PI * 2; a += Math.PI / 3) {
          ctx.beginPath();
          ctx.moveTo(sx, sy);
          ctx.lineTo(sx + Math.cos(a) * sz * 0.6, sy + Math.sin(a) * sz * 0.6);
          ctx.stroke();
        }
        ctx.fillStyle = 'rgba(220,240,255,0.9)'; ctx.fillRect(sx - 1, sy - 1, 2, 2);
      } else if (type === 'ice_crystal') {
        // Cristal de glace flottant
        ctx.fillStyle = `rgba(140,200,255,${0.4 + 0.3 * Math.sin(f * 0.07)})`;
        ctx.save(); ctx.translate(sx, sy); ctx.rotate(f * 0.02);
        ctx.fillRect(-sz * 0.5, -1, sz, 2); ctx.fillRect(-1, -sz * 0.5, 2, sz);
        ctx.restore();
      }
      ctx.restore();
    }

    function renderAmbient() {
      const { cam, ambient } = GS;
      const biome = LEVELS[curLvl].biome;
      for (const p of ambient) {
        p.y -= p.spd * 0.3; if (p.y < 0) p.y = WH;
        p.x += Math.sin(GS.frame * 0.01 + p.off) * 0.3;
        const sx = p.x - cam.x, sy = p.y - cam.y;
        if (sx < -30 || sx > canvas.width + 30 || sy < -30 || sy > canvas.height + 30) continue;
        const a = p.alpha * (0.5 + 0.5 * Math.sin(GS.frame * 0.03 + p.off));
        // Choisir le type selon le biome et l'index
        const types = biome === 'forest'
          ? ['firefly', 'leaf_fall']
          : biome === 'castle'
            ? ['spark', 'candle']
            : ['snowflake', 'ice_crystal'];
        const type = types[Math.floor(p.off * 100) % 2];
        drawAmbientParticle(C, sx, sy, type, p.sz, a);
      }
    }

    // ‚îÄ‚îÄ‚îÄ D√©cors pixel art par biome ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawDecoForest(ctx, sx, sy, bob, scale) {
      const s = Math.max(1, Math.round(scale * TSIZ * 0.75 / 16));
      const t = GS.frame;
      const variant = Math.floor((sx * 7 + sy * 13) % 5);
      if (variant === 0) {
        // Champignon
        ctx.fillStyle = '#cc3333'; ctx.beginPath(); ctx.arc(sx, sy - s * 3 + bob, s * 3, Math.PI, 0); ctx.fill();
        ctx.fillStyle = '#ff6666'; ctx.fillRect(sx - s, sy - s * 3 + bob, s, s); ctx.fillRect(sx + s, sy - s * 4 + bob, s, s);
        ctx.fillStyle = '#e8d0b0'; ctx.fillRect(sx - s, sy - s * 3 + bob, s * 2, s * 4);
        ctx.fillStyle = '#c0a888'; ctx.fillRect(sx - s * 2, sy + bob, s * 4, s);
      } else if (variant === 1) {
        // Fleur rose
        for (let i = 0; i < 5; i++) {
          const a = (i / 5) * Math.PI * 2 + t * 0.01;
          ctx.fillStyle = i % 2 === 0 ? '#ff88aa' : '#ffaabb';
          ctx.fillRect(sx + Math.cos(a) * s * 2 - s, sy - s * 3 + Math.sin(a) * s * 2 + bob, s * 2, s * 2);
        }
        ctx.fillStyle = '#ffee44'; ctx.fillRect(sx - s, sy - s * 3 - s + bob, s * 2, s * 2);
        ctx.fillStyle = '#2a8040'; ctx.fillRect(sx, sy - s * 2 + bob, s, s * 3);
      } else if (variant === 2) {
        // Rocher moussu
        ctx.fillStyle = '#5a5a4a'; ctx.fillRect(sx - s * 3, sy - s * 2 + bob, s * 6, s * 3);
        ctx.fillStyle = '#6a6a58'; ctx.fillRect(sx - s * 2, sy - s * 3 + bob, s * 4, s);
        ctx.fillStyle = '#2a8040'; ctx.fillRect(sx - s * 3, sy - s * 3 + bob, s * 3, s);
        ctx.fillRect(sx + s, sy - s * 4 + bob, s * 2, s);
        ctx.fillStyle = 'rgba(255,255,255,0.18)'; ctx.fillRect(sx - s * 2, sy - s * 3 + bob, s * 2, s);
      } else if (variant === 3) {
        // Petit arbre touffu
        ctx.fillStyle = '#4a2e10'; ctx.fillRect(sx - s, sy + bob, s * 2, s * 4);
        ctx.fillStyle = '#1a5010'; ctx.fillRect(sx - s * 4, sy - s * 5 + bob, s * 8, s * 6);
        ctx.fillStyle = '#2a7020'; ctx.fillRect(sx - s * 3, sy - s * 7 + bob, s * 6, s * 4);
        ctx.fillStyle = '#3a9030'; ctx.fillRect(sx - s * 2, sy - s * 8 + bob, s * 4, s * 3);
        ctx.fillStyle = '#1a4010'; ctx.fillRect(sx - s * 2, sy - s * 4 + bob, s * 4, s);
      } else {
        // Buisson baies
        ctx.fillStyle = '#1a5010'; ctx.fillRect(sx - s * 3, sy - s * 3 + bob, s * 6, s * 4);
        ctx.fillStyle = '#2a7020'; ctx.fillRect(sx - s * 2, sy - s * 4 + bob, s * 4, s * 2);
        // Baies rouges
        for (let i = 0; i < 4; i++) {
          ctx.fillStyle = '#cc2222';
          ctx.beginPath(); ctx.arc(sx - s * 2 + i * s * 1.3, sy - s * 2 + bob, s * 0.8, 0, Math.PI * 2); ctx.fill();
        }
      }
    }

    function drawDecoCastle(ctx, sx, sy, bob, scale) {
      const s = Math.max(1, Math.round(scale * TSIZ * 0.75 / 16));
      const t = GS.frame;
      const variant = Math.floor((sx * 11 + sy * 7) % 5);
      if (variant === 0) {
        // Chandelier mural
        ctx.fillStyle = '#888'; ctx.fillRect(sx - s * 2, sy - s * 6 + bob, s * 4, s);
        ctx.fillStyle = '#c8a020'; ctx.fillRect(sx - s * 2, sy - s * 6 + bob, s * 4, s * 2);
        // 3 bougies
        for (let i = 0; i < 3; i++) {
          const cx = sx - s * 2 + i * s * 2;
          ctx.fillStyle = '#f0d080'; ctx.fillRect(cx - s * 0.5, sy - s * 4 + bob, s, s * 3);
          const flicker = Math.sin(t * 0.3 + i) * 1;
          ctx.fillStyle = '#ffaa00'; ctx.fillRect(cx - s * 0.5, sy - s * 5 + bob + flicker, s, s * 1.5);
          ctx.fillStyle = '#ffee44'; ctx.fillRect(cx - s * 0.3, sy - s * 6 + bob + flicker, s * 0.6, s);
          ctx.fillStyle = `rgba(255,160,0,${0.2 + 0.1 * Math.sin(t * 0.3 + i)})`;
          ctx.beginPath(); ctx.arc(cx, sy - s * 5 + bob + flicker, s * 2, 0, Math.PI * 2); ctx.fill();
        }
      } else if (variant === 1) {
        // Cr√¢ne d√©coratif
        ctx.fillStyle = '#c8c0a8';
        ctx.fillRect(sx - s * 2, sy - s * 4 + bob, s * 4, s * 4);
        ctx.fillRect(sx - s * 3, sy - s * 2 + bob, s * 6, s * 2);
        ctx.fillStyle = '#000'; ctx.fillRect(sx - s * 2, sy - s * 3 + bob, s, s * 2); ctx.fillRect(sx + s, sy - s * 3 + bob, s, s * 2);
        ctx.fillStyle = '#c8c0a8'; ctx.fillRect(sx - s * 2, sy + bob, s, s * 2); ctx.fillRect(sx, sy + bob, s, s * 2); ctx.fillRect(sx + s * 2, sy + bob, s, s * 2);
        ctx.fillStyle = '#aaa'; ctx.fillRect(sx - s * 2, sy - s * 5 + bob, s, s * 2); ctx.fillRect(sx + s, sy - s * 5 + bob, s, s * 2);
      } else if (variant === 2) {
        // Coffre
        ctx.fillStyle = '#6a4010'; ctx.fillRect(sx - s * 3, sy - s * 2 + bob, s * 6, s * 4);
        ctx.fillStyle = '#c8a020'; ctx.fillRect(sx - s * 3, sy - s * 2 + bob, s * 6, s);
        ctx.fillRect(sx - s * 3, sy - s * 2 + bob, s, s * 4);
        ctx.fillRect(sx + s * 2, sy - s * 2 + bob, s, s * 4);
        ctx.fillRect(sx - s * 3, sy + s + bob, s * 6, s);
        ctx.fillStyle = '#ffd700'; ctx.fillRect(sx - s, sy - s + bob, s * 2, s * 2);
        ctx.fillStyle = '#ffee88'; ctx.fillRect(sx - s * 0.5, sy - s * 0.5 + bob, s, s);
      } else if (variant === 3) {
        // Torche murale
        ctx.fillStyle = '#6a4010'; ctx.fillRect(sx - s, sy - s * 6 + bob, s * 2, s * 5);
        ctx.fillStyle = '#888'; ctx.fillRect(sx - s * 2, sy - s * 8 + bob, s * 4, s * 2);
        const fl = Math.sin(t * 0.25) * 1.5;
        ctx.fillStyle = '#ff6600'; ctx.fillRect(sx - s, sy - s * 10 + bob + fl, s * 2, s * 3);
        ctx.fillStyle = '#ffaa00'; ctx.fillRect(sx - s * 0.5, sy - s * 12 + bob + fl, s, s * 3);
        ctx.fillStyle = '#ffee44'; ctx.fillRect(sx - s * 0.3, sy - s * 13 + bob + fl, s * 0.6, s * 2);
        ctx.fillStyle = `rgba(255,120,0,${0.2 + 0.1 * Math.abs(fl)})`;
        ctx.beginPath(); ctx.arc(sx, sy - s * 10 + bob + fl, s * 3, 0, Math.PI * 2); ctx.fill();
      } else {
        // Banni√®re royale
        ctx.fillStyle = '#333'; ctx.fillRect(sx - s * 0.5, sy - s * 8 + bob, s, s * 8);
        ctx.fillStyle = '#8800aa'; ctx.fillRect(sx, sy - s * 7 + bob, s * 4, s * 5);
        ctx.fillStyle = '#aa00cc'; ctx.fillRect(sx + s, sy - s * 6 + bob, s * 2, s * 3);
        ctx.fillStyle = '#ffd700'; ctx.fillRect(sx + s, sy - s * 5 + bob, s * 2, s);
        // Bas frang√©
        for (let i = 0; i < 4; i++) { ctx.fillStyle = '#6600aa'; ctx.fillRect(sx + i * s, sy - s * 2 + bob, s * 0.6, s * 2); }
      }
    }

    function drawDecoMountain(ctx, sx, sy, bob, scale) {
      const s = Math.max(1, Math.round(scale * TSIZ * 0.75 / 16));
      const t = GS.frame;
      const variant = Math.floor((sx * 9 + sy * 17) % 5);
      if (variant === 0) {
        // Cristal de glace
        ctx.fillStyle = '#88ccff'; ctx.fillRect(sx - s, sy - s * 6 + bob, s * 2, s * 6);
        ctx.fillStyle = '#aaddff'; ctx.fillRect(sx - s * 2, sy - s * 4 + bob, s * 4, s * 2);
        // Pointe
        ctx.fillStyle = '#cceeFF';
        ctx.beginPath(); ctx.moveTo(sx, sy - s * 7 + bob); ctx.lineTo(sx - s, sy - s * 6 + bob); ctx.lineTo(sx + s, sy - s * 6 + bob); ctx.closePath(); ctx.fill();
        // Reflet
        const glow = ctx.createLinearGradient(sx, sy - s * 7 + bob, sx, sy + bob);
        glow.addColorStop(0, 'rgba(200,240,255,0.6)'); glow.addColorStop(1, 'rgba(100,180,255,0.1)');
        ctx.fillStyle = glow; ctx.fillRect(sx - s * 2, sy - s * 6 + bob, s, s * 6);
      } else if (variant === 1) {
        // Cairn (empilement de pierres)
        const sizes = [4, 3, 2.5, 1.5];
        for (let i = 0; i < sizes.length; i++) {
          const w = sizes[i] * s; const y = sy + bob - i * s * 2;
          ctx.fillStyle = i % 2 === 0 ? '#7a7a8a' : '#8a8a9a';
          ctx.fillRect(sx - w, y - s * 2, w * 2, s * 2);
          ctx.fillStyle = 'rgba(255,255,255,0.12)'; ctx.fillRect(sx - w, y - s * 2, w * 2, s * 0.5);
        }
      } else if (variant === 2) {
        // Stalactite / stalagmite
        ctx.fillStyle = '#9090a0';
        // stalagmite bas
        ctx.beginPath(); ctx.moveTo(sx - s * 2, sy + bob); ctx.lineTo(sx, sy - s * 5 + bob); ctx.lineTo(sx + s * 2, sy + bob); ctx.closePath(); ctx.fill();
        ctx.fillStyle = '#b0b0c0'; ctx.beginPath(); ctx.moveTo(sx - s, sy + bob); ctx.lineTo(sx, sy - s * 4 + bob); ctx.lineTo(sx + s, sy + bob); ctx.closePath(); ctx.fill();
        ctx.fillStyle = 'rgba(200,220,255,0.3)'; ctx.fillRect(sx - s * 0.5, sy - s * 4 + bob, s * 0.5, s * 4);
      } else if (variant === 3) {
        // Ruines enneig√©es
        ctx.fillStyle = '#6a6a7a'; ctx.fillRect(sx - s * 3, sy + bob, s * 6, s * 2);
        ctx.fillRect(sx - s * 3, sy - s * 5 + bob, s * 2, s * 5);
        ctx.fillRect(sx + s, sy - s * 4 + bob, s * 2, s * 4);
        // Neige sur le dessus
        ctx.fillStyle = '#e8f4ff'; ctx.fillRect(sx - s * 3, sy - s * 5 + bob, s * 6, s);
        ctx.fillRect(sx - s * 3, sy + bob, s * 6, s * 0.5);
        ctx.fillStyle = '#ffffff'; ctx.fillRect(sx - s * 3, sy - s * 5 + bob, s * 2, s * 0.5);
        ctx.fillRect(sx + s, sy - s * 4 + bob, s * 2, s * 0.5);
      } else {
        // Ossements anciens
        ctx.fillStyle = '#d4ccb0';
        // cr√¢ne
        ctx.fillRect(sx - s * 2, sy - s * 4 + bob, s * 4, s * 3);
        ctx.fillRect(sx - s * 3, sy - s * 2 + bob, s * 6, s);
        ctx.fillStyle = '#000'; ctx.fillRect(sx - s * 2, sy - s * 3 + bob, s, s); ctx.fillRect(sx + s, sy - s * 3 + bob, s, s);
        // Os crois√©s
        ctx.fillStyle = '#c8c0a8';
        ctx.save(); ctx.translate(sx, sy + s * 2 + bob); ctx.rotate(0.4);
        ctx.fillRect(-s * 4, -s * 0.5, s * 8, s); ctx.restore();
        ctx.save(); ctx.translate(sx, sy + s * 2 + bob); ctx.rotate(-0.4);
        ctx.fillRect(-s * 4, -s * 0.5, s * 8, s); ctx.restore();
      }
    }

    function renderDecos() {
      const { cam, decos } = GS;
      const biome = LEVELS[curLvl].biome;
      for (const d of decos) {
        const sx = d.x - cam.x, sy = d.y - cam.y;
        if (sx < -TSIZ * 3 || sx > canvas.width + TSIZ * 3 || sy < -TSIZ * 3 || sy > canvas.height + TSIZ * 3) continue;
        const bob = Math.sin(GS.frame * 0.022 + d.off) * 1.5;
        C.save(); C.globalAlpha = 0.85;
        if (biome === 'forest') drawDecoForest(C, sx, sy, bob, d.scale);
        else if (biome === 'castle') drawDecoCastle(C, sx, sy, bob, d.scale);
        else drawDecoMountain(C, sx, sy, bob, d.scale);
        C.restore();
      }
    }

    // ============================================================
    // QUEST ITEMS
    // ============================================================
    function renderQItems() {
      const { cam, qItems } = GS; const lv = LEVELS[curLvl];
      C.textAlign = 'center'; C.textBaseline = 'middle';
      for (const qi of qItems) {
        if (qi.collected) continue;
        const sx = qi.x - cam.x, sy = qi.y - cam.y;
        if (Math.abs(sx) > canvas.width / 2 + 80 || Math.abs(sy) > canvas.height / 2 + 80) continue;
        const bob = Math.sin(GS.frame * 0.07 + qi.x) * 6;
        const ag = C.createRadialGradient(sx, sy + bob, 0, sx, sy + bob, 30);
        ag.addColorStop(0, 'rgba(255,215,0,0.4)'); ag.addColorStop(1, 'transparent');
        C.fillStyle = ag; C.beginPath(); C.arc(sx, sy + bob, 30, 0, Math.PI * 2); C.fill();
        C.save(); C.shadowColor = '#ffd700'; C.shadowBlur = 22;
        // Dessin pixel art selon le type d'objet de qu√™te
        const qi2 = lv.questItem;
        if (qi2 === 'ü•á') {
          // M√©daillon dor√©
          C.fillStyle = '#ffd700'; C.beginPath(); C.arc(sx, sy + bob, 10, 0, Math.PI * 2); C.fill();
          C.fillStyle = '#cc8800'; C.beginPath(); C.arc(sx, sy + bob, 10, 0, Math.PI * 2); C.stroke();
          C.strokeStyle = '#cc8800'; C.lineWidth = 2; C.stroke();
          C.fillStyle = '#ffee88'; C.fillRect(sx - 3, sy + bob - 4, 6, 8);
          C.fillStyle = '#cc8800'; C.fillRect(sx - 1, sy + bob - 6, 2, 3);
          C.fillStyle = '#ffee88'; C.fillRect(sx - 1, sy + bob - 1, 2, 2);
        } else if (qi2 === 'üíÄ') {
          // Cr√¢ne (pour les kills)
          C.fillStyle = '#e8e0c8';
          C.fillRect(sx - 7, sy + bob - 8, 14, 12);
          C.fillRect(sx - 5, sy + bob - 10, 10, 5);
          C.fillStyle = '#000'; C.fillRect(sx - 5, sy + bob - 8, 4, 4); C.fillRect(sx + 1, sy + bob - 8, 4, 4);
          C.fillStyle = '#e8e0c8'; C.fillRect(sx - 4, sy + bob + 3, 2, 3); C.fillRect(sx - 1, sy + bob + 3, 2, 3); C.fillRect(sx + 2, sy + bob + 3, 2, 3);
        } else if (qi2 === '‚≠ê') {
          // √âtoile or 5 branches
          C.fillStyle = '#ffd700';
          const starR = 12, starr = 5;
          C.beginPath();
          for (let i = 0; i < 10; i++) {
            const r2 = i % 2 === 0 ? starR : starr;
            const a = (i / 10) * Math.PI * 2 - Math.PI / 2;
            if (i === 0) C.moveTo(sx + Math.cos(a) * r2, sy + bob + Math.sin(a) * r2);
            else C.lineTo(sx + Math.cos(a) * r2, sy + bob + Math.sin(a) * r2);
          }
          C.closePath(); C.fill();
          C.fillStyle = '#ffe066'; C.fillRect(sx - 2, sy + bob - 4, 4, 4);
        } else {
          // Fallback g√©n√©rique : diamant brillant
          C.fillStyle = '#aaddff';
          C.beginPath(); C.moveTo(sx, sy + bob - 10); C.lineTo(sx + 8, sy + bob); C.lineTo(sx, sy + bob + 10); C.lineTo(sx - 8, sy + bob); C.closePath(); C.fill();
          C.fillStyle = '#fff'; C.fillRect(sx - 2, sy + bob - 5, 3, 3);
        }
        C.restore();
      }
    }

    // ============================================================
    // BOSS WARNINGS RENDER
    // ============================================================
    function renderBossWarnings() {
      const { cam } = GS;
      for (const w of GS.bossWarnings) {
        const sx = w.x - cam.x, sy = w.y - cam.y;
        const alpha = (w.life / w.maxLife) * 0.75;
        const pulse = Math.sin(GS.frame * 0.4) * 0.3;
        C.save();
        if (w.type === 'slam_zone') {
          // Aerial slam danger zone ‚Äî filled red circle + concentric rings
          const a = Math.max(0, alpha * 0.55 + pulse * 0.2);
          const rg = C.createRadialGradient(sx, sy, 0, sx, sy, w.r);
          rg.addColorStop(0, `rgba(255,60,0,${a * 0.6})`); rg.addColorStop(0.7, `rgba(255,20,0,${a * 0.3})`); rg.addColorStop(1, 'transparent');
          C.fillStyle = rg; C.beginPath(); C.arc(sx, sy, w.r, 0, Math.PI * 2); C.fill();
          C.strokeStyle = w.color; C.lineWidth = 4; C.globalAlpha = a + 0.2;
          C.shadowColor = '#ff0000'; C.shadowBlur = 18;
          C.setLineDash([8, 4]); C.beginPath(); C.arc(sx, sy, w.r, 0, Math.PI * 2); C.stroke();
          C.setLineDash([]);
          // Inner target cross
          C.strokeStyle = `rgba(255,200,0,${a + 0.1})`; C.lineWidth = 2; C.shadowBlur = 10;
          C.beginPath(); C.moveTo(sx - 16, sy); C.lineTo(sx + 16, sy); C.stroke();
          C.beginPath(); C.moveTo(sx, sy - 16); C.lineTo(sx, sy + 16); C.stroke();
        } else if (w.type === 'warn_zone') {
          // Boss 2 approach warning ‚Äî pulsing orange ring
          C.strokeStyle = w.color; C.lineWidth = 4; C.globalAlpha = (alpha + pulse) * 0.8;
          C.shadowColor = w.color; C.shadowBlur = 20;
          C.setLineDash([12, 8]);
          C.beginPath(); C.arc(sx, sy, w.r, 0, Math.PI * 2); C.stroke();
          C.setLineDash([]);
          // "DANGER" text pulsing
          if (Math.floor(GS.frame / 6) % 2 === 0) {
            C.globalAlpha = 0.9; C.fillStyle = '#ff8800'; C.shadowBlur = 12;
            C.font = '7px "Press Start 2P"'; C.textAlign = 'center'; C.textBaseline = 'middle';
            C.fillText('‚ö† DANGER ‚ö†', sx, sy - w.r - 12);
          }
        } else if (w.type === 'beam_warn') {
          // Directional warning ‚Äî shows beam trajectory before it fires
          const blink = Math.floor(GS.frame / 5) % 2 === 0;
          if (blink) {
            C.globalAlpha = (alpha + pulse) * 0.7;
            C.strokeStyle = '#ff2200'; C.lineWidth = 6; C.shadowColor = '#ff0000'; C.shadowBlur = 20;
            C.setLineDash([14, 8]);
            C.beginPath(); C.moveTo(sx, sy);
            C.lineTo(sx + Math.cos(w.angle) * w.r, sy + Math.sin(w.angle) * w.r);
            C.stroke(); C.setLineDash([]);
            // "LASER" label
            C.font = '7px "Press Start 2P"'; C.fillStyle = '#ff4400'; C.textAlign = 'center'; C.textBaseline = 'middle';
            C.fillText('‚ö° LASER ‚ö°', sx + Math.cos(w.angle) * w.r * 0.5, sy + Math.sin(w.angle) * w.r * 0.5 - 14);
          }
        } else if (w.type === 'circle') {
          C.strokeStyle = w.color; C.lineWidth = 3; C.globalAlpha = alpha + pulse;
          C.shadowColor = w.color; C.shadowBlur = 12;
          C.setLineDash([6, 4]);
          C.beginPath(); C.arc(sx, sy, w.r, 0, Math.PI * 2); C.stroke();
          C.setLineDash([]);
        } else {
          C.strokeStyle = w.color; C.lineWidth = 2; C.globalAlpha = alpha + pulse;
          C.shadowColor = w.color; C.shadowBlur = 10;
          C.beginPath(); C.arc(sx, sy, w.r, 0, Math.PI * 2); C.stroke();
        }
        C.restore();
      }
    }

    // ============================================================
    // BOSS BEAM RENDER
    // ============================================================
    function renderBossBeam() {
      const { boss, cam } = GS; if (!boss || !boss.beamActive || boss.beamTimer <= 0) return;
      const sx = boss.x - cam.x, sy = boss.y - cam.y;
      const len = 500;
      const ex = sx + Math.cos(boss.beamAngle) * len, ey = sy + Math.sin(boss.beamAngle) * len;
      const alpha = Math.min(1, boss.beamTimer / 15);
      C.save();
      // Outer glow
      C.globalAlpha = alpha * 0.25; C.strokeStyle = '#ff4400'; C.lineWidth = 28; C.shadowColor = '#ff4400'; C.shadowBlur = 30;
      C.beginPath(); C.moveTo(sx, sy); C.lineTo(ex, ey); C.stroke();
      // Core
      C.globalAlpha = alpha * 0.9; C.strokeStyle = '#fff'; C.lineWidth = 4; C.shadowBlur = 15;
      C.beginPath(); C.moveTo(sx, sy); C.lineTo(ex, ey); C.stroke();
      C.restore();
    }

    // ============================================================
    // MONSTERS RENDER
    // ============================================================
    function renderMons() {
      const { cam, mons, boss } = GS; const all = [...mons]; if (boss) all.push(boss);
      for (const m of all) {
        if (m.state === 'dead') continue;
        const sx = m.x - cam.x, sy = m.y - cam.y;
        if (sx < -140 || sx > canvas.width + 140 || sy < -140 || sy > canvas.height + 140) continue;
        const dying = m.state === 'dying';
        const alpha = dying ? Math.max(0, m.dyingTimer / 22) : 1;
        const bob = dying ? 0 : Math.sin(GS.frame * 0.07 + m.x * 0.01) * 2;

        C.save();
        C.globalAlpha = alpha;
        if (m.hitFlash > 0) C.filter = 'brightness(3.5) saturate(0)';

        const frame = getMonFrame(m);
        const dir = getMonDir(m);

        if (m.boss) {
          // ‚îÄ‚îÄ BOSS ‚îÄ‚îÄ
          const aerialOff = m.aerialYOff || 0;
          const lvlType = getBossType(curLvl);

          if (m.boss && aerialOff < -10) {
            // ombre au sol pendant le vol
            C.save();
            C.globalAlpha *= (0.15 + 0.3 * (1 - Math.abs(aerialOff) / 80));
            C.filter = 'blur(6px) brightness(0)';
            C.translate(sx + 5, sy + 8 + bob);
            C.scale(1, 0.3);
            if (lvlType === 'demon') drawDemon(C, 0, 0, dir, frame, 2.8, 1, m.rageMode);
            else if (lvlType === 'king') drawKingDoubt(C, 0, 0, dir, frame, 2.8, 1, m.rageMode);
            else drawDragon(C, 0, 0, dir, frame, 3.0, 1, m.rageMode, 0);
            C.restore();
          }

          if (lvlType === 'demon') drawDemon(C, sx, sy + bob + aerialOff, dir, frame, 2.8, 1, m.rageMode);
          else if (lvlType === 'king') drawKingDoubt(C, sx, sy + bob + aerialOff, dir, frame, 2.8, 1, m.rageMode);
          else drawDragon(C, sx, sy + bob, dir, frame, 3.0, 1, m.rageMode, aerialOff);

          // Aura boss
          C.save(); C.globalAlpha = alpha * (m.rageMode ? 0.35 : 0.18);
          const rageT = m.rageMode ? 0.22 : 0;
          const bg = C.createRadialGradient(sx, sy, 5, sx, sy, 70);
          bg.addColorStop(0, `rgba(255,${m.rageMode ? 30 : 80},50,${0.18 + rageT})`);
          bg.addColorStop(1, 'transparent');
          C.fillStyle = bg; C.beginPath(); C.arc(sx, sy, 70, 0, Math.PI * 2); C.fill();
          C.restore();

          if (m.rageMode) {
            C.save(); C.globalAlpha = alpha * 0.6; C.strokeStyle = '#ff2200'; C.lineWidth = 3;
            C.shadowColor = '#ff2200'; C.shadowBlur = 18;
            C.beginPath(); C.arc(sx, sy, 60 + Math.sin(GS.frame * 0.2) * 5, 0, Math.PI * 2); C.stroke();
            C.restore();
          }

        } else {
          // ‚îÄ‚îÄ MONSTRES NORMAUX ‚îÄ‚îÄ
          const type = getMonsterType(m);
          if (type === 'wolf') drawWolf(C, sx, sy + bob, dir, frame, 1.8, 1);
          else if (type === 'bat') drawBat(C, sx, sy + bob, frame % 2, 1.5, 1);
          else if (type === 'spider') drawSpider(C, sx, sy + bob, frame % 2, 1.5, 1);
          else if (type === 'leaf') drawLeafMonster(C, sx, sy + bob, frame % 2, 1.7, 1);
          else if (type === 'skeleton') drawSkeleton(C, sx, sy + bob, dir, frame, 1.8, 1);
          else if (type === 'zombie') drawZombie(C, sx, sy + bob, dir, frame, 1.8, 1);
          else if (type === 'ghost') drawGhost(C, sx, sy + bob, frame % 2, 1.7, 1);
          else if (type === 'knight') drawKnight(C, sx, sy + bob, dir, frame, 1.8, 1);
          else if (type === 'iceGiant') drawIceGiant(C, sx, sy + bob, dir, frame, 2.0, 1);
          else if (type === 'griffon') drawGriffon(C, sx, sy + bob, dir, frame, 1.7, 1);
          else if (type === 'golem') drawGolem(C, sx, sy + bob, dir, frame, 2.0, 1);
          else if (type === 'elemental') drawElemental(C, sx, sy + bob, frame % 2, 1.7, 1);
          else {
            // fallback absolu (ne devrait pas arriver)
            C.textAlign = 'center'; C.textBaseline = 'middle';
            C.font = '20px serif'; C.fillStyle = '#fff'; C.fillText('?', sx, sy + bob);
          }
        }

        C.restore();

        // HP bar
        if (!dying && m.hp < m.maxHp) {
          const bw = m.boss ? 72 : 38, bh = m.boss ? 9 : 5;
          const bx = sx - bw / 2, by = sy - (m.boss ? 55 : 28);
          C.fillStyle = 'rgba(0,0,0,0.8)'; C.fillRect(bx - 1, by - 1, bw + 2, bh + 2);
          C.fillStyle = '#2a0000'; C.fillRect(bx, by, bw, bh);
          const pct = m.hp / m.maxHp;
          C.fillStyle = pct > 0.6 ? '#44ff44' : pct > 0.3 ? '#ffaa00' : '#ff2222';
          C.fillRect(bx, by, bw * pct, bh);
          C.fillStyle = 'rgba(255,255,255,0.18)'; C.fillRect(bx, by, bw * pct, bh / 2);
          if (m.boss) {
            C.save(); C.font = '6px "Press Start 2P"';
            C.fillStyle = m.rageMode ? '#ff4444' : '#ff8888';
            C.textAlign = 'center';
            C.fillText(m.name + (m.rageMode ? ' ‚ö°RAGE' : m.phase > 0 ? ` P${m.phase + 1}` : ''), sx, sy - 68);
            C.restore();
          }
        }
      }
    }

    // ============================================================
    // PLAYER RENDER
    // ============================================================
    function renderPlayer() {
      const { p, cam } = GS;
      const sx = p.x - cam.x, sy = p.y - cam.y;
      const moving = Math.abs(p.vx) > 0.05 || Math.abs(p.vy) > 0.05 || K['ArrowLeft'] || K['ArrowRight'] || K['ArrowUp'] || K['ArrowDown'] || K['KeyA'] || K['KeyD'] || K['KeyW'] || K['KeyS'];
      const bob = moving ? Math.sin(GS.frame * 0.3) * 3 : 0;
      C.save();
      // Invincibilit√© dash ‚Äî clignotement rapide + aura cyan
      if (p.invincible) {
        if (Math.floor(GS.frame / 2) % 2 === 0) C.globalAlpha = 0.15;
        C.save();
        const ia = C.createRadialGradient(sx, sy, 4, sx, sy, 38);
        ia.addColorStop(0, 'rgba(0,255,200,0.45)'); ia.addColorStop(1, 'transparent');
        C.fillStyle = ia; C.beginPath(); C.arc(sx, sy, 38, 0, Math.PI * 2); C.fill();
        C.strokeStyle = 'rgba(0,255,200,0.7)'; C.lineWidth = 2.5;
        C.beginPath(); C.arc(sx, sy, 30 + Math.sin(GS.frame * 0.4) * 4, 0, Math.PI * 2); C.stroke();
        C.restore();
      } else if (p.inv > 0 && Math.floor(GS.frame / 3) % 2 === 0) {
        C.globalAlpha = 0.22;
      }
      // Time stop aura
      if (GS.timeStop) {
        C.save(); C.globalAlpha = 0.3 + Math.sin(GS.frame * 0.2) * 0.1; C.strokeStyle = '#8888ff'; C.lineWidth = 3;
        C.beginPath(); C.arc(sx, sy, 28, 0, Math.PI * 2); C.stroke(); C.restore();
      }
      // Attack arc
      if (p.atkAnim > 0) {
        const prog = 1 - p.atkAnim / 14, angle = Math.atan2(p.fy, p.fx);
        C.save(); C.globalAlpha = 0.7 * (1 - prog); C.strokeStyle = '#ffd700'; C.lineWidth = 7;
        C.shadowColor = '#ffd700'; C.shadowBlur = 18;
        C.beginPath(); C.arc(sx, sy, 48, angle - 1.0, angle + 1.0); C.stroke();
        C.strokeStyle = 'rgba(255,255,255,0.35)'; C.lineWidth = 2.5;
        C.beginPath(); C.arc(sx, sy, 48, angle - 1.0, angle + 1.0); C.stroke(); C.restore();
      }
      // Spin ring
      if (GS.spinAnim && GS.spinAnim.timer > 0) {
        const prog = GS.spinAnim.timer / GS.spinAnim.maxTimer;
        C.save(); C.globalAlpha = 0.5 * prog; C.strokeStyle = '#cc44ff'; C.lineWidth = 5;
        C.shadowColor = '#cc44ff'; C.shadowBlur = 20;
        C.beginPath(); C.arc(sx, sy, 55, 0, Math.PI * 2); C.stroke(); C.restore();
        GS.spinAnim.timer--;
      }
      // Charge aura
      if (p.charging && p.chargeTime > 0) {
        const ch = p.chargeTime / 90;
        const cg = C.createRadialGradient(sx, sy, 5, sx, sy, 32 + ch * 22);
        cg.addColorStop(0, `rgba(255,200,50,${0.45 * ch})`); cg.addColorStop(1, 'transparent');
        C.fillStyle = cg; C.beginPath(); C.arc(sx, sy, 52 + ch * 22, 0, Math.PI * 2); C.fill();
      }
      // Glow
      const glow = C.createRadialGradient(sx, sy + bob, 0, sx, sy + bob, 34);
      glow.addColorStop(0, `rgba(100,200,255,${0.12 + 0.05 * Math.sin(GS.frame * 0.05)})`); glow.addColorStop(1, 'transparent');
      C.fillStyle = glow; C.beginPath(); C.arc(sx, sy + bob, 34, 0, Math.PI * 2); C.fill();
      // Sprite sorcier pixel art
      const pdir = getPlayerDir(p);
      // scale up slightly if dying ‚Äî non (no dying state for player), just draw
      drawWizard(C, sx, sy + bob, pdir, p.atkAnim > 0 ? (Math.floor(GS.frame / 4) % 3) : (Math.floor(GS.frame / 10) % 3), 2.4);
      C.restore();
    }

    // ============================================================
    // ATTACK FX
    // ============================================================
    function renderAtks() {
      const { cam, atks } = GS;
      for (let i = atks.length - 1; i >= 0; i--) {
        const a = atks[i]; a.life--; if (a.life <= 0) { atks.splice(i, 1); continue; }
        const prog = (a.maxLife - a.life) / a.maxLife;
        const elapsed = a.maxLife - a.life;
        const sx = (a.worldX || a.x) - cam.x + a.vx * elapsed * 2.5;
        const sy = (a.worldY || a.y) - cam.y + a.vy * elapsed * 2.5;
        const fa = 1 - prog;
        C.save(); C.globalAlpha = fa;
        const sz = a.sz * (1 + prog * 0.3);

        if (a.icon === '‚ú®' || a.icon === 'üí´') {
          // √âclat dor√© ‚Äî croix de pixels + glow
          C.shadowColor = '#ffd700'; C.shadowBlur = 14 + prog * 10;
          C.fillStyle = '#ffd700';
          C.fillRect(sx - sz * 0.5, sy - 2, sz, 4);
          C.fillRect(sx - 2, sy - sz * 0.5, 4, sz);
          C.fillStyle = '#fff'; C.fillRect(sx - 2, sy - 2, 4, 4);
        } else if (a.icon === 'üí•') {
          // Explosion ‚Äî cercles concentriques pixelis√©s
          C.shadowColor = '#ff6600'; C.shadowBlur = 10;
          const rings = [['#ffcc00', sz * 0.9], ['#ff6600', sz * 0.65], ['#cc2200', sz * 0.35]];
          for (const [col, r] of rings) {
            C.strokeStyle = col; C.lineWidth = 3;
            C.beginPath(); C.arc(sx, sy, r, 0, Math.PI * 2); C.stroke();
          }
          C.fillStyle = '#fff'; C.fillRect(sx - 2, sy - 2, 4, 4);
        } else if (a.icon === 'üí®') {
          // Tra√Æn√©e dash ‚Äî petits rectangles bleus
          C.fillStyle = `rgba(0,220,180,${fa * 0.8})`;
          C.fillRect(sx - sz * 0.4, sy - 2, sz * 0.8, 4);
          C.fillRect(sx - 2, sy - sz * 0.3, 4, sz * 0.6);
        } else if (a.icon === 'üåÄ') {
          // T√©l√©port ‚Äî spirale violette
          C.strokeStyle = '#cc44ff'; C.lineWidth = 2; C.shadowColor = '#cc44ff'; C.shadowBlur = 12;
          for (let t = 0; t < Math.PI * 4; t += 0.3) {
            const r = (t / (Math.PI * 4)) * sz * 0.6;
            const px2 = sx + Math.cos(t + GS.frame * 0.3) * r;
            const py2 = sy + Math.sin(t + GS.frame * 0.3) * r;
            C.fillStyle = `rgba(200,80,255,${fa * (1 - t / (Math.PI * 4))})`;
            C.fillRect(px2, py2, 2, 2);
          }
        } else if (a.icon === '‚òÑÔ∏è') {
          // M√©t√©ore ‚Äî cercle rouge + tra√Æn√©e
          C.shadowColor = '#ff3300'; C.shadowBlur = 18;
          C.fillStyle = '#ff8800';
          C.beginPath(); C.arc(sx, sy, sz * 0.5, 0, Math.PI * 2); C.fill();
          C.fillStyle = '#ffdd00';
          C.beginPath(); C.arc(sx, sy, sz * 0.25, 0, Math.PI * 2); C.fill();
          // tra√Æn√©e
          C.fillStyle = 'rgba(255,100,0,0.4)';
          for (let t = 1; t <= 4; t++) {
            C.beginPath(); C.arc(sx - t * sz * 0.15, sy - t * sz * 0.15, sz * 0.4 / t, 0, Math.PI * 2); C.fill();
          }
        } else if (a.icon === 'üëÅÔ∏è') {
          // Wall phase eye ‚Äî oeil flottant
          C.fillStyle = `rgba(180,0,255,${fa * 0.7})`;
          C.beginPath(); C.ellipse(sx, sy, sz * 0.6, sz * 0.35, 0, 0, Math.PI * 2); C.fill();
          C.fillStyle = '#cc00ff';
          C.beginPath(); C.arc(sx, sy, sz * 0.2, 0, Math.PI * 2); C.fill();
          C.fillStyle = '#000';
          C.beginPath(); C.arc(sx, sy, sz * 0.1, 0, Math.PI * 2); C.fill();
        } else {
          // Fallback : carr√© color√© g√©n√©rique
          C.fillStyle = '#ffd700'; C.shadowColor = '#ffd700'; C.shadowBlur = 10;
          C.fillRect(sx - sz * 0.4, sy - sz * 0.4, sz * 0.8, sz * 0.8);
        }
        C.restore();
      }
    }

    // ============================================================
    // PROJECTILES RENDER
    // ============================================================
    function renderProjectiles() {
      const { cam } = GS;
      // Player projectiles
      for (const pr of GS.projectiles) {
        const sx = pr.x - cam.x, sy = pr.y - cam.y;
        if (sx < -60 || sx > canvas.width + 60 || sy < -60 || sy > canvas.height + 60) continue;
        C.save(); C.shadowBlur = 14;
        const ang = Math.atan2(pr.vy, pr.vx);
        C.translate(sx, sy); C.rotate(ang);
        if (pr.icon === '‚ö°') {
          // √âclair ‚Äî zigzag jaune
          C.shadowColor = '#ffd700'; C.strokeStyle = '#ffee00'; C.lineWidth = 3;
          C.beginPath(); C.moveTo(-10, 0); C.lineTo(-3, -5); C.lineTo(2, 3); C.lineTo(8, -4); C.lineTo(12, 0); C.stroke();
          C.strokeStyle = '#fff'; C.lineWidth = 1.5; C.stroke();
        } else if (pr.icon === 'üîÆ') {
          // Orbe violet
          C.shadowColor = '#aa00ff';
          C.fillStyle = '#8800cc';
          C.beginPath(); C.arc(0, 0, pr.sz * 0.5, 0, Math.PI * 2); C.fill();
          C.fillStyle = '#cc44ff';
          C.beginPath(); C.arc(-2, -2, pr.sz * 0.2, 0, Math.PI * 2); C.fill();
        } else if (pr.icon === '‚ùÑÔ∏è') {
          // Flocon glace
          C.shadowColor = '#88ccff'; C.strokeStyle = '#aaddff'; C.lineWidth = 2;
          for (let a = 0; a < Math.PI * 2; a += Math.PI / 3) {
            C.beginPath(); C.moveTo(0, 0); C.lineTo(Math.cos(a) * 10, Math.sin(a) * 10); C.stroke();
          }
          C.fillStyle = '#88ccff'; C.beginPath(); C.arc(0, 0, 3, 0, Math.PI * 2); C.fill();
        } else {
          C.fillStyle = '#ffd700'; C.shadowColor = '#ffd700';
          C.fillRect(-pr.sz * 0.4, -pr.sz * 0.4, pr.sz * 0.8, pr.sz * 0.8);
        }
        C.restore();
      }
      // Boss projectiles
      for (const pr of GS.bossProjectiles) {
        const sx = pr.x - cam.x, sy = pr.y - cam.y;
        if (sx < -60 || sx > canvas.width + 60 || sy < -60 || sy > canvas.height + 60) continue;
        C.save(); C.shadowBlur = 12; C.translate(sx, sy);
        if (pr.icon === '‚ò†Ô∏è') {
          // Poison ‚Äî cr√¢ne pixelis√©
          C.shadowColor = '#44ff44';
          C.fillStyle = '#228822';
          C.fillRect(-6, -6, 12, 10);
          C.fillStyle = '#44ff44'; C.fillRect(-4, -8, 4, 3); C.fillRect(2, -8, 4, 3);
          C.fillStyle = '#002200'; C.fillRect(-3, -4, 3, 3); C.fillRect(2, -4, 3, 3);
          C.fillRect(-2, 0, 2, 3); C.fillRect(0, 0, 2, 3); C.fillRect(2, 0, 2, 3);
        } else if (pr.icon === 'üíú') {
          // Ombre violette
          C.shadowColor = '#8800ff';
          C.fillStyle = '#6600cc';
          C.beginPath(); C.arc(0, 0, pr.sz * 0.5, 0, Math.PI * 2); C.fill();
          C.fillStyle = '#aa44ff'; C.beginPath(); C.arc(-2, -2, pr.sz * 0.2, 0, Math.PI * 2); C.fill();
        } else if (pr.icon === 'üî•') {
          // Flamme
          C.shadowColor = '#ff4400';
          C.fillStyle = '#ff4400'; C.fillRect(-4, -8, 8, 10);
          C.fillStyle = '#ff8800'; C.fillRect(-3, -10, 6, 7);
          C.fillStyle = '#ffcc00'; C.fillRect(-2, -12, 4, 6);
          C.fillStyle = '#fff'; C.fillRect(-1, -13, 2, 3);
        } else if (pr.icon === 'üåä') {
          // Onde choc
          C.shadowColor = '#4488ff';
          C.strokeStyle = '#4488ff'; C.lineWidth = 2;
          C.beginPath(); C.arc(0, 0, pr.sz * 0.6, 0, Math.PI * 2); C.stroke();
          C.strokeStyle = '#88ccff'; C.lineWidth = 1;
          C.beginPath(); C.arc(0, 0, pr.sz * 0.35, 0, Math.PI * 2); C.stroke();
        } else if (pr.icon === 'üí¢') {
          // Enrage ‚Äî losange rouge
          C.shadowColor = '#ff0000';
          C.fillStyle = '#cc0000';
          C.save(); C.rotate(Math.PI / 4 + GS.frame * 0.05);
          C.fillRect(-5, -5, 10, 10);
          C.restore();
          C.fillStyle = '#ff4444'; C.fillRect(-2, -2, 4, 4);
        } else if (pr.icon === '‚è∞') {
          // Arr√™t du temps ‚Äî horloge
          C.shadowColor = '#8888ff';
          C.strokeStyle = '#8888ff'; C.lineWidth = 2;
          C.beginPath(); C.arc(0, 0, pr.sz * 0.5, 0, Math.PI * 2); C.stroke();
          C.fillStyle = '#8888ff'; C.fillRect(-1, -7, 2, 7); C.fillRect(0, -2, 5, 2);
        } else {
          C.fillStyle = '#ff4400'; C.shadowColor = '#ff4400';
          C.fillRect(-pr.sz * 0.4, -pr.sz * 0.4, pr.sz * 0.8, pr.sz * 0.8);
        }
        C.restore();
      }
    }

    // ============================================================
    // LIGHTING
    // ============================================================
    function renderLighting() {
      const { p, cam } = GS; const sx = p.x - cam.x, sy = p.y - cam.y;
      const biome = LEVELS[curLvl].biome;
      const vg = C.createRadialGradient(sx, sy, canvas.width * 0.14, sx, sy, canvas.width * 0.65);
      const outerA = biome === 'castle' ? 0.62 : biome === 'mountain' ? 0.52 : 0.42;
      vg.addColorStop(0, 'rgba(0,0,0,0)'); vg.addColorStop(1, `rgba(0,0,0,${outerA})`);
      C.fillStyle = vg; C.fillRect(0, 0, canvas.width, canvas.height);
      if (GS.lightPulse > 0) GS.lightPulse--;
      const lr = 220 + GS.lightPulse * 10;
      const lg = C.createRadialGradient(sx, sy, 0, sx, sy, lr);
      const lc = biome === 'castle' ? 'rgba(100,100,200,' : biome === 'mountain' ? 'rgba(150,200,255,' : 'rgba(255,220,100,';
      lg.addColorStop(0, lc + '0.13)'); lg.addColorStop(0.5, lc + '0.04)'); lg.addColorStop(1, 'transparent');
      C.fillStyle = lg; C.fillRect(0, 0, canvas.width, canvas.height);
      // Time stop tint
      if (GS.timeStop) {
        C.fillStyle = `rgba(50,50,200,${0.15 + 0.05 * Math.sin(GS.frame * 0.1)})`;
        C.fillRect(0, 0, canvas.width, canvas.height);
      }
      const edge = 8; C.fillStyle = 'rgba(0,0,0,0.25)';
      C.fillRect(0, 64, edge, canvas.height - 64); C.fillRect(canvas.width - edge, 64, edge, canvas.height - 64);
      C.fillRect(0, canvas.height - edge, canvas.width, edge);
    }

    // ============================================================
    // MINIMAP
    // ============================================================
    function renderMinimap() {
      const { map: { map }, p, cam, mons, boss, qItems } = GS;
      const mw = mm.width, mh = mm.height; const sx = mw / WW, sy = mh / WH;
      // Fond
      MC.fillStyle = '#020208'; MC.fillRect(0, 0, mw, mh);
      const step = 3;
      const tC = {
        0: '#2a7a2a', 1: '#a07830', 2: '#1a4a8a', 3: '#555', 4: '#1a3a1a', 5: '#3a8a3a',
        6: '#1e4a20', 7: '#252440', 8: '#16163a', 9: '#d0e8f8', 10: '#7aaac8', 11: '#cc2200',
        12: '#090914', 13: '#7a5020', 14: '#3a9a3a', 15: '#3a8c30', 16: '#c8a060', 17: '#1e5a2a'
      };
      for (let r = 0; r < ROWS; r += step)for (let c = 0; c < COLS; c += step) {
        MC.fillStyle = tC[map[r][c]] || '#333'; MC.fillRect(c * sx * TSIZ, r * sy * TSIZ, (step * sx * TSIZ) + 1, (step * sy * TSIZ) + 1);
      }
      // Items de qu√™te ‚Äî jaune vif
      for (const qi of qItems) if (!qi.collected) {
        MC.fillStyle = '#ffe000'; MC.fillRect(qi.x * sx - 2, qi.y * sy - 2, 4, 4);
      }
      // Ennemis ‚Äî rouge plus visible
      MC.fillStyle = '#ff3333';
      for (const m of mons) if (m.state !== 'dead') { MC.fillRect(m.x * sx - 1.5, m.y * sy - 1.5, 3, 3); }
      // Boss ‚Äî orange puls√©
      if (boss && boss.state !== 'dead') {
        MC.fillStyle = boss.rageMode ? '#ff6600' : '#ff2200';
        MC.fillRect(boss.x * sx - 3, boss.y * sy - 3, 6, 6);
      }
      // Vue cam√©ra
      MC.strokeStyle = 'rgba(255,255,100,0.25)'; MC.lineWidth = 1;
      MC.strokeRect(cam.x * sx, cam.y * sy, canvas.width * sx, canvas.height * sy);
      // Joueur ‚Äî point vert vif + halo
      MC.fillStyle = 'rgba(0,255,100,0.3)'; MC.beginPath(); MC.arc(p.x * sx, p.y * sy, 5, 0, Math.PI * 2); MC.fill();
      MC.fillStyle = '#00ff66'; MC.beginPath(); MC.arc(p.x * sx, p.y * sy, 2.5, 0, Math.PI * 2); MC.fill();
    }

    // ============================================================
    // HUD
    // ============================================================
    function updHUD() {
      const p = GS.p; const lv = LEVELS[curLvl];
      const hw = document.getElementById('hearts'); hw.innerHTML = '';
      for (let i = 0; i < p.maxHp; i++) { const h = document.createElement('div'); h.className = i < p.hp ? 'heart-full' : 'heart-empty'; hw.appendChild(h); }
      document.getElementById('xpbar').style.width = Math.min(100, p.xp / (p.lvl * 100) * 100) + '%';
      document.getElementById('hud-lvl').textContent = `Niv. ${p.lvl}`;
      document.getElementById('hud-weapon').textContent = p.weapon;
      const done = lv.questType === 'kill' ? p.qKills : p.qItems;
      document.getElementById('hud-quest').textContent = `${lv.quest} (${Math.min(done, lv.questCount)}/${lv.questCount})`;
    }

    // ============================================================
    // DIALOG
    // ============================================================
    let dlgLines = [], dlgIdx = 0, dlgCB = null, dlgTyping = false, dlgTimer = null, dlgFull = '';
    function openDlg(portrait, name, lines, cb) {
      GS.dlgActive = true; dlgLines = lines; dlgIdx = 0; dlgCB = cb;
      document.getElementById('dialog').style.display = 'block';
      document.getElementById('dlg-portrait').textContent = portrait;
      document.getElementById('dlg-name').textContent = name.toUpperCase();
      document.getElementById('dlg-btn').style.display = 'none';
      document.getElementById('dlg-cont').style.display = 'none';
      typeNext();
    }
    function typeNext() {
      if (dlgIdx >= dlgLines.length) { closeDlg(); return; }
      dlgFull = dlgLines[dlgIdx++];
      const el = document.getElementById('dlg-text');
      const btn = document.getElementById('dlg-btn'), cont = document.getElementById('dlg-cont');
      btn.style.display = 'none'; cont.style.display = 'none';
      if (dlgTimer) clearInterval(dlgTimer);
      dlgTyping = true; el.textContent = ''; let i = 0;
      dlgTimer = setInterval(() => {
        el.textContent += dlgFull[i]; sBeep(); i++;
        if (i >= dlgFull.length) {
          clearInterval(dlgTimer); dlgTyping = false; btn.style.display = 'block';
          if (dlgIdx < dlgLines.length) { cont.style.display = 'block'; btn.textContent = 'SUITE ‚ñ∂'; }
          else btn.textContent = 'FERMER ‚úï';
        }
      }, 28);
    }
    function nextLine() {
      if (dlgTyping) {
        clearInterval(dlgTimer); dlgTyping = false; document.getElementById('dlg-text').textContent = dlgFull;
        const btn = document.getElementById('dlg-btn'); btn.style.display = 'block';
        if (dlgIdx < dlgLines.length) { document.getElementById('dlg-cont').style.display = 'block'; btn.textContent = 'SUITE ‚ñ∂'; }
        else { document.getElementById('dlg-cont').style.display = 'none'; btn.textContent = 'FERMER ‚úï'; } return;
      }
      if (dlgIdx < dlgLines.length) typeNext(); else closeDlg();
    }
    function closeDlg() {
      document.getElementById('dialog').style.display = 'none';
      GS.dlgActive = false; if (dlgCB) { const cb = dlgCB; dlgCB = null; cb(); }
    }

    // ============================================================
    // LEVEL TRANSITION / VICTORY
    // ============================================================
    function showLT() {
      const lv = LEVELS[curLvl];
      document.getElementById('lt-icon').textContent = lv.rewardIcon;
      document.getElementById('lt-title').textContent = curLvl >= 2 ? 'üèÜ VICTOIRE FINALE !' : 'NIVEAU ACCOMPLI !';
      document.getElementById('lt-zone').textContent = lv.name + ' ‚Äî Termin√© !';
      document.getElementById('lt-reward').textContent = lv.reward;
      if (curLvl >= 2) {
        document.getElementById('lt-btn').style.display = 'none';
        const vb = document.createElement('button'); vb.className = 'lt-next-btn'; vb.textContent = 'üåü VOIR LA FIN';
        vb.onclick = () => { document.getElementById('leveltrans').style.display = 'none'; showVic(); };
        document.getElementById('leveltrans').appendChild(vb);
      }
      document.getElementById('leveltrans').style.display = 'flex';
      sLvlUp(); fireworks();
    }
    function goNextLevel() {
      document.getElementById('leveltrans').style.display = 'none';
      curLvl++; if (curLvl >= LEVELS.length) { showVic(); return; }
      loadLevel(curLvl);
    }
    function showVic() { document.getElementById('victory').style.display = 'flex'; sVic(); fireworks(); }

    // ============================================================
    // LOAD LEVEL
    // ============================================================
    function loadLevel(idx) {
      if (typeof BossMusic !== 'undefined') BossMusic.onLoadLevel(idx);
      const lv = LEVELS[idx];
      const mapData = genMap(lv.biome);
      GS.map = mapData; GS.decos = genDecos(mapData, lv.biome); GS.ambient = genAmbient(lv.biome);
      GS.qItems = mapData.questPos; GS.mons = spawnMons(mapData, lv.biome, idx);
      GS.boss = null; GS.bossSpawned = false; GS.bossDefeated = false;
      GS.projectiles = []; GS.bossProjectiles = []; GS.bossWarnings = []; GS.atks = []; GS.spinAnim = null;
      GS.timeStop = false; GS.timeStopTimer = 0;
      const p = GS.p;
      p.x = mapData.startPos.x; p.y = mapData.startPos.y;
      p.qItems = 0; p.qKills = 0; p.inv = 100; p.charging = false; p.chargeTime = 0; p.atkCDs = [0, 0, 0, 0];
      p.dashCD = 0; p.invincible = false; p.invincibleTimer = 0;
      if (idx > 0) { p.weapon = LEVELS[idx - 1].weapon; p.wPow = LEVELS[idx - 1].wPow; }
      p.hp = p.maxHp;
      if (idx === 2) {
        const bp = mapData.bossPos;
        GS.qItems = [{ x: bp.x, y: bp.y, collected: false }];
        GS.boss = {
          icon: lv.bossIcon, name: lv.bossName, hp: lv.bossHP, maxHp: lv.bossHP,
          spd: 0.8, dmg: 5, x: bp.x - 80, y: bp.y, state: 'idle', dyingTimer: 0, atkCD: 0,
          aggroR: 400, loseR: 620, wAngle: 0, wTimer: 0, hitFlash: 0, r: 26, boss: true, xp: 250,
          phase: 0, phaseTimer: 0, patternTimer: 0, patterns: lv.bossPatterns || [],
          dashActive: false, dashTimer: 0, dashVx: 0, dashVy: 0, vx: 0, vy: 0,
          teleportCooldown: 0, rageMode: false, beamActive: false, beamTimer: 0, beamAngle: 0,
          beamSweepDir: 1, timeStopActive: false
        };
        GS.bossSpawned = true;
        // Setup boss HP bar
        document.getElementById('boss-hud').style.display = 'flex';
        document.getElementById('boss-hud-name').textContent = lv.bossName.toUpperCase();
        const pip = document.getElementById('boss-phase-wrap'); pip.innerHTML = '';
        for (let i = 0; i < (lv.bossPhases || 2); i++) { const d = document.createElement('div'); d.className = 'boss-phase-pip' + (i === 0 ? ' active' : ''); d.id = `bpip${i}`; pip.appendChild(d); }
      }
      GS.cam.x = p.x - canvas.width / 2; GS.cam.y = p.y - canvas.height / 2;
      GS.cam.x = Math.max(0, Math.min(WW - canvas.width, GS.cam.x)); GS.cam.y = Math.max(0, Math.min(WH - canvas.height, GS.cam.y));
      updHUD(); tileCache.clear();
      setTimeout(() => openDlg('üìú', `NIVEAU ${idx + 1}`, [`${lv.name}`, `Objectif : ${lv.quest}`, 'En avant, h√©ros !'], null), 700);
    }

    function spawnMons(mapData, biome, idx) {
      const types = MONS[biome] || MONS.forest; const count = 12 + idx * 5; const { map } = mapData;
      const sR = Math.floor(mapData.startPos.y / TSIZ), sC = Math.floor(mapData.startPos.x / TSIZ);
      const cells = bfsPassable(map, sR, sC, 5000); const out = [];
      for (let i = 0; i < count && cells.length > 0; i++) {
        const type = types[Math.floor(Math.random() * types.length)];
        const cell = safeSpawnCell(cells, mapData.startPos.x, mapData.startPos.y, 120);
        if (!cell) continue;
        out.push({
          ...JSON.parse(JSON.stringify(type)), id: i, x: cell.x, y: cell.y, vx: 0, vy: 0,
          state: 'idle', dyingTimer: 0, atkCD: 0, aggroR: 160 + Math.random() * 80, loseR: 300,
          wAngle: Math.random() * Math.PI * 2, wTimer: Math.random() * 90, hitFlash: 0
        });
      }
      return out;
    }

    // ============================================================
    // PIXEL ART SPRITES ‚Äî toutes les fonctions de dessin
    // ============================================================

    // Helper : dessine un pixel art √† partir d'une palette + grille
    function px(ctx, x, y, s, palette, grid, cols) {
      for (let i = 0; i < grid.length; i++) {
        const c = grid[i]; if (c === 0) continue;
        ctx.fillStyle = palette[c - 1];
        ctx.fillRect(x + (i % cols) * s, y + Math.floor(i / cols) * s, s, s);
      }
    }

    // ‚îÄ‚îÄ‚îÄ SORCIER (joueur) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // 12√ó16 pixels, 4 directions, 3 frames
    // direction: 0=bas 1=gauche 2=droite 3=haut
    function drawWizard(ctx, cx, cy, dir, frame, scale = 2) {
      const s = scale;
      const flip = dir === 1; // gauche = flip horizontal
      ctx.save();
      ctx.translate(cx, cy);
      if (flip) { ctx.scale(-1, 1); }

      // Palette: 1=robe fonc√©e 2=robe claire 3=peau 4=barbe 5=chapeau 6=b√¢ton 7=orbe 8=yeux 9=accent dor√©
      const P = ['#2a1c6e', '#4a3ea8', '#f2c07a', '#e8e8e8', '#1a1240', '#7a4a1a', '#00d4ff', '#220022', '#ffd700'];

      const W = 12, H = 16;
      const ox = -Math.floor(W * s / 2), oy = -Math.floor(H * s / 2);

      // Bob walking
      const legFrame = frame;
      const bodyBob = (frame === 1) ? -1 : 0;

      // --- CHAPEAU ---
      // pointe du chapeau
      for (let i = 3; i <= 8; i++) {
        const h = Math.max(0, 4 - Math.abs(i - 5.5));
        ctx.fillStyle = P[4];
        ctx.fillRect(ox + i * s, oy + (1 + (3 - h)) * s, s, h * s);
      }
      // bord chapeau
      ctx.fillStyle = P[4];
      ctx.fillRect(ox + 1 * s, oy + 5 * s, 10 * s, s);
      // √©toile sur chapeau
      ctx.fillStyle = P[8];
      ctx.fillRect(ox + 5 * s, oy + 3 * s, s, s);
      ctx.fillRect(ox + 4 * s, oy + 4 * s, 3 * s, s);
      ctx.fillRect(ox + 5 * s, oy + 4 * s, s, s);

      // --- T√äTE ---
      ctx.fillStyle = P[2];
      ctx.fillRect(ox + 3 * s, oy + (6 + bodyBob) * s, 6 * s, 4 * s);
      // yeux (selon direction)
      ctx.fillStyle = P[7];
      if (dir !== 3) { // pas dos
        ctx.fillRect(ox + 4 * s, oy + (7 + bodyBob) * s, s, s);
        ctx.fillRect(ox + 7 * s, oy + (7 + bodyBob) * s, s, s);
      }
      // barbe
      ctx.fillStyle = P[3];
      ctx.fillRect(ox + 3 * s, oy + (9 + bodyBob) * s, 6 * s, s);
      ctx.fillRect(ox + 4 * s, oy + (9 + bodyBob) * s, 4 * s, 2 * s);

      // --- ROBE ---
      ctx.fillStyle = P[0];
      ctx.fillRect(ox + 2 * s, oy + 10 * s, 8 * s, 4 * s);
      ctx.fillStyle = P[1];
      // reflets robe
      ctx.fillRect(ox + 4 * s, oy + 10 * s, 4 * s, 3 * s);
      // bas robe √©vas√©
      ctx.fillStyle = P[0];
      ctx.fillRect(ox + 1 * s, oy + 13 * s, 10 * s, s);
      // motif dor√© robe
      ctx.fillStyle = P[8];
      ctx.fillRect(ox + 5 * s, oy + 11 * s, 2 * s, s);

      // --- JAMBES ---
      const legOff = legFrame === 0 ? 0 : legFrame === 1 ? -s : s;
      ctx.fillStyle = P[0];
      ctx.fillRect(ox + 3 * s + legOff, oy + 14 * s, 2 * s, 2 * s);
      ctx.fillRect(ox + 7 * s - legOff, oy + 14 * s, 2 * s, 2 * s);
      // chaussures
      ctx.fillStyle = P[4];
      ctx.fillRect(ox + 3 * s + legOff - s, oy + 15 * s, 3 * s, s);
      ctx.fillRect(ox + 7 * s - legOff, oy + 15 * s, 3 * s, s);

      // --- BATON ---
      ctx.fillStyle = P[5];
      ctx.fillRect(ox + 0 * s, oy + 5 * s, s, 11 * s);
      // orbe b√¢ton
      ctx.fillStyle = P[6];
      ctx.fillRect(ox + 0 * s, oy + 4 * s, 2 * s, 2 * s);
      // brillance orbe (pulse)
      const pulse = (Math.sin(GS.frame * 0.12) + 1) / 2;
      ctx.globalAlpha *= (0.5 + 0.5 * pulse);
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(ox + 0 * s, oy + 4 * s, s, s);
      ctx.globalAlpha = ctx.globalAlpha / (0.5 + 0.5 * pulse) || 1;

      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ LOUP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawWolf(ctx, cx, cy, dir, frame, scale = 2, alpha = 1) {
      const s = scale;
      const flip = dir < 0; // dir=-1 va √† gauche
      ctx.save();
      ctx.translate(cx, cy);
      ctx.globalAlpha *= alpha;
      if (flip) { ctx.scale(-1, 1); }

      const ox = -10 * s, oy = -10 * s;

      const legOff = frame === 0 ? 0 : 2 * s;
      const runBob = frame === 1 ? -s : 0;

      // Corps
      ctx.fillStyle = '#5a4030';
      ctx.fillRect(ox + 3 * s, oy + 5 * s + runBob, 12 * s, 7 * s);
      // Ventre plus clair
      ctx.fillStyle = '#7a6050';
      ctx.fillRect(ox + 5 * s, oy + 8 * s + runBob, 7 * s, 3 * s);
      // Queue
      ctx.fillStyle = '#4a3020';
      ctx.fillRect(ox + 15 * s, oy + 3 * s + runBob, 3 * s, 5 * s);
      ctx.fillRect(ox + 16 * s, oy + 2 * s + runBob, 2 * s, 3 * s);

      // T√™te
      ctx.fillStyle = '#4a3020';
      ctx.fillRect(ox + 0 * s, oy + 2 * s + runBob, 8 * s, 7 * s);
      // Museau
      ctx.fillStyle = '#6a5040';
      ctx.fillRect(ox + 0 * s, oy + 6 * s + runBob, 5 * s, 3 * s);
      // Truffe
      ctx.fillStyle = '#1a0808';
      ctx.fillRect(ox + 0 * s, oy + 6 * s + runBob, 2 * s, 2 * s);
      // Oreilles
      ctx.fillStyle = '#3a2010';
      ctx.fillRect(ox + 3 * s, oy + 0 * s + runBob, 3 * s, 3 * s);
      ctx.fillRect(ox + 6 * s, oy + 0 * s + runBob, 3 * s, 3 * s);
      // Yeux
      ctx.fillStyle = '#ffdd00';
      ctx.fillRect(ox + 2 * s, oy + 3 * s + runBob, 2 * s, 2 * s);
      ctx.fillRect(ox + 5 * s, oy + 3 * s + runBob, 2 * s, 2 * s);
      ctx.fillStyle = '#000';
      ctx.fillRect(ox + 3 * s, oy + 3 * s + runBob, s, s);
      ctx.fillRect(ox + 6 * s, oy + 3 * s + runBob, s, s);

      // Pattes avant
      ctx.fillStyle = '#4a3020';
      ctx.fillRect(ox + 3 * s, oy + 11 * s + legOff, 3 * s, 3 * s);
      ctx.fillRect(ox + 8 * s, oy + 11 * s - legOff, 3 * s, 3 * s);
      // Pattes arri√®re
      ctx.fillRect(ox + 11 * s, oy + 11 * s + legOff, 3 * s, 3 * s);
      ctx.fillRect(ox + 14 * s, oy + 11 * s - legOff, 3 * s, 3 * s);
      // Griffes
      ctx.fillStyle = '#aaa';
      ctx.fillRect(ox + 3 * s, oy + 13 * s + legOff, s, s);
      ctx.fillRect(ox + 5 * s, oy + 13 * s + legOff, s, s);
      ctx.fillRect(ox + 8 * s, oy + 13 * s - legOff, s, s);
      ctx.fillRect(ox + 10 * s, oy + 13 * s - legOff, s, s);

      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ CHAUVE-SOURIS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawBat(ctx, cx, cy, frame, scale = 2, alpha = 1) {
      const s = scale;
      ctx.save();
      ctx.translate(cx, cy);
      ctx.globalAlpha *= alpha;

      const ox = -10 * s, oy = -8 * s;
      const wingUp = frame === 0;

      // Ombre port√©e
      ctx.fillStyle = 'rgba(0,0,0,0.18)';
      ctx.beginPath(); ctx.ellipse(cx - cx + 0, oy + 18 * s - cy + cy, 8 * s, 2 * s, 0, 0, Math.PI * 2); ctx.fill();
      ctx.translate(-cx + cx, -cy + cy);

      // Ailes
      ctx.fillStyle = '#2a1848';
      if (wingUp) {
        // Ailes lev√©es
        ctx.beginPath();
        ctx.moveTo(ox + 6 * s, oy + 6 * s); ctx.lineTo(ox - 2 * s, oy + 0 * s);
        ctx.lineTo(ox + 0 * s, oy + 2 * s); ctx.lineTo(ox + 2 * s, oy + 0 * s);
        ctx.lineTo(ox + 4 * s, oy + 3 * s); ctx.closePath(); ctx.fill();
        ctx.beginPath();
        ctx.moveTo(ox + 14 * s, oy + 6 * s); ctx.lineTo(ox + 22 * s, oy + 0 * s);
        ctx.lineTo(ox + 20 * s, oy + 2 * s); ctx.lineTo(ox + 18 * s, oy + 0 * s);
        ctx.lineTo(ox + 16 * s, oy + 3 * s); ctx.closePath(); ctx.fill();
      } else {
        // Ailes baiss√©es
        ctx.beginPath();
        ctx.moveTo(ox + 6 * s, oy + 6 * s); ctx.lineTo(ox - 2 * s, oy + 10 * s);
        ctx.lineTo(ox + 0 * s, oy + 9 * s); ctx.lineTo(ox + 2 * s, oy + 10 * s);
        ctx.lineTo(ox + 4 * s, oy + 8 * s); ctx.closePath(); ctx.fill();
        ctx.beginPath();
        ctx.moveTo(ox + 14 * s, oy + 6 * s); ctx.lineTo(ox + 22 * s, oy + 10 * s);
        ctx.lineTo(ox + 20 * s, oy + 9 * s); ctx.lineTo(ox + 18 * s, oy + 10 * s);
        ctx.lineTo(ox + 16 * s, oy + 8 * s); ctx.closePath(); ctx.fill();
      }
      // Membrane aile (d√©tail)
      ctx.fillStyle = '#3a2860';
      if (wingUp) {
        ctx.fillRect(ox + 1 * s, oy + 1 * s, 4 * s, s); ctx.fillRect(ox + 15 * s, oy + 1 * s, 4 * s, s);
      }
      // Corps
      ctx.fillStyle = '#2a1848';
      ctx.beginPath(); ctx.arc(ox + 10 * s, oy + 7 * s, 5 * s, 0, Math.PI * 2); ctx.fill();
      // Fourrure ventre
      ctx.fillStyle = '#3a2868';
      ctx.fillRect(ox + 7 * s, oy + 6 * s, 6 * s, 3 * s);
      // Oreilles pointues
      ctx.fillStyle = '#1a0c30';
      ctx.beginPath();
      ctx.moveTo(ox + 7 * s, oy + 3 * s); ctx.lineTo(ox + 6 * s, oy - 1 * s); ctx.lineTo(ox + 9 * s, oy + 3 * s); ctx.closePath(); ctx.fill();
      ctx.beginPath();
      ctx.moveTo(ox + 11 * s, oy + 3 * s); ctx.lineTo(ox + 14 * s, oy - 1 * s); ctx.lineTo(ox + 13 * s, oy + 3 * s); ctx.closePath(); ctx.fill();
      // Yeux rouges brillants
      ctx.fillStyle = '#ff2200';
      ctx.fillRect(ox + 8 * s, oy + 5 * s, 2 * s, 2 * s);
      ctx.fillRect(ox + 11 * s, oy + 5 * s, 2 * s, 2 * s);
      ctx.fillStyle = '#ff8866';
      ctx.fillRect(ox + 8 * s, oy + 5 * s, s, s);
      ctx.fillRect(ox + 11 * s, oy + 5 * s, s, s);
      // Crocs
      ctx.fillStyle = '#eee';
      ctx.fillRect(ox + 9 * s, oy + 9 * s, s, 2 * s);
      ctx.fillRect(ox + 11 * s, oy + 9 * s, s, 2 * s);

      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ ARAIGN√âE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawSpider(ctx, cx, cy, frame, scale = 2, alpha = 1) {
      const s = scale;
      ctx.save();
      ctx.translate(cx, cy);
      ctx.globalAlpha *= alpha;

      const ox = -9 * s, oy = -8 * s;
      const legOff = frame === 0 ? 0 : s;

      // Toile (fond)
      ctx.strokeStyle = 'rgba(200,200,200,0.3)';
      ctx.lineWidth = 0.5;
      for (let i = 0; i < 3; i++) {
        ctx.beginPath(); ctx.arc(0, oy + 2 * s, (4 + i * 3) * s, 0, Math.PI * 2); ctx.stroke();
      }

      // Pattes (8 pattes)
      ctx.strokeStyle = '#1a1a1a'; ctx.lineWidth = s;
      const legAngles = [-0.7, -0.4, -0.15, 0.15, 0.4, 0.7, 1.0, 1.3].map((a, i) => i < 4 ? -Math.PI / 2 - a * 0.8 : Math.PI / 2 + (a - 0.7) * 0.8);
      for (let i = 0; i < 8; i++) {
        const side = i < 4 ? -1 : 1;
        const li = i % 4;
        const ang = (i < 4 ? [-0.8, -0.4, 0.0, 0.4][li] : [0.0, 0.4, 0.8, 1.2][li]);
        const baseX = side * 3 * s;
        const lLen = (7 + li) * s;
        const bendY = legOff * (li % 2 === 0 ? 1 : -1);
        ctx.beginPath();
        ctx.moveTo(baseX, 0);
        const midX = baseX + side * lLen * 0.5;
        const midY = -4 * s + ang * 3 * s + bendY;
        const endX = baseX + side * lLen;
        const endY = 3 * s + ang * 2 * s - bendY;
        ctx.quadraticCurveTo(midX, midY, endX, endY);
        ctx.stroke();
      }

      // Corps (abdomen)
      ctx.fillStyle = '#181818';
      ctx.beginPath(); ctx.ellipse(0, 3 * s, 6 * s, 5 * s, 0, 0, Math.PI * 2); ctx.fill();
      // Motif abdomen
      ctx.fillStyle = '#cc2200';
      ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-2 * s, 5 * s); ctx.lineTo(0, 7 * s); ctx.lineTo(2 * s, 5 * s); ctx.closePath(); ctx.fill();
      ctx.fillStyle = '#ff4400';
      ctx.fillRect(-s, 3 * s, 2 * s, 2 * s);

      // C√©phalothorax
      ctx.fillStyle = '#222';
      ctx.beginPath(); ctx.ellipse(0, -3 * s, 4 * s, 4 * s, 0, 0, Math.PI * 2); ctx.fill();
      // 8 yeux
      ctx.fillStyle = '#44ffaa';
      const eyePos = [[-2, -5], [0, -5], [2, -5], [-3, -3], [3, -3], [-1, -2], [1, -2], [0, -4]];
      for (const [ex, ey] of eyePos) {
        ctx.fillRect(ex * s, ey * s, s, s);
      }
      // Crochets
      ctx.fillStyle = '#ff2200';
      ctx.fillRect(-2 * s, -8 * s, s, 3 * s);
      ctx.fillRect(s, -8 * s, s, 3 * s);

      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ MONSTRE FEUILLE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawLeafMonster(ctx, cx, cy, frame, scale = 2, alpha = 1) {
      const s = scale;
      ctx.save();
      ctx.translate(cx, cy);
      ctx.globalAlpha *= alpha;

      const ox = -9 * s, oy = -12 * s;
      const sway = frame === 0 ? 0 : s;

      // Feuilles de fond (d√©cor)
      ctx.fillStyle = '#1a5c2a';
      for (let i = 0; i < 3; i++) {
        ctx.save();
        ctx.rotate((i - 1) * 0.3 + sway * 0.05);
        ctx.beginPath();
        ctx.ellipse((-2 + i * 2) * s, -10 * s, 4 * s, 7 * s, (i - 1) * 0.4, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      // Corps principal (feuille g√©ante)
      ctx.fillStyle = '#2a8040';
      ctx.beginPath();
      ctx.moveTo(0, oy + 0 * s);
      ctx.bezierCurveTo(-8 * s + sway, oy + 6 * s, -6 * s - sway, oy + 16 * s, 0, oy + 22 * s);
      ctx.bezierCurveTo(6 * s + sway, oy + 16 * s, 8 * s - sway, oy + 6 * s, 0, oy + 0 * s);
      ctx.fill();
      // Nervure centrale
      ctx.strokeStyle = '#1a6030'; ctx.lineWidth = s;
      ctx.beginPath();
      ctx.moveTo(0, oy); ctx.lineTo(0, oy + 22 * s); ctx.stroke();
      // Nervures lat√©rales
      ctx.lineWidth = 0.5;
      for (let i = 1; i < 5; i++) {
        ctx.beginPath();
        ctx.moveTo(0, oy + i * 4 * s);
        ctx.lineTo(-4 * s, oy + i * 4 * s + 2 * s);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, oy + i * 4 * s);
        ctx.lineTo(4 * s, oy + i * 4 * s + 2 * s);
        ctx.stroke();
      }
      // Reflets
      ctx.fillStyle = '#4ab060';
      ctx.beginPath();
      ctx.ellipse(-2 * s, oy + 8 * s, 2 * s, 5 * s, -0.2, 0, Math.PI * 2);
      ctx.fill();

      // Yeux rouges brillants
      ctx.fillStyle = '#cc0000';
      ctx.beginPath(); ctx.arc(-3 * s, oy + 9 * s, 2 * s, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(3 * s, oy + 9 * s, 2 * s, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#ff4444';
      ctx.fillRect(-4 * s, oy + 8 * s, 2 * s, 2 * s);
      ctx.fillRect(2 * s, oy + 8 * s, 2 * s, 2 * s);
      // Pupilles
      ctx.fillStyle = '#000';
      ctx.fillRect(-3 * s, oy + 9 * s, s, s);
      ctx.fillRect(3 * s, oy + 9 * s, s, s);

      // Bouche dentel√©e
      ctx.fillStyle = '#0a3010';
      ctx.fillRect(-3 * s, oy + 13 * s, 6 * s, 2 * s);
      ctx.fillStyle = '#eee';
      for (let i = 0; i < 3; i++) {
        ctx.fillRect((-2 + i * 2) * s, oy + 13 * s, s, 2 * s);
      }

      // Petites griffes
      ctx.fillStyle = '#1a4020';
      ctx.fillRect(-4 * s, oy + 20 * s - sway, 2 * s, 3 * s);
      ctx.fillRect(2 * s, oy + 20 * s + sway, 2 * s, 3 * s);
      ctx.fillStyle = '#aad060';
      ctx.fillRect(-5 * s, oy + 22 * s - sway, s, 2 * s);
      ctx.fillRect(-3 * s, oy + 22 * s - sway, s, 2 * s);
      ctx.fillRect(2 * s, oy + 22 * s + sway, s, 2 * s);
      ctx.fillRect(4 * s, oy + 22 * s + sway, s, 2 * s);

      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ D√âMON RAGE (boss 1) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ‚îÄ‚îÄ‚îÄ VORGATH LE BR√õL√â ‚Äî D√©mon des Flammes ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function drawDemon(ctx, cx, cy, dir, frame, scale = 2.2, alpha = 1, rageMode = false) {
      const s = scale;
      const f = GS.frame;
      ctx.save();
      ctx.translate(cx, cy);
      ctx.globalAlpha *= alpha;
      if (dir === 1) ctx.scale(-1, 1);

      const ox = -12 * s, oy = -16 * s;

      // Timings anim√©s ind√©pendants
      const breathe   = Math.sin(f * 0.06);
      const pulse     = (Math.sin(f * 0.18) + 1) / 2;
      const fireFlick = (Math.sin(f * 0.38) + Math.sin(f * 0.71)) * 0.5;
      const legPhase  = (f % 32) / 32;
      const legL      = Math.sin(legPhase * Math.PI * 2) * 4 * s;
      const legR      = -legL;
      const armL      = Math.sin(f * 0.09) * 5 * s;
      const armR      = -armL;
      const bodyBob   = breathe * 1.2 * s;
      const hornPulse = rageMode ? 0.6 + 0.4 * pulse : 0.2 + 0.15 * pulse;

      // ‚îÄ‚îÄ Flammes au sol (en dessous de tout) ‚îÄ‚îÄ
      const flameCount = rageMode ? 8 : 5;
      for (let i = 0; i < flameCount; i++) {
        const fx2 = ox + (4 + i * 4) * s;
        const fh = (6 + Math.sin(f * 0.3 + i * 1.3) * 3 + fireFlick * 2) * s;
        const falpha = 0.35 + 0.25 * Math.sin(f * 0.25 + i * 0.8);
        ctx.fillStyle = `rgba(255,${60 + i * 15},0,${falpha})`;
        ctx.beginPath();
        ctx.moveTo(fx2, oy + 33 * s + bodyBob);
        ctx.lineTo(fx2 + 2 * s, oy + 33 * s - fh + bodyBob);
        ctx.lineTo(fx2 + 4 * s, oy + 33 * s + bodyBob);
        ctx.closePath(); ctx.fill();
      }

      // ‚îÄ‚îÄ Aura rage / braise ‚îÄ‚îÄ
      if (rageMode) {
        const gr = ctx.createRadialGradient(0, bodyBob, 3 * s, 0, bodyBob, 28 * s);
        gr.addColorStop(0, `rgba(255,80,0,${0.35 + 0.2 * pulse})`);
        gr.addColorStop(0.6, `rgba(200,20,0,${0.12 + 0.08 * pulse})`);
        gr.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gr;
        ctx.beginPath(); ctx.ellipse(0, bodyBob, 28 * s, 22 * s, 0, 0, Math.PI * 2); ctx.fill();
        // Particules de braise
        for (let i = 0; i < 6; i++) {
          const angle = (f * 0.04 + i * 1.047) % (Math.PI * 2);
          const r2 = (18 + Math.sin(f * 0.1 + i) * 4) * s;
          const px2 = Math.cos(angle) * r2, py2 = Math.sin(angle) * r2 * 0.6 + bodyBob;
          ctx.fillStyle = `rgba(255,${100 + i * 25},0,${0.5 + 0.3 * Math.sin(f * 0.2 + i)})`;
          ctx.fillRect(px2 - s, py2 - s, 2 * s, 2 * s);
        }
      } else {
        // braise passive
        const gr2 = ctx.createRadialGradient(0, bodyBob, 2 * s, 0, bodyBob, 20 * s);
        gr2.addColorStop(0, `rgba(200,40,0,${0.15 + 0.08 * pulse})`);
        gr2.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gr2; ctx.beginPath(); ctx.ellipse(0, bodyBob, 22 * s, 16 * s, 0, 0, Math.PI * 2); ctx.fill();
      }

      // ‚îÄ‚îÄ Corps (centr√© sur bodyBob) ‚îÄ‚îÄ
      ctx.save(); ctx.translate(0, bodyBob);

      // Ombre corps
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.fillRect(ox + 2 * s, oy + 7 * s, 20 * s, 21 * s);

      // JAMBES (anim√©es ind√©pendamment)
      // Jambe gauche
      ctx.fillStyle = '#6a0000';
      ctx.fillRect(ox + 4 * s, oy + 26 * s + legL, 6 * s, 6 * s);
      ctx.fillStyle = '#4a0000';
      ctx.fillRect(ox + 3 * s, oy + 31 * s + legL, 7 * s, 3 * s);
      // Sabot gauche avec petites flammes
      ctx.fillStyle = rageMode ? '#ff2200' : '#1a0000';
      ctx.fillRect(ox + 2 * s, oy + 33 * s + legL, 8 * s, 2 * s);
      if (rageMode) {
        ctx.fillStyle = `rgba(255,120,0,${0.6 + 0.3 * pulse})`;
        ctx.fillRect(ox + 3 * s, oy + 32 * s + legL, 2 * s, 2 * s);
        ctx.fillRect(ox + 7 * s, oy + 32 * s + legL, 2 * s, 2 * s);
      }
      // Jambe droite
      ctx.fillStyle = '#6a0000';
      ctx.fillRect(ox + 14 * s, oy + 26 * s + legR, 6 * s, 6 * s);
      ctx.fillStyle = '#4a0000';
      ctx.fillRect(ox + 13 * s, oy + 31 * s + legR, 7 * s, 3 * s);
      ctx.fillStyle = rageMode ? '#ff2200' : '#1a0000';
      ctx.fillRect(ox + 12 * s, oy + 33 * s + legR, 8 * s, 2 * s);
      if (rageMode) {
        ctx.fillStyle = `rgba(255,120,0,${0.6 + 0.3 * pulse})`;
        ctx.fillRect(ox + 13 * s, oy + 32 * s + legR, 2 * s, 2 * s);
        ctx.fillRect(ox + 17 * s, oy + 32 * s + legR, 2 * s, 2 * s);
      }

      // CORPS principal
      ctx.fillStyle = '#6a0000';
      ctx.fillRect(ox + 2 * s, oy + 16 * s, 20 * s, 11 * s);
      // Abdomen segment√©
      ctx.fillStyle = '#8b1a00';
      ctx.fillRect(ox + 4 * s, oy + 18 * s, 16 * s, 7 * s);
      // Segments abdomen anim√©s
      for (let i = 0; i < 3; i++) {
        const segAlpha = 0.4 + 0.2 * Math.sin(f * 0.12 + i * 1.2);
        ctx.fillStyle = `rgba(40,0,0,${segAlpha})`;
        ctx.fillRect(ox + 4 * s, oy + (19 + i * 2) * s, 16 * s, s);
      }
      // Lueur abdomen (lave interne)
      ctx.fillStyle = `rgba(255,${60 + 40 * pulse},0,${0.18 + 0.12 * pulse})`;
      ctx.fillRect(ox + 5 * s, oy + 19 * s, 14 * s, 5 * s);

      // √âPAULES avec lave
      const shoulderGlow = rageMode ? `rgba(255,80,0,${0.5 + 0.3 * pulse})` : `rgba(200,30,0,${0.25 + 0.15 * pulse})`;
      ctx.fillStyle = shoulderGlow;
      ctx.fillRect(ox + 0 * s, oy + 14 * s, 5 * s, 5 * s);
      ctx.fillRect(ox + 19 * s, oy + 14 * s, 5 * s, 5 * s);
      ctx.fillStyle = '#8b0000';
      ctx.fillRect(ox + 1 * s, oy + 15 * s, 3 * s, 3 * s);
      ctx.fillRect(ox + 20 * s, oy + 15 * s, 3 * s, 3 * s);

      // BRAS gauche (anim√©)
      ctx.save(); ctx.translate(ox + 2 * s, oy + 16 * s);
      ctx.rotate(armL * 0.025);
      ctx.fillStyle = '#7a0000';
      ctx.fillRect(-2 * s, 0, 4 * s, 9 * s);
      // Avant-bras
      ctx.fillStyle = '#6a0000';
      ctx.fillRect(-2 * s, 7 * s, 4 * s, 5 * s);
      // Griffes
      ctx.fillStyle = '#1a0000';
      ctx.fillRect(-2 * s, 11 * s, 2 * s, 3 * s);
      ctx.fillRect(0, 12 * s, 2 * s, 2 * s);
      ctx.fillRect(1 * s, 11 * s, 2 * s, 3 * s);
      if (rageMode) {
        ctx.fillStyle = `rgba(255,100,0,${0.5 + 0.3 * pulse})`;
        ctx.fillRect(-3 * s, 10 * s, 6 * s, 4 * s);
      }
      ctx.restore();

      // BRAS droit (anim√© miroir)
      ctx.save(); ctx.translate(ox + 22 * s, oy + 16 * s);
      ctx.rotate(armR * 0.025);
      ctx.fillStyle = '#7a0000';
      ctx.fillRect(-2 * s, 0, 4 * s, 9 * s);
      ctx.fillStyle = '#6a0000';
      ctx.fillRect(-2 * s, 7 * s, 4 * s, 5 * s);
      ctx.fillStyle = '#1a0000';
      ctx.fillRect(-2 * s, 11 * s, 2 * s, 3 * s);
      ctx.fillRect(0, 12 * s, 2 * s, 2 * s);
      ctx.fillRect(1 * s, 11 * s, 2 * s, 3 * s);
      if (rageMode) {
        ctx.fillStyle = `rgba(255,100,0,${0.5 + 0.3 * pulse})`;
        ctx.fillRect(-3 * s, 10 * s, 6 * s, 4 * s);
      }
      ctx.restore();

      // T√äTE
      // Ombre t√™te
      ctx.fillStyle = '#2a0000';
      ctx.fillRect(ox + 3 * s, oy + 3 * s, 18 * s, 4 * s);
      ctx.fillRect(ox + 2 * s, oy + 7 * s, 20 * s, 11 * s);

      // Cornes (anim√©es l√©g√®rement)
      const hornBend = Math.sin(f * 0.05) * s * 0.5;
      // Corne gauche
      ctx.fillStyle = '#1a0000';
      ctx.beginPath();
      ctx.moveTo(ox + 5 * s, oy + 7 * s);
      ctx.lineTo(ox + 2 * s + hornBend, oy + 0);
      ctx.lineTo(ox + 9 * s, oy + 7 * s);
      ctx.closePath(); ctx.fill();
      // Corne droite
      ctx.beginPath();
      ctx.moveTo(ox + 15 * s, oy + 7 * s);
      ctx.lineTo(ox + 22 * s - hornBend, oy + 0);
      ctx.lineTo(ox + 19 * s, oy + 7 * s);
      ctx.closePath(); ctx.fill();
      // Pointes cornes avec glow
      ctx.fillStyle = rageMode ? '#ff6600' : '#8b1a00';
      ctx.fillRect(ox + 2 * s, oy - s, 2 * s, 2 * s);
      ctx.fillRect(ox + 21 * s, oy - s, 2 * s, 2 * s);
      if (hornPulse > 0.25) {
        ctx.fillStyle = `rgba(255,${rageMode ? 80 : 30},0,${hornPulse})`;
        ctx.fillRect(ox + 1 * s, oy - 2 * s, 4 * s, 3 * s);
        ctx.fillRect(ox + 19 * s, oy - 2 * s, 4 * s, 3 * s);
      }

      // T√™te principale
      ctx.fillStyle = '#8b0000';
      ctx.fillRect(ox + 4 * s, oy + 7 * s, 16 * s, 10 * s);
      // Joues osseuses
      ctx.fillStyle = '#6a0000';
      ctx.fillRect(ox + 3 * s, oy + 10 * s, 3 * s, 5 * s);
      ctx.fillRect(ox + 18 * s, oy + 10 * s, 3 * s, 5 * s);
      // D√©tail front
      ctx.fillStyle = '#7a0000';
      ctx.fillRect(ox + 5 * s, oy + 7 * s, 14 * s, 3 * s);

      // YEUX (anim√©s ‚Äî clignement + glow puls√©)
      const blinkOpen = (f % 120) > 4; // cligne rapidement toutes les 2s
      const eyeH = blinkOpen ? 3 * s : s;
      const eyeY = blinkOpen ? oy + 9 * s : oy + 10 * s;
      // Fond yeux sombres
      ctx.fillStyle = '#1a0000';
      ctx.fillRect(ox + 6 * s, oy + 9 * s, 5 * s, 4 * s);
      ctx.fillRect(ox + 13 * s, oy + 9 * s, 5 * s, 4 * s);
      // Iris
      const eyeColor = rageMode ? `rgb(255,${60 + Math.floor(80 * pulse)},0)` : `rgb(220,${30 + Math.floor(40 * pulse)},0)`;
      ctx.fillStyle = eyeColor;
      ctx.fillRect(ox + 7 * s, eyeY, 4 * s, eyeH);
      ctx.fillRect(ox + 14 * s, eyeY, 4 * s, eyeH);
      // Pupilles
      if (blinkOpen) {
        ctx.fillStyle = '#000';
        ctx.fillRect(ox + 8 * s, eyeY + s, 2 * s, s);
        ctx.fillRect(ox + 15 * s, eyeY + s, 2 * s, s);
      }
      // Brillance
      ctx.fillStyle = '#fff';
      ctx.fillRect(ox + 7 * s, eyeY, s, s);
      ctx.fillRect(ox + 14 * s, eyeY, s, s);
      // Glow yeux
      const glowA = blinkOpen ? 0.35 + 0.25 * pulse : 0.1;
      ctx.fillStyle = `rgba(255,${rageMode ? 60 : 30},0,${glowA})`;
      ctx.fillRect(ox + 5 * s, oy + 8 * s, 7 * s, 6 * s);
      ctx.fillRect(ox + 12 * s, oy + 8 * s, 7 * s, 6 * s);

      // BOUCHE avec crocs
      ctx.fillStyle = '#2a0000';
      ctx.fillRect(ox + 7 * s, oy + 14 * s, 10 * s, 3 * s);
      // Lueur bouche (int√©rieur ardent)
      ctx.fillStyle = `rgba(255,${80 + 40 * pulse},0,${0.5 + 0.3 * pulse})`;
      ctx.fillRect(ox + 8 * s, oy + 15 * s, 8 * s, s);
      // Crocs
      ctx.fillStyle = '#e0d8cc';
      ctx.fillRect(ox + 7 * s, oy + 14 * s, 2 * s, 3 * s);
      ctx.fillRect(ox + 10 * s, oy + 14 * s, 2 * s, 2 * s);
      ctx.fillRect(ox + 14 * s, oy + 14 * s, 2 * s, 3 * s);
      ctx.fillRect(ox + 12 * s, oy + 14 * s, 2 * s, 2 * s);

      // Flammes bouche (rage)
      if (rageMode) {
        for (let i = 0; i < 4; i++) {
          const fh2 = (4 + Math.sin(f * 0.3 + i * 0.9) * 2 + fireFlick) * s;
          ctx.fillStyle = `rgba(255,${80 + i * 30},0,${0.7 + 0.2 * Math.sin(f * 0.4 + i)})`;
          ctx.beginPath();
          ctx.moveTo(ox + (8 + i * 2) * s, oy + 17 * s);
          ctx.lineTo(ox + (9 + i * 2) * s, oy + 17 * s - fh2);
          ctx.lineTo(ox + (10 + i * 2) * s, oy + 17 * s);
          ctx.closePath(); ctx.fill();
        }
      }

      ctx.restore(); // fin bodyBob
      ctx.restore(); // fin global
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ‚îÄ‚îÄ‚îÄ NYTHERION LE REVENANT ‚Äî Roi Fant√¥me ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function drawKingDoubt(ctx, cx, cy, dir, frame, scale = 2.2, alpha = 1, rageMode = false) {
      const s = scale;
      const f = GS.frame;
      ctx.save();
      ctx.translate(cx, cy);
      ctx.globalAlpha *= alpha;
      if (dir === 1) ctx.scale(-1, 1);

      const ox = -12 * s, oy = -18 * s;

      // Timings
      const breathe   = Math.sin(f * 0.05);
      const pulse     = (Math.sin(f * 0.14) + 1) / 2;
      const fastPulse = (Math.sin(f * 0.28) + 1) / 2;
      const capeWave  = Math.sin(f * 0.08);
      const legPhase  = (f % 36) / 36;
      const legL      = Math.sin(legPhase * Math.PI * 2) * 3 * s;
      const legR      = -legL;
      const armWave   = Math.sin(f * 0.07) * 6 * s;
      const float     = Math.sin(f * 0.055) * 1.5 * s;
      const orbSpin   = f * 0.04;

      // ‚îÄ‚îÄ Orbes orbitaux (avant tout) ‚îÄ‚îÄ
      const orbCount = rageMode ? 5 : 3;
      for (let i = 0; i < orbCount; i++) {
        const angle = orbSpin + i * (Math.PI * 2 / orbCount);
        const orR = (22 + Math.sin(f * 0.06 + i) * 3) * s;
        const orX = Math.cos(angle) * orR;
        const orY = Math.sin(angle) * orR * 0.5 + float;
        const orA = 0.5 + 0.4 * Math.sin(f * 0.15 + i);
        ctx.fillStyle = rageMode ? `rgba(255,0,255,${orA})` : `rgba(160,0,255,${orA})`;
        ctx.beginPath(); ctx.arc(orX, orY, 3 * s, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = `rgba(255,255,255,${orA * 0.6})`;
        ctx.beginPath(); ctx.arc(orX - s, orY - s, s, 0, Math.PI * 2); ctx.fill();
        // Tra√Æne de l'orbe
        for (let t = 1; t <= 3; t++) {
          const ta = angle - t * 0.15;
          const tX = Math.cos(ta) * orR;
          const tY = Math.sin(ta) * orR * 0.5 + float;
          ctx.fillStyle = rageMode ? `rgba(200,0,255,${orA * 0.3 / t})` : `rgba(120,0,220,${orA * 0.25 / t})`;
          ctx.beginPath(); ctx.arc(tX, tY, (2 - t * 0.4) * s, 0, Math.PI * 2); ctx.fill();
        }
      }

      // ‚îÄ‚îÄ Aura fant√¥me ‚îÄ‚îÄ
      const auraGr = ctx.createRadialGradient(0, float, 4 * s, 0, float, 30 * s);
      if (rageMode) {
        auraGr.addColorStop(0, `rgba(200,0,255,${0.3 + 0.2 * pulse})`);
        auraGr.addColorStop(0.5, `rgba(100,0,180,${0.12 + 0.08 * pulse})`);
      } else {
        auraGr.addColorStop(0, `rgba(80,0,160,${0.2 + 0.12 * pulse})`);
        auraGr.addColorStop(0.5, `rgba(40,0,80,${0.08 + 0.05 * pulse})`);
      }
      auraGr.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = auraGr;
      ctx.beginPath(); ctx.ellipse(0, float, 30 * s, 22 * s, 0, 0, Math.PI * 2); ctx.fill();

      ctx.save(); ctx.translate(0, float);

      // ‚îÄ‚îÄ CAPE (derri√®re corps) ‚Äî ondulante ‚îÄ‚îÄ
      const capeL = capeWave * 3 * s;
      const capeR = -capeL;
      ctx.fillStyle = rageMode ? '#5a0090' : '#1e004e';
      ctx.beginPath();
      ctx.moveTo(ox + 1 * s, oy + 16 * s);
      ctx.bezierCurveTo(
        ox - 5 * s, oy + 24 * s + capeL,
        ox - 3 * s + capeL, oy + 34 * s,
        ox + 12 * s, oy + 36 * s + capeWave * s
      );
      ctx.bezierCurveTo(
        ox + 27 * s + capeR, oy + 34 * s,
        ox + 29 * s, oy + 24 * s + capeR,
        ox + 23 * s, oy + 16 * s
      );
      ctx.closePath(); ctx.fill();
      // Bord de cape lumineux
      ctx.strokeStyle = rageMode ? '#cc00ff' : '#7700bb';
      ctx.lineWidth = s * 1.2;
      ctx.stroke();
      // Reflets cape
      ctx.fillStyle = `rgba(${rageMode ? '200,0,255' : '100,0,200'},${0.12 + 0.08 * pulse})`;
      ctx.beginPath();
      ctx.moveTo(ox + 3 * s, oy + 18 * s);
      ctx.bezierCurveTo(ox + 0, oy + 26 * s, ox + 2 * s, oy + 32 * s, ox + 7 * s, oy + 35 * s);
      ctx.bezierCurveTo(ox + 5 * s, oy + 30 * s, ox + 4 * s, oy + 24 * s, ox + 5 * s, oy + 18 * s);
      ctx.closePath(); ctx.fill();

      // JAMBES
      ctx.fillStyle = '#1a0038';
      ctx.fillRect(ox + 5 * s, oy + 28 * s + legL, 5 * s, 7 * s);
      ctx.fillRect(ox + 14 * s, oy + 28 * s + legR, 5 * s, 7 * s);
      // Bottes
      ctx.fillStyle = '#0a0020';
      ctx.fillRect(ox + 4 * s, oy + 34 * s + legL, 7 * s, 2 * s);
      ctx.fillRect(ox + 13 * s, oy + 34 * s + legR, 7 * s, 2 * s);
      // Lueur bottes
      if (rageMode) {
        ctx.fillStyle = `rgba(180,0,255,${0.4 + 0.3 * pulse})`;
        ctx.fillRect(ox + 4 * s, oy + 35 * s + legL, 7 * s, s);
        ctx.fillRect(ox + 13 * s, oy + 35 * s + legR, 7 * s, s);
      }

      // CORPS armure
      ctx.fillStyle = '#1a0a30';
      ctx.fillRect(ox + 3 * s, oy + 18 * s, 18 * s, 11 * s);
      // Plaque centrale
      ctx.fillStyle = '#2e1450';
      ctx.fillRect(ox + 5 * s, oy + 19 * s, 14 * s, 5 * s);
      ctx.fillRect(ox + 5 * s, oy + 24 * s, 14 * s, 4 * s);
      // Nervures armure anim√©es
      for (let i = 0; i < 3; i++) {
        const gv = 0.15 + 0.12 * Math.sin(f * 0.1 + i * 1.4);
        ctx.fillStyle = rageMode ? `rgba(220,0,255,${gv})` : `rgba(140,0,220,${gv})`;
        ctx.fillRect(ox + 6 * s, oy + (19 + i * 2) * s, 12 * s, s);
      }
      // Orbe pectoral central
      const orbR = (3 + Math.sin(f * 0.15) * 0.8) * s;
      const orbGr = ctx.createRadialGradient(ox + 12 * s, oy + 22 * s, 0, ox + 12 * s, oy + 22 * s, orbR);
      if (rageMode) {
        orbGr.addColorStop(0, `rgba(255,200,255,${0.9 + 0.1 * fastPulse})`);
        orbGr.addColorStop(0.4, `rgba(255,0,255,0.85)`);
        orbGr.addColorStop(1, 'rgba(100,0,180,0.4)');
      } else {
        orbGr.addColorStop(0, `rgba(200,150,255,${0.85 + 0.15 * pulse})`);
        orbGr.addColorStop(0.4, `rgba(140,0,220,0.8)`);
        orbGr.addColorStop(1, 'rgba(60,0,120,0.3)');
      }
      ctx.fillStyle = orbGr;
      ctx.beginPath(); ctx.arc(ox + 12 * s, oy + 22 * s, orbR, 0, Math.PI * 2); ctx.fill();

      // BRAS gauche (flotte et se l√®ve en combat)
      ctx.save(); ctx.translate(ox + 3 * s, oy + 18 * s);
      ctx.rotate(-0.15 + armWave * 0.012);
      ctx.fillStyle = '#2a0a40';
      ctx.fillRect(-2 * s, 0, 5 * s, 9 * s);
      // √âpauli√®re
      ctx.fillStyle = '#4a2080';
      ctx.fillRect(-3 * s, -s, 7 * s, 4 * s);
      ctx.fillStyle = rageMode ? '#cc00ff' : '#6600aa';
      ctx.fillRect(-2 * s, -s, 5 * s, 2 * s);
      // Main magique
      ctx.fillStyle = rageMode ? '#ff00ff' : '#9900cc';
      ctx.fillRect(-2 * s, 9 * s, 5 * s, 4 * s);
      // Particules mains
      if (rageMode || pulse > 0.5) {
        for (let i = 0; i < 3; i++) {
          ctx.fillStyle = `rgba(${rageMode ? '255,0,255' : '180,0,255'},${(0.4 + 0.4 * Math.sin(f * 0.2 + i)) * (rageMode ? 1 : 0.5)})`;
          const mx = (Math.sin(f * 0.15 + i * 2.1)) * 3 * s;
          const my = (Math.cos(f * 0.12 + i * 1.5)) * 2 * s;
          ctx.fillRect(mx - s, 12 * s + my, 2 * s, 2 * s);
        }
      }
      ctx.restore();

      // BRAS droit
      ctx.save(); ctx.translate(ox + 21 * s, oy + 18 * s);
      ctx.rotate(0.15 - armWave * 0.012);
      ctx.fillStyle = '#2a0a40';
      ctx.fillRect(-3 * s, 0, 5 * s, 9 * s);
      ctx.fillStyle = '#4a2080';
      ctx.fillRect(-4 * s, -s, 7 * s, 4 * s);
      ctx.fillStyle = rageMode ? '#cc00ff' : '#6600aa';
      ctx.fillRect(-3 * s, -s, 5 * s, 2 * s);
      ctx.fillStyle = rageMode ? '#ff00ff' : '#9900cc';
      ctx.fillRect(-3 * s, 9 * s, 5 * s, 4 * s);
      if (rageMode || pulse > 0.5) {
        for (let i = 0; i < 3; i++) {
          ctx.fillStyle = `rgba(${rageMode ? '255,0,255' : '180,0,255'},${(0.4 + 0.4 * Math.sin(f * 0.2 + i + 1)) * (rageMode ? 1 : 0.5)})`;
          const mx = (Math.sin(f * 0.15 + i * 2.1 + 1)) * 3 * s;
          const my = (Math.cos(f * 0.12 + i * 1.5 + 1)) * 2 * s;
          ctx.fillRect(mx - s, 12 * s + my, 2 * s, 2 * s);
        }
      }
      ctx.restore();

      // T√äTE
      // Ombre t√™te
      ctx.fillStyle = '#1a0030';
      ctx.fillRect(ox + 3 * s, oy + 4 * s, 18 * s, 16 * s);

      // COURONNE (anim√©e ‚Äî gemmes pulsantes)
      ctx.fillStyle = '#d4a800';
      ctx.fillRect(ox + 4 * s, oy + 4 * s, 16 * s, 5 * s);
      // Pointes couronne
      const crownHeights = [3, 5, 7, 5, 3];
      for (let i = 0; i < 5; i++) {
        const h = crownHeights[i] * s;
        const cx2 = ox + (4 + i * 3.2) * s;
        ctx.fillStyle = '#ffd700';
        ctx.fillRect(cx2, oy + 4 * s - h, 2.5 * s, h);
        ctx.fillStyle = '#c8a000';
        ctx.fillRect(cx2, oy + 4 * s - h, s, h * 0.6);
      }
      // Gemme centrale couronne (pulsante)
      const gemR = (2 + Math.sin(f * 0.2) * 0.5) * s;
      ctx.fillStyle = rageMode ? `rgba(255,0,255,${0.8 + 0.2 * fastPulse})` : `rgba(180,0,255,${0.75 + 0.25 * pulse})`;
      ctx.beginPath(); ctx.arc(ox + 12 * s, oy + s, gemR, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = `rgba(255,255,255,${0.6 + 0.4 * fastPulse})`;
      ctx.beginPath(); ctx.arc(ox + 11 * s, oy + 0.5 * s, gemR * 0.4, 0, Math.PI * 2); ctx.fill();
      // Gemmes lat√©rales
      ctx.fillStyle = `rgba(255,60,60,${0.7 + 0.3 * pulse})`;
      ctx.fillRect(ox + 7 * s, oy + 2 * s, 2 * s, 2 * s);
      ctx.fillRect(ox + 15 * s, oy + 2 * s, 2 * s, 2 * s);

      // T√™te principale
      ctx.fillStyle = '#280a35';
      ctx.fillRect(ox + 4 * s, oy + 9 * s, 16 * s, 10 * s);
      // Masque fant√¥me
      ctx.fillStyle = '#1c0028';
      ctx.fillRect(ox + 6 * s, oy + 10 * s, 12 * s, 6 * s);

      // YEUX (portail spectral, anim√©s)
      const blinkKing = (f % 150) > 5;
      const eyeGlowR = rageMode ? `rgba(255,0,255,${0.5 + 0.4 * pulse})` : `rgba(160,0,255,${0.4 + 0.3 * pulse})`;
      // Halo yeux
      ctx.fillStyle = eyeGlowR;
      ctx.fillRect(ox + 6 * s, oy + 10 * s, 5 * s, 5 * s);
      ctx.fillRect(ox + 13 * s, oy + 10 * s, 5 * s, 5 * s);
      // Yeux
      const eyeKingH = blinkKing ? 3 * s : s * 0.8;
      const eyeKingColor = rageMode
        ? `rgb(255,${60 + Math.floor(100 * fastPulse)},255)`
        : `rgb(${160 + Math.floor(60 * pulse)},0,${200 + Math.floor(55 * pulse)})`;
      ctx.fillStyle = eyeKingColor;
      ctx.fillRect(ox + 7 * s, oy + 11 * s, 4 * s, eyeKingH);
      ctx.fillRect(ox + 14 * s, oy + 11 * s, 4 * s, eyeKingH);
      // Pupilles portail
      if (blinkKing) {
        ctx.fillStyle = '#000';
        ctx.fillRect(ox + 8 * s, oy + 12 * s, 2 * s, s);
        ctx.fillRect(ox + 15 * s, oy + 12 * s, 2 * s, s);
        // √âtoile dans l'≈ìil
        ctx.fillStyle = `rgba(255,255,255,${0.8 + 0.2 * fastPulse})`;
        ctx.fillRect(ox + 7 * s, oy + 11 * s, s, s);
        ctx.fillRect(ox + 14 * s, oy + 11 * s, s, s);
      }

      // Bouche royale
      ctx.fillStyle = '#0a0018';
      ctx.fillRect(ox + 7 * s, oy + 16 * s, 10 * s, 2 * s);
      // Lueur bouche magie
      ctx.fillStyle = `rgba(${rageMode ? '255,0,255' : '120,0,200'},${0.4 + 0.3 * pulse})`;
      ctx.fillRect(ox + 8 * s, oy + 16 * s, 8 * s, s);
      // Dents spectrales
      ctx.fillStyle = `rgba(200,150,255,${0.5 + 0.3 * pulse})`;
      ctx.fillRect(ox + 7 * s, oy + 15 * s, 2 * s, 2 * s);
      ctx.fillRect(ox + 10 * s, oy + 15 * s, 2 * s, 2 * s);
      ctx.fillRect(ox + 14 * s, oy + 15 * s, 2 * s, 2 * s);

      // Brume fant√¥me autour de la t√™te
      for (let i = 0; i < 4; i++) {
        const angle2 = f * 0.03 + i * 1.57;
        const bx = Math.cos(angle2) * (14 + i * 2) * s + ox + 12 * s;
        const by = Math.sin(angle2) * 6 * s + oy + 12 * s;
        ctx.fillStyle = `rgba(${rageMode ? '200,0,255' : '80,0,160'},${0.08 + 0.06 * Math.sin(f * 0.1 + i)})`;
        ctx.beginPath(); ctx.arc(bx, by, (3 + i) * s, 0, Math.PI * 2); ctx.fill();
      }

      ctx.restore(); // float
      ctx.restore();
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ‚îÄ‚îÄ‚îÄ THYRAX LE SOUFFLE NOIR ‚Äî Dragon du Temps ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function drawDragon(ctx, cx, cy, dir, frame, scale = 2.5, alpha = 1, rageMode = false, aerialYOff = 0) {
      const s = scale;
      const f = GS.frame;
      ctx.save();
      ctx.translate(cx, cy + (aerialYOff || 0));
      ctx.globalAlpha *= alpha;
      if (dir === 1) ctx.scale(-1, 1);

      const ox = -18 * s, oy = -18 * s;

      // Timings
      const breathe    = Math.sin(f * 0.055);
      const pulse      = (Math.sin(f * 0.13) + 1) / 2;
      const fastPulse  = (Math.sin(f * 0.24) + 1) / 2;
      const legPhase   = (f % 28) / 28;
      const legL       = Math.sin(legPhase * Math.PI * 2) * 5 * s;
      const legR       = -legL;
      const bodyBreath = breathe * 1.5 * s;
      const tailWave   = Math.sin(f * 0.07);
      const tailWave2  = Math.sin(f * 0.07 + 0.8);

      // ‚îÄ‚îÄ Aile : battement ‚îÄ‚îÄ
      const wFlap = (aerialYOff < -20)
        ? Math.sin(f * 0.35) * 12 * s           // vol rapide
        : Math.sin(f * 0.1) * 5 * s;            // aile lente au sol

      // ‚îÄ‚îÄ Particules temporelles (autour du dragon) ‚îÄ‚îÄ
      const partCount = rageMode ? 10 : 6;
      for (let i = 0; i < partCount; i++) {
        const angle = f * 0.035 + i * (Math.PI * 2 / partCount);
        const r2 = (26 + Math.sin(f * 0.07 + i) * 6) * s;
        const px2 = Math.cos(angle) * r2;
        const py2 = Math.sin(angle) * r2 * 0.45 + bodyBreath;
        const pA = 0.4 + 0.35 * Math.sin(f * 0.12 + i * 1.3);
        ctx.fillStyle = rageMode
          ? `rgba(255,${80 + i * 15},0,${pA})`
          : `rgba(${20 + i * 20},${160 + i * 8},255,${pA})`;
        ctx.beginPath(); ctx.arc(px2, py2, (2 + Math.sin(f * 0.1 + i) * 0.8) * s, 0, Math.PI * 2); ctx.fill();
        // Tra√Æne particule
        const ta = angle - 0.2;
        ctx.fillStyle = rageMode ? `rgba(220,60,0,${pA * 0.4})` : `rgba(0,100,255,${pA * 0.35})`;
        ctx.beginPath(); ctx.arc(Math.cos(ta) * r2, Math.sin(ta) * r2 * 0.45 + bodyBreath, s, 0, Math.PI * 2); ctx.fill();
      }

      // ‚îÄ‚îÄ Aura temporelle ‚îÄ‚îÄ
      const auraGr = ctx.createRadialGradient(0, bodyBreath, 5 * s, 0, bodyBreath, 38 * s);
      if (rageMode) {
        auraGr.addColorStop(0, `rgba(255,100,0,${0.28 + 0.18 * pulse})`);
        auraGr.addColorStop(0.5, `rgba(200,40,0,${0.1 + 0.07 * pulse})`);
      } else {
        auraGr.addColorStop(0, `rgba(60,160,255,${0.18 + 0.12 * pulse})`);
        auraGr.addColorStop(0.5, `rgba(20,80,200,${0.07 + 0.05 * pulse})`);
      }
      auraGr.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = auraGr;
      ctx.beginPath(); ctx.ellipse(0, bodyBreath, 38 * s, 24 * s, 0, 0, Math.PI * 2); ctx.fill();

      ctx.save(); ctx.translate(0, bodyBreath);

      // ‚îÄ‚îÄ QUEUE (ondulante) ‚îÄ‚îÄ
      const qCol = rageMode ? '#7a1800' : '#102848';
      ctx.fillStyle = qCol;
      ctx.beginPath();
      ctx.moveTo(ox + 24 * s, oy + 24 * s);
      ctx.bezierCurveTo(
        ox + 32 * s, oy + 28 * s + tailWave * 4 * s,
        ox + 38 * s, oy + 22 * s + tailWave2 * 4 * s,
        ox + 42 * s, oy + 16 * s + tailWave * 6 * s
      );
      ctx.bezierCurveTo(
        ox + 40 * s, oy + 16 * s + tailWave * 6 * s,
        ox + 36 * s, oy + 22 * s + tailWave2 * 3 * s,
        ox + 30 * s, oy + 26 * s + tailWave * 3 * s
      );
      ctx.closePath(); ctx.fill();
      // Pointe queue
      ctx.fillStyle = rageMode ? '#ff4400' : '#4090d0';
      ctx.beginPath();
      ctx.moveTo(ox + 42 * s, oy + 16 * s + tailWave * 6 * s);
      ctx.lineTo(ox + 46 * s, oy + 10 * s + tailWave * 8 * s);
      ctx.lineTo(ox + 43 * s, oy + 16 * s + tailWave * 6 * s);
      ctx.closePath(); ctx.fill();
      // Segments queue
      for (let i = 0; i < 4; i++) {
        const t2 = i / 4;
        const qx = ox + (24 + i * 4.5) * s;
        const qy = oy + (25 + i * 0.5) * s + tailWave * i * 1.5 * s;
        ctx.fillStyle = rageMode ? `rgba(160,30,0,0.6)` : `rgba(30,80,160,0.5)`;
        ctx.fillRect(qx, qy, 3 * s, 2 * s);
      }

      // ‚îÄ‚îÄ AILES (derri√®re le corps) ‚îÄ‚îÄ
      const wingMainCol = rageMode ? '#8b2000' : '#1a3870';
      const wingMemCol  = rageMode ? 'rgba(180,50,0,0.55)' : 'rgba(40,90,160,0.55)';

      // Aile gauche
      ctx.fillStyle = wingMainCol;
      ctx.beginPath();
      ctx.moveTo(ox + 14 * s, oy + 14 * s);
      ctx.lineTo(ox - 8 * s, oy + 8 * s + wFlap);
      ctx.lineTo(ox - 2 * s, oy + 2 * s + wFlap * 1.2);
      ctx.lineTo(ox + 2 * s, oy - 4 * s + wFlap * 0.6);
      ctx.lineTo(ox + 6 * s, oy + 6 * s + wFlap * 0.4);
      ctx.lineTo(ox + 10 * s, oy + 8 * s + wFlap * 0.2);
      ctx.lineTo(ox + 14 * s, oy + 12 * s);
      ctx.closePath(); ctx.fill();
      // Nervures aile gauche
      ctx.strokeStyle = rageMode ? 'rgba(255,80,0,0.5)' : 'rgba(80,140,255,0.45)';
      ctx.lineWidth = s * 0.9;
      for (let i = 0; i < 3; i++) {
        const nx = ox + (14 - i * 4) * s;
        const ny = oy + (14 - i * 2) * s;
        const ex = ox + (-6 + i * 3) * s;
        const ey = oy + (9 + wFlap * (1 - i * 0.3));
        ctx.beginPath(); ctx.moveTo(nx, ny); ctx.lineTo(ex, ey); ctx.stroke();
      }
      // Membrane aile gauche
      ctx.fillStyle = wingMemCol;
      ctx.beginPath();
      ctx.moveTo(ox + 12 * s, oy + 13 * s);
      ctx.lineTo(ox - 6 * s, oy + 9 * s + wFlap);
      ctx.lineTo(ox + 0, oy + 4 * s + wFlap * 1.1);
      ctx.lineTo(ox + 8 * s, oy + 9 * s + wFlap * 0.3);
      ctx.closePath(); ctx.fill();

      // Aile droite
      ctx.fillStyle = wingMainCol;
      ctx.beginPath();
      ctx.moveTo(ox + 22 * s, oy + 14 * s);
      ctx.lineTo(ox + 44 * s, oy + 8 * s + wFlap);
      ctx.lineTo(ox + 38 * s, oy + 2 * s + wFlap * 1.2);
      ctx.lineTo(ox + 34 * s, oy - 4 * s + wFlap * 0.6);
      ctx.lineTo(ox + 30 * s, oy + 6 * s + wFlap * 0.4);
      ctx.lineTo(ox + 26 * s, oy + 8 * s + wFlap * 0.2);
      ctx.lineTo(ox + 22 * s, oy + 12 * s);
      ctx.closePath(); ctx.fill();
      // Nervures aile droite
      for (let i = 0; i < 3; i++) {
        const nx = ox + (22 + i * 4) * s;
        const ny = oy + (14 - i * 2) * s;
        const ex = ox + (42 - i * 3) * s;
        const ey = oy + (9 + wFlap * (1 - i * 0.3));
        ctx.beginPath(); ctx.moveTo(nx, ny); ctx.lineTo(ex, ey); ctx.stroke();
      }
      ctx.fillStyle = wingMemCol;
      ctx.beginPath();
      ctx.moveTo(ox + 24 * s, oy + 13 * s);
      ctx.lineTo(ox + 42 * s, oy + 9 * s + wFlap);
      ctx.lineTo(ox + 36 * s, oy + 4 * s + wFlap * 1.1);
      ctx.lineTo(ox + 28 * s, oy + 9 * s + wFlap * 0.3);
      ctx.closePath(); ctx.fill();

      // ‚îÄ‚îÄ CORPS principal ‚îÄ‚îÄ
      ctx.fillStyle = rageMode ? '#6a0000' : '#0d2848';
      ctx.fillRect(ox + 8 * s, oy + 12 * s, 20 * s, 16 * s);
      // Dos / √©cailles
      ctx.fillStyle = rageMode ? '#8b1000' : '#1a4070';
      ctx.fillRect(ox + 9 * s, oy + 12 * s, 18 * s, 5 * s);
      // Ventre
      ctx.fillStyle = rageMode ? '#cc3300' : '#1a5090';
      ctx.fillRect(ox + 10 * s, oy + 19 * s, 16 * s, 7 * s);
      // Plaques ventre anim√©es
      for (let i = 0; i < 4; i++) {
        const gv = 0.3 + 0.2 * Math.sin(f * 0.1 + i * 1.1);
        ctx.fillStyle = rageMode ? `rgba(40,0,0,${gv})` : `rgba(0,30,60,${gv})`;
        ctx.fillRect(ox + (10 + i * 4) * s, oy + 20 * s, 3 * s, 5 * s);
      }
      // Cr√™te dorsale (√©pines anim√©es)
      const creteCol = rageMode ? '#ff4400' : '#40a0ff';
      for (let i = 0; i < 5; i++) {
        const h = (4 + Math.sin(f * 0.08 + i * 0.8) * 1.5) * s;
        const bx2 = ox + (10 + i * 3.5) * s;
        ctx.fillStyle = creteCol;
        ctx.beginPath();
        ctx.moveTo(bx2, oy + 12 * s);
        ctx.lineTo(bx2 + 1.5 * s, oy + 12 * s - h);
        ctx.lineTo(bx2 + 3 * s, oy + 12 * s);
        ctx.closePath(); ctx.fill();
        ctx.fillStyle = `rgba(255,255,255,${0.3 + 0.2 * Math.sin(f * 0.12 + i)})`;
        ctx.fillRect(bx2 + 0.5 * s, oy + 12 * s - h, s, h * 0.4);
      }

      // PATTES avant
      ctx.fillStyle = rageMode ? '#6a0000' : '#0d2848';
      ctx.fillRect(ox + 8 * s, oy + 24 * s + legL, 6 * s, 8 * s);
      ctx.fillRect(ox + 18 * s, oy + 24 * s + legR, 6 * s, 8 * s);
      // Griffes
      const clawCol = rageMode ? '#cc3300' : '#4080c0';
      for (let i = 0; i < 3; i++) {
        ctx.fillStyle = '#aaa';
        ctx.fillRect(ox + (8 + i * 2) * s, oy + 31 * s + legL, 2 * s, 4 * s);
        ctx.fillRect(ox + (18 + i * 2) * s, oy + 31 * s + legR, 2 * s, 4 * s);
        // Base griffes color√©e
        ctx.fillStyle = clawCol;
        ctx.fillRect(ox + (8 + i * 2) * s, oy + 31 * s + legL, 2 * s, s);
        ctx.fillRect(ox + (18 + i * 2) * s, oy + 31 * s + legR, 2 * s, s);
      }

      // ‚îÄ‚îÄ COU ‚îÄ‚îÄ
      ctx.fillStyle = rageMode ? '#7a0000' : '#0f2a50';
      ctx.fillRect(ox + 4 * s, oy + 8 * s, 12 * s, 8 * s);
      // √âcailles cou
      ctx.fillStyle = rageMode ? '#9b1000' : '#1a3a60';
      for (let i = 0; i < 3; i++) {
        ctx.fillRect(ox + (4 + i * 3.5) * s, oy + 8 * s, 3 * s, 3 * s);
      }

      // ‚îÄ‚îÄ T√äTE ‚îÄ‚îÄ
      ctx.fillStyle = rageMode ? '#9b0000' : '#152840';
      ctx.fillRect(ox - 2 * s, oy + 2 * s, 18 * s, 12 * s);
      // Cr√¢ne
      ctx.fillStyle = rageMode ? '#7a0000' : '#0d2030';
      ctx.fillRect(ox - 2 * s, oy + 2 * s, 18 * s, 6 * s);

      // CORNES de t√™te (anim√©es)
      const hornAng = Math.sin(f * 0.04) * 0.06;
      ctx.save(); ctx.translate(ox + 0, oy + 2 * s);
      ctx.rotate(-hornAng);
      ctx.fillStyle = rageMode ? '#cc3300' : '#2060a0';
      ctx.beginPath();
      ctx.moveTo(0, 0); ctx.lineTo(-3 * s, -10 * s); ctx.lineTo(3 * s, 0);
      ctx.closePath(); ctx.fill();
      ctx.fillStyle = rageMode ? '#ff6600' : '#60b0ff';
      ctx.fillRect(-s, -10 * s, 2 * s, 2 * s);
      ctx.restore();
      ctx.save(); ctx.translate(ox + 14 * s, oy + 2 * s);
      ctx.rotate(hornAng);
      ctx.fillStyle = rageMode ? '#cc3300' : '#2060a0';
      ctx.beginPath();
      ctx.moveTo(0, 0); ctx.lineTo(3 * s, -10 * s); ctx.lineTo(-3 * s, 0);
      ctx.closePath(); ctx.fill();
      ctx.fillStyle = rageMode ? '#ff6600' : '#60b0ff';
      ctx.fillRect(-s, -10 * s, 2 * s, 2 * s);
      ctx.restore();

      // YEUX dragon (fendus, pulsants)
      const blinkDragon = (f % 110) > 4;
      // Halo
      ctx.fillStyle = rageMode ? `rgba(255,120,0,${0.5 + 0.4 * pulse})` : `rgba(0,180,255,${0.45 + 0.35 * pulse})`;
      ctx.fillRect(ox + 0, oy + 4 * s, 6 * s, 5 * s);
      ctx.fillRect(ox + 8 * s, oy + 4 * s, 6 * s, 5 * s);
      // Iris
      const dragonEyeH = blinkDragon ? 4 * s : s;
      ctx.fillStyle = rageMode ? `rgb(255,${80 + Math.floor(80 * fastPulse)},0)` : `rgb(0,${180 + Math.floor(75 * pulse)},255)`;
      ctx.fillRect(ox + s, oy + 5 * s, 4 * s, dragonEyeH);
      ctx.fillRect(ox + 9 * s, oy + 5 * s, 4 * s, dragonEyeH);
      // Pupille verticale
      if (blinkDragon) {
        ctx.fillStyle = '#000';
        ctx.fillRect(ox + 2 * s, oy + 5 * s, 2 * s, 4 * s);
        ctx.fillRect(ox + 10 * s, oy + 5 * s, 2 * s, 4 * s);
        // Reflet
        ctx.fillStyle = 'rgba(255,255,255,0.7)';
        ctx.fillRect(ox + s, oy + 5 * s, s, s);
        ctx.fillRect(ox + 9 * s, oy + 5 * s, s, s);
      }

      // GUEULE (m√¢choire anim√©e l√©g√®rement)
      const mawOpen = rageMode ? 2 + Math.sin(f * 0.15) * 1.5 : 1;
      ctx.fillStyle = rageMode ? '#7a0000' : '#0d2030';
      ctx.fillRect(ox - 2 * s, oy + (11 + mawOpen) * s, 14 * s, 4 * s);
      // Lueur gueule
      ctx.fillStyle = rageMode
        ? `rgba(255,${80 + 60 * pulse},0,${0.6 + 0.3 * pulse})`
        : `rgba(0,150,255,${0.35 + 0.2 * pulse})`;
      ctx.fillRect(ox - s, oy + (12 + mawOpen) * s, 12 * s, 2 * s);
      // Crocs
      ctx.fillStyle = '#e8e4d8';
      for (let i = 0; i < 5; i++) {
        ctx.fillRect(ox + (i * 2.5 - 1) * s, oy + (11 + mawOpen) * s, 2 * s, 3 * s);
      }

      // Flamme / souffle (rage)
      if (rageMode) {
        for (let i = 0; i < 6; i++) {
          const fh3 = (5 + Math.sin(f * 0.35 + i * 0.9) * 3) * s;
          const fw3 = (3 + Math.sin(f * 0.2 + i * 1.1)) * s;
          const fx3 = ox + (i * 2.2 - 2) * s;
          ctx.fillStyle = `rgba(255,${50 + i * 30},0,${0.7 + 0.2 * Math.sin(f * 0.4 + i)})`;
          ctx.beginPath();
          ctx.moveTo(fx3, oy + (12 + mawOpen) * s);
          ctx.lineTo(fx3 + fw3 * 0.5, oy + (12 + mawOpen) * s - fh3);
          ctx.lineTo(fx3 + fw3, oy + (12 + mawOpen) * s);
          ctx.closePath(); ctx.fill();
        }
      }

      // Narines
      ctx.fillStyle = rageMode ? '#ff3300' : '#003060';
      ctx.fillRect(ox + s, oy + 9 * s, 2 * s, 2 * s);
      ctx.fillRect(ox + 5 * s, oy + 9 * s, 2 * s, 2 * s);

      ctx.restore(); // bodyBreath
      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ SQUELETTE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawSkeleton(ctx, cx, cy, dir, frame, scale = 1.8, alpha = 1) {
      const s = scale; ctx.save(); ctx.translate(cx, cy); ctx.globalAlpha *= alpha;
      if (dir < 0) { ctx.scale(-1, 1); }
      const ox = -7 * s, oy = -12 * s;
      const legOff = frame === 0 ? 0 : frame === 1 ? -s : s;
      // Os cr√¢ne
      ctx.fillStyle = '#e8e0c8';
      ctx.fillRect(ox + 2 * s, oy + 0 * s, 10 * s, 8 * s);
      ctx.fillRect(ox + 1 * s, oy + 2 * s, 12 * s, 6 * s);
      // Yeux noirs
      ctx.fillStyle = '#000';
      ctx.fillRect(ox + 3 * s, oy + 2 * s, 3 * s, 3 * s);
      ctx.fillRect(ox + 8 * s, oy + 2 * s, 3 * s, 3 * s);
      // Nez
      ctx.fillRect(ox + 6 * s, oy + 5 * s, 2 * s, s);
      // Dents
      ctx.fillStyle = '#e8e0c8';
      ctx.fillRect(ox + 3 * s, oy + 7 * s, 8 * s, 2 * s);
      ctx.fillStyle = '#222';
      for (let i = 0; i < 3; i++) ctx.fillRect(ox + (4 + i * 2) * s, oy + 7 * s, s, 2 * s);
      // Colonne
      ctx.fillStyle = '#d4ccb0';
      for (let i = 0; i < 3; i++) ctx.fillRect(ox + 6 * s, oy + (9 + i * 2) * s, 2 * s, s);
      // C√¥tes
      ctx.strokeStyle = '#d4ccb0'; ctx.lineWidth = s * 0.7;
      for (let i = 0; i < 2; i++) {
        ctx.beginPath(); ctx.moveTo(ox + 6 * s, oy + (10 + i * 2) * s); ctx.lineTo(ox + 2 * s, oy + (11 + i * 2) * s); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(ox + 8 * s, oy + (10 + i * 2) * s); ctx.lineTo(ox + 12 * s, oy + (11 + i * 2) * s); ctx.stroke();
      }
      // Bras
      ctx.fillStyle = '#d4ccb0';
      ctx.fillRect(ox + 0 * s, oy + 9 * s, 2 * s, 6 * s);
      ctx.fillRect(ox + 12 * s, oy + 9 * s, 2 * s, 6 * s);
      // Mains
      ctx.fillRect(ox - s, oy + 14 * s, 3 * s, 2 * s);
      ctx.fillRect(ox + 12 * s, oy + 14 * s, 3 * s, 2 * s);
      // Jambes
      ctx.fillRect(ox + 3 * s, oy + 17 * s + legOff, 2 * s, 5 * s);
      ctx.fillRect(ox + 9 * s, oy + 17 * s - legOff, 2 * s, 5 * s);
      // Pieds
      ctx.fillRect(ox + 2 * s, oy + 21 * s + legOff, 4 * s, s);
      ctx.fillRect(ox + 8 * s, oy + 21 * s - legOff, 4 * s, s);
      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ ZOMBIE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawZombie(ctx, cx, cy, dir, frame, scale = 1.8, alpha = 1) {
      const s = scale; ctx.save(); ctx.translate(cx, cy); ctx.globalAlpha *= alpha;
      if (dir < 0) { ctx.scale(-1, 1); }
      const ox = -8 * s, oy = -13 * s;
      const legOff = frame === 1 ? -s : frame === 2 ? s : 0;
      // Corps
      ctx.fillStyle = '#3a6a2a';
      ctx.fillRect(ox + 2 * s, oy + 9 * s, 12 * s, 10 * s);
      // D√©chirures
      ctx.fillStyle = '#2a5020';
      ctx.fillRect(ox + 4 * s, oy + 10 * s, 2 * s, 5 * s);
      ctx.fillRect(ox + 10 * s, oy + 12 * s, 2 * s, 4 * s);
      // T√™te
      ctx.fillStyle = '#4a7a38';
      ctx.fillRect(ox + 3 * s, oy + 1 * s, 10 * s, 9 * s);
      // Plaie
      ctx.fillStyle = '#8b0000';
      ctx.fillRect(ox + 5 * s, oy + 4 * s, 6 * s, 2 * s);
      // Yeux jaunes
      ctx.fillStyle = '#aaff00';
      ctx.fillRect(ox + 4 * s, oy + 2 * s, 3 * s, 3 * s);
      ctx.fillRect(ox + 9 * s, oy + 2 * s, 3 * s, 3 * s);
      ctx.fillStyle = '#000';
      ctx.fillRect(ox + 5 * s, oy + 3 * s, s, s);
      ctx.fillRect(ox + 10 * s, oy + 3 * s, s, s);
      // Bouche
      ctx.fillStyle = '#1a0000';
      ctx.fillRect(ox + 4 * s, oy + 7 * s, 8 * s, 2 * s);
      ctx.fillStyle = '#cc2200'; ctx.fillRect(ox + 6 * s, oy + 7 * s, 4 * s, s);
      // Bras tendus (zombie!)
      ctx.fillStyle = '#3a6a2a';
      ctx.fillRect(ox - 2 * s, oy + 9 * s, 4 * s, 3 * s); // bras gauche tendu
      ctx.fillRect(ox + 14 * s, oy + 8 * s, 4 * s, 3 * s);// bras droit tendu
      ctx.fillRect(ox - 4 * s, oy + 10 * s, 3 * s, s);   // main g
      ctx.fillRect(ox + 16 * s, oy + 9 * s, 3 * s, s);   // main d
      // Jambes lentes
      ctx.fillStyle = '#2a5020';
      ctx.fillRect(ox + 3 * s, oy + 19 * s + legOff, 4 * s, 4 * s);
      ctx.fillRect(ox + 9 * s, oy + 19 * s - legOff, 4 * s, 4 * s);
      ctx.fillStyle = '#1a3010';
      ctx.fillRect(ox + 2 * s, oy + 22 * s + legOff, 5 * s, 2 * s);
      ctx.fillRect(ox + 8 * s, oy + 22 * s - legOff, 5 * s, 2 * s);
      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ FANT√îME ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawGhost(ctx, cx, cy, frame, scale = 1.7, alpha = 1) {
      const s = scale; ctx.save(); ctx.translate(cx, cy); ctx.globalAlpha *= alpha;
      const ox = -7 * s, oy = -11 * s;
      const float = Math.sin(GS.frame * 0.08) * 3;
      const pulse = (Math.sin(GS.frame * 0.12) + 1) / 2;
      // Corps translucide
      ctx.fillStyle = `rgba(180,200,255,${0.65 + 0.15 * pulse})`;
      ctx.beginPath();
      ctx.arc(ox + 7 * s, oy + 6 * s + float, 7 * s, Math.PI, 0);
      ctx.lineTo(ox + 14 * s, oy + 14 * s + float);
      // bord ondul√© bas
      for (let i = 0; i < 3; i++) {
        ctx.lineTo(ox + (12 - i * 4) * s, oy + (12 + i % 2 * 3) * s + float);
      }
      ctx.lineTo(ox + 0 * s, oy + 14 * s + float);
      ctx.closePath(); ctx.fill();
      // Yeux
      ctx.fillStyle = `rgba(40,0,120,${0.9})`;
      ctx.fillRect(ox + 3 * s, oy + 4 * s + float, 3 * s, 4 * s);
      ctx.fillRect(ox + 8 * s, oy + 4 * s + float, 3 * s, 4 * s);
      // reflet yeux
      ctx.fillStyle = `rgba(150,150,255,0.8)`;
      ctx.fillRect(ox + 3 * s, oy + 4 * s + float, s, s);
      ctx.fillRect(ox + 8 * s, oy + 4 * s + float, s, s);
      // Bouche
      ctx.fillStyle = `rgba(40,0,120,0.7)`;
      ctx.fillRect(ox + 4 * s, oy + 9 * s + float, 6 * s, 2 * s);
      // tra√Æn√© fant√¥me
      ctx.fillStyle = `rgba(180,200,255,${0.12 * pulse})`;
      ctx.fillRect(ox + 2 * s, oy + 14 * s + float, 10 * s, 4 * s);
      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ CHEVALIER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawKnight(ctx, cx, cy, dir, frame, scale = 1.8, alpha = 1) {
      const s = scale; ctx.save(); ctx.translate(cx, cy); ctx.globalAlpha *= alpha;
      if (dir < 0) ctx.scale(-1, 1);
      const ox = -8 * s, oy = -14 * s;
      const legOff = frame === 1 ? -s : frame === 2 ? s : 0;
      // Bouclier
      ctx.fillStyle = '#c8a020';
      ctx.fillRect(ox - 2 * s, oy + 9 * s, 5 * s, 8 * s);
      ctx.fillStyle = '#8b5e00'; ctx.fillRect(ox - s, oy + 10 * s, 3 * s, 6 * s);
      ctx.fillStyle = '#ffd700'; ctx.fillRect(ox, oy + 12 * s, s, 2 * s);
      // Corps armure
      ctx.fillStyle = '#888888';
      ctx.fillRect(ox + 3 * s, oy + 8 * s, 12 * s, 12 * s);
      ctx.fillStyle = '#aaaaaa'; ctx.fillRect(ox + 4 * s, oy + 9 * s, 10 * s, 5 * s);
      // D√©tails armure
      ctx.fillStyle = '#666'; ctx.fillRect(ox + 4 * s, oy + 13 * s, 10 * s, s);
      ctx.fillStyle = '#c8a020'; ctx.fillRect(ox + 8 * s, oy + 10 * s, 2 * s, 3 * s);
      // Casque
      ctx.fillStyle = '#777';
      ctx.fillRect(ox + 3 * s, oy + 1 * s, 12 * s, 8 * s);
      ctx.fillStyle = '#999'; ctx.fillRect(ox + 4 * s, oy + 2 * s, 10 * s, 4 * s);
      // Visi√®re
      ctx.fillStyle = '#333'; ctx.fillRect(ox + 5 * s, oy + 5 * s, 8 * s, 3 * s);
      // Yeux (fente)
      ctx.fillStyle = '#ff6600';
      ctx.fillRect(ox + 5 * s, oy + 5 * s, 3 * s, s);
      ctx.fillRect(ox + 10 * s, oy + 5 * s, 3 * s, s);
      // Plumet
      ctx.fillStyle = '#cc0000';
      ctx.fillRect(ox + 7 * s, oy - 2 * s, 4 * s, 4 * s);
      ctx.fillRect(ox + 8 * s, oy - 4 * s, 2 * s, 3 * s);
      // Bras + √©p√©e
      ctx.fillStyle = '#777';
      ctx.fillRect(ox + 15 * s, oy + 8 * s, 3 * s, 6 * s);
      // √âp√©e
      ctx.fillStyle = '#ccc'; ctx.fillRect(ox + 17 * s, oy + 2 * s, 2 * s, 10 * s);
      ctx.fillStyle = '#c8a020'; ctx.fillRect(ox + 15 * s, oy + 8 * s, 6 * s, 2 * s);
      ctx.fillStyle = '#888'; ctx.fillRect(ox + 17 * s, oy + 11 * s, 2 * s, s);
      // Jambes
      ctx.fillStyle = '#666';
      ctx.fillRect(ox + 4 * s, oy + 20 * s + legOff, 4 * s, 5 * s);
      ctx.fillRect(ox + 10 * s, oy + 20 * s - legOff, 4 * s, 5 * s);
      ctx.fillStyle = '#444';
      ctx.fillRect(ox + 3 * s, oy + 24 * s + legOff, 5 * s, 2 * s);
      ctx.fillRect(ox + 9 * s, oy + 24 * s - legOff, 5 * s, 2 * s);
      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ G√âANT DE GLACE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawIceGiant(ctx, cx, cy, dir, frame, scale = 2.0, alpha = 1) {
      const s = scale; ctx.save(); ctx.translate(cx, cy); ctx.globalAlpha *= alpha;
      if (dir < 0) ctx.scale(-1, 1);
      const ox = -11 * s, oy = -16 * s;
      const legOff = frame === 1 ? -s * 1.5 : frame === 2 ? s * 1.5 : 0;
      const pulse = (Math.sin(GS.frame * 0.08) + 1) / 2;
      // Aura glace
      ctx.fillStyle = `rgba(100,200,255,${0.1 + 0.08 * pulse})`;
      ctx.beginPath(); ctx.ellipse(0, 4 * s, 18 * s, 10 * s, 0, 0, Math.PI * 2); ctx.fill();
      // Corps massif glace
      ctx.fillStyle = '#4488cc';
      ctx.fillRect(ox + 3 * s, oy + 10 * s, 16 * s, 16 * s);
      // Cristaux dos
      ctx.fillStyle = '#88ccff';
      ctx.fillRect(ox + 5 * s, oy + 10 * s, 12 * s, 3 * s);
      // Ventre
      ctx.fillStyle = '#66aaee';
      ctx.fillRect(ox + 5 * s, oy + 16 * s, 12 * s, 7 * s);
      // Craquelures glace
      ctx.strokeStyle = '#aaddff'; ctx.lineWidth = s * 0.5;
      ctx.beginPath(); ctx.moveTo(ox + 6 * s, oy + 14 * s); ctx.lineTo(ox + 10 * s, oy + 20 * s); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(ox + 14 * s, oy + 13 * s); ctx.lineTo(ox + 11 * s, oy + 19 * s); ctx.stroke();
      // Cristaux √©paules
      ctx.fillStyle = '#aaddff';
      ctx.beginPath(); ctx.moveTo(ox + 2 * s, oy + 10 * s); ctx.lineTo(ox, oy + 6 * s); ctx.lineTo(ox + 4 * s, oy + 10 * s); ctx.closePath(); ctx.fill();
      ctx.beginPath(); ctx.moveTo(ox + 18 * s, oy + 10 * s); ctx.lineTo(ox + 22 * s, oy + 6 * s); ctx.lineTo(ox + 20 * s, oy + 10 * s); ctx.closePath(); ctx.fill();
      // Bras
      ctx.fillStyle = '#3377bb';
      ctx.fillRect(ox + 0 * s, oy + 10 * s, 4 * s, 10 * s);
      ctx.fillRect(ox + 18 * s, oy + 10 * s, 4 * s, 10 * s);
      // Poings
      ctx.fillStyle = '#4488cc'; ctx.fillRect(ox - s, oy + 19 * s, 5 * s, 4 * s);
      ctx.fillStyle = '#4488cc'; ctx.fillRect(ox + 18 * s, oy + 19 * s, 5 * s, 4 * s);
      // Cristaux poings
      ctx.fillStyle = '#88ddff'; ctx.fillRect(ox - 2 * s, oy + 18 * s, 2 * s, 3 * s); ctx.fillRect(ox + 22 * s, oy + 18 * s, 2 * s, 3 * s);
      // T√™te
      ctx.fillStyle = '#3377bb';
      ctx.fillRect(ox + 4 * s, oy + 3 * s, 14 * s, 8 * s);
      // Cr√™te cristaux
      ctx.fillStyle = '#aaddff';
      for (let i = 0; i < 3; i++) { ctx.beginPath(); ctx.moveTo(ox + (5 + i * 4) * s, oy + 3 * s); ctx.lineTo(ox + (6 + i * 4) * s, oy, oy + 0 * s); ctx.lineTo(ox + (7 + i * 4) * s, oy + 3 * s); ctx.closePath(); ctx.fill(); }
      // Yeux
      ctx.fillStyle = '#00ccff';
      ctx.fillRect(ox + 5 * s, oy + 5 * s, 4 * s, 3 * s);
      ctx.fillRect(ox + 13 * s, oy + 5 * s, 4 * s, 3 * s);
      ctx.fillStyle = `rgba(0,200,255,${0.5 * pulse})`;
      ctx.fillRect(ox + 4 * s, oy + 4 * s, 6 * s, 5 * s); ctx.fillRect(ox + 12 * s, oy + 4 * s, 6 * s, 5 * s);
      // Bouche
      ctx.fillStyle = '#002244';
      ctx.fillRect(ox + 6 * s, oy + 9 * s, 10 * s, 2 * s);
      ctx.fillStyle = '#aaddff'; for (let i = 0; i < 3; i++) ctx.fillRect(ox + (7 + i * 3) * s, oy + 9 * s, 2 * s, 2 * s);
      // Jambes
      ctx.fillStyle = '#3377bb';
      ctx.fillRect(ox + 4 * s, oy + 26 * s + legOff, 5 * s, 6 * s);
      ctx.fillRect(ox + 13 * s, oy + 26 * s - legOff, 5 * s, 6 * s);
      ctx.fillStyle = '#2266aa';
      ctx.fillRect(ox + 3 * s, oy + 31 * s + legOff, 6 * s, 2 * s); ctx.fillRect(ox + 12 * s, oy + 31 * s - legOff, 6 * s, 2 * s);
      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ GRIFFON (montagne) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawGriffon(ctx, cx, cy, dir, frame, scale = 1.7, alpha = 1) {
      const s = scale; ctx.save(); ctx.translate(cx, cy); ctx.globalAlpha *= alpha;
      if (dir < 0) ctx.scale(-1, 1);
      const ox = -10 * s, oy = -10 * s;
      const wingOff = frame === 1 ? -2 * s : frame === 2 ? 2 * s : 0;
      const legOff = frame === 1 ? -s : frame === 2 ? s : 0;
      // Ailes
      ctx.fillStyle = '#8b6a10';
      ctx.beginPath(); ctx.moveTo(ox + 10 * s, oy + 5 * s); ctx.lineTo(ox - 4 * s, oy + 0 * s + wingOff); ctx.lineTo(ox + 0 * s, oy + 5 * s + wingOff); ctx.lineTo(ox + 6 * s, oy + 8 * s); ctx.closePath(); ctx.fill();
      ctx.beginPath(); ctx.moveTo(ox + 12 * s, oy + 5 * s); ctx.lineTo(ox + 24 * s, oy + 0 * s + wingOff); ctx.lineTo(ox + 20 * s, oy + 5 * s + wingOff); ctx.lineTo(ox + 16 * s, oy + 8 * s); ctx.closePath(); ctx.fill();
      ctx.fillStyle = '#c8a020';
      ctx.fillRect(ox - 3 * s, oy + s + wingOff, 4 * s, s); ctx.fillRect(ox + 21 * s, oy + s + wingOff, 4 * s, s);
      // Corps
      ctx.fillStyle = '#c8a020';
      ctx.fillRect(ox + 4 * s, oy + 5 * s, 14 * s, 9 * s);
      ctx.fillStyle = '#eecc44';
      ctx.fillRect(ox + 6 * s, oy + 6 * s, 10 * s, 4 * s);
      // T√™te d'aigle
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(ox + 1 * s, oy + 1 * s, 10 * s, 8 * s);
      ctx.fillStyle = '#dddddd'; ctx.fillRect(ox + 2 * s, oy + 2 * s, 7 * s, 5 * s);
      // Bec
      ctx.fillStyle = '#cc8800'; ctx.fillRect(ox, oy + 5 * s, 3 * s, 3 * s); ctx.fillRect(ox - s, oy + 7 * s, 3 * s, s);
      // Oeil
      ctx.fillStyle = '#ffcc00'; ctx.fillRect(ox + 5 * s, oy + 3 * s, 3 * s, 3 * s);
      ctx.fillStyle = '#000'; ctx.fillRect(ox + 6 * s, oy + 3 * s, 2 * s, 2 * s);
      // Oreilles/huppe
      ctx.fillStyle = '#c8a020'; ctx.fillRect(ox + 7 * s, oy, 3 * s, 2 * s); ctx.fillRect(ox + 6 * s, oy - 2 * s, s, 3 * s); ctx.fillRect(ox + 10 * s, oy - 2 * s, s, 3 * s);
      // Queue
      ctx.fillStyle = '#c8a020';
      ctx.fillRect(ox + 18 * s, oy + 5 * s, 4 * s, 4 * s);
      ctx.fillRect(ox + 20 * s, oy + 3 * s + legOff, 2 * s, 4 * s);
      ctx.fillRect(ox + 21 * s, oy + 1 * s + legOff, s, 3 * s);
      // Pattes avec griffes
      ctx.fillStyle = '#aa8810';
      ctx.fillRect(ox + 5 * s, oy + 13 * s + legOff, 3 * s, 4 * s);
      ctx.fillRect(ox + 13 * s, oy + 13 * s - legOff, 3 * s, 4 * s);
      ctx.fillStyle = '#888';
      ctx.fillRect(ox + 4 * s, oy + 16 * s + legOff, s, 2 * s); ctx.fillRect(ox + 6 * s, oy + 17 * s + legOff, s, 2 * s); ctx.fillRect(ox + 8 * s, oy + 16 * s + legOff, s, 2 * s);
      ctx.fillRect(ox + 12 * s, oy + 16 * s - legOff, s, 2 * s); ctx.fillRect(ox + 14 * s, oy + 17 * s - legOff, s, 2 * s); ctx.fillRect(ox + 16 * s, oy + 16 * s - legOff, s, 2 * s);
      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ GOLEM (montagne) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawGolem(ctx, cx, cy, dir, frame, scale = 2.0, alpha = 1) {
      const s = scale; ctx.save(); ctx.translate(cx, cy); ctx.globalAlpha *= alpha;
      if (dir < 0) ctx.scale(-1, 1);
      const ox = -12 * s, oy = -16 * s;
      const legOff = frame === 1 ? -s : frame === 2 ? s : 0;
      const pulse = (Math.sin(GS.frame * 0.06) + 1) / 2;
      // Corps massif
      ctx.fillStyle = '#5a5a5a';
      ctx.fillRect(ox + 2 * s, oy + 8 * s, 20 * s, 18 * s);
      ctx.fillStyle = '#707070'; ctx.fillRect(ox + 3 * s, oy + 9 * s, 18 * s, 8 * s);
      // Fissures lumineuses
      ctx.strokeStyle = `rgba(255,${100 + Math.floor(100 * pulse)},0,${0.6 + 0.3 * pulse})`; ctx.lineWidth = s;
      ctx.beginPath(); ctx.moveTo(ox + 8 * s, oy + 12 * s); ctx.lineTo(ox + 12 * s, oy + 20 * s); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(ox + 15 * s, oy + 11 * s); ctx.lineTo(ox + 13 * s, oy + 18 * s); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(ox + 6 * s, oy + 18 * s); ctx.lineTo(ox + 10 * s, oy + 24 * s); ctx.stroke();
      // √âpauli√®res rocheuses
      ctx.fillStyle = '#444';
      ctx.fillRect(ox, oy + 8 * s, 4 * s, 6 * s); ctx.fillRect(ox + 20 * s, oy + 8 * s, 4 * s, 6 * s);
      ctx.fillRect(ox - 2 * s, oy + 6 * s, 4 * s, 4 * s); ctx.fillRect(ox + 22 * s, oy + 6 * s, 4 * s, 4 * s);
      // Bras
      ctx.fillStyle = '#5a5a5a';
      ctx.fillRect(ox - 2 * s, oy + 9 * s, 4 * s, 12 * s); ctx.fillRect(ox + 22 * s, oy + 9 * s, 4 * s, 12 * s);
      // Poings
      ctx.fillStyle = '#444';
      ctx.fillRect(ox - 3 * s, oy + 20 * s, 5 * s, 5 * s); ctx.fillRect(ox + 22 * s, oy + 20 * s, 5 * s, 5 * s);
      // T√™te
      ctx.fillStyle = '#4a4a4a';
      ctx.fillRect(ox + 4 * s, oy + 0 * s, 16 * s, 9 * s);
      ctx.fillStyle = '#606060'; ctx.fillRect(ox + 5 * s, oy + s, 14 * s, 4 * s);
      // Yeux de magma
      ctx.fillStyle = `rgba(255,${80 + Math.floor(120 * pulse)},0,1)`;
      ctx.fillRect(ox + 5 * s, oy + 2 * s, 5 * s, 4 * s); ctx.fillRect(ox + 14 * s, oy + 2 * s, 5 * s, 4 * s);
      ctx.fillStyle = '#fff'; ctx.fillRect(ox + 5 * s, oy + 2 * s, 2 * s, s); ctx.fillRect(ox + 14 * s, oy + 2 * s, 2 * s, s);
      // Bouche
      ctx.fillStyle = `rgba(255,60,0,${0.7 + 0.2 * pulse})`;
      ctx.fillRect(ox + 6 * s, oy + 7 * s, 12 * s, 2 * s);
      for (let i = 0; i < 3; i++) { ctx.fillStyle = '#333'; ctx.fillRect(ox + (7 + i * 3) * s, oy + 7 * s, 2 * s, 2 * s); }
      // Jambes
      ctx.fillStyle = '#4a4a4a';
      ctx.fillRect(ox + 4 * s, oy + 26 * s + legOff, 6 * s, 6 * s); ctx.fillRect(ox + 14 * s, oy + 26 * s - legOff, 6 * s, 6 * s);
      ctx.fillStyle = '#333'; ctx.fillRect(ox + 3 * s, oy + 31 * s + legOff, 7 * s, 2 * s); ctx.fillRect(ox + 13 * s, oy + 31 * s - legOff, 7 * s, 2 * s);
      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ √âL√âMENTAL DE NEIGE (montagne) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawElemental(ctx, cx, cy, frame, scale = 1.7, alpha = 1) {
      const s = scale; ctx.save(); ctx.translate(cx, cy); ctx.globalAlpha *= alpha;
      const ox = -8 * s, oy = -12 * s;
      const pulse = (Math.sin(GS.frame * 0.1) + 1) / 2;
      const spin = GS.frame * 0.05;
      // Tourbillon neige ext√©rieur
      ctx.strokeStyle = `rgba(180,220,255,${0.3 + 0.2 * pulse})`; ctx.lineWidth = s;
      for (let i = 0; i < 3; i++) {
        ctx.beginPath(); ctx.arc(0, 0, (8 + i * 4) * s, spin + i * Math.PI * 0.6, spin + i * Math.PI * 0.6 + Math.PI * 1.4); ctx.stroke();
      }
      // Corps neige/glace
      ctx.fillStyle = `rgba(180,220,255,${0.75 + 0.15 * pulse})`;
      ctx.beginPath(); ctx.arc(ox + 8 * s, oy + 8 * s, 8 * s, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = `rgba(220,240,255,${0.5 + 0.2 * pulse})`;
      ctx.beginPath(); ctx.arc(ox + 8 * s, oy + 6 * s, 6 * s, 0, Math.PI * 2); ctx.fill();
      // Cristaux internes
      ctx.fillStyle = '#aaddff';
      for (let i = 0; i < 4; i++) {
        const a2 = spin * 2 + i * Math.PI / 2;
        ctx.fillRect(ox + 8 * s + Math.cos(a2) * 4 * s - s, oy + 8 * s + Math.sin(a2) * 4 * s - s, 2 * s, 2 * s);
      }
      // Yeux
      ctx.fillStyle = '#0044aa';
      ctx.fillRect(ox + 4 * s, oy + 5 * s, 3 * s, 4 * s); ctx.fillRect(ox + 9 * s, oy + 5 * s, 3 * s, 4 * s);
      ctx.fillStyle = '#00aaff'; ctx.fillRect(ox + 4 * s, oy + 5 * s, s, s); ctx.fillRect(ox + 9 * s, oy + 5 * s, s, s);
      // Bouche
      ctx.fillStyle = '#0044aa';
      ctx.fillRect(ox + 5 * s, oy + 10 * s, 6 * s, s);
      for (let i = 0; i < 3; i++) { ctx.fillStyle = '#88ccff'; ctx.fillRect(ox + (5 + i * 2) * s, oy + 10 * s, s, s); }
      // Bras cristaux flottants
      ctx.fillStyle = `rgba(140,200,255,${0.7 + 0.2 * pulse})`;
      ctx.fillRect(ox - 2 * s, oy + 6 * s, 3 * s, 6 * s); ctx.fillRect(ox + 15 * s, oy + 6 * s, 3 * s, 6 * s);
      ctx.fillStyle = '#aaddff'; ctx.fillRect(ox - 3 * s, oy + 5 * s, 2 * s, 2 * s); ctx.fillRect(ox + 17 * s, oy + 5 * s, 2 * s, 2 * s);
      // Bas du corps (fondu en particules)
      for (let i = 0; i < 5; i++) {
        ctx.fillStyle = `rgba(180,220,255,${(0.5 - i * 0.08) * pulse})`;
        ctx.fillRect(ox + (3 + i * 2) * s, oy + (14 + i) * s, 2 * s, 2 * s);
      }
      ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ Fonctions utilitaires pour obtenir frame/dir par monstre ‚îÄ
    function getMonFrame(m) {
      if (!m._animFrame) { m._animFrame = 0; m._animTimer = 0; }
      m._animTimer++;
      const spd = m.spd > 1.5 ? 6 : m.spd > 0.8 ? 10 : 14;
      if (m._animTimer >= spd) { m._animFrame = (m._animFrame + 1) % 3; m._animTimer = 0; }
      return (m.state === 'idle' || m.state === 'wander') && m.spd < 0.5 ? 0 : m._animFrame;
    }
    function getMonDir(m) {
      // -1=gauche, 1=droite  (pour flip)
      if (!m._dir) m._dir = 1;
      if (m.vx < -0.1) m._dir = -1;
      else if (m.vx > 0.1) m._dir = 1;
      return m._dir;
    }
    function getPlayerDir(p) {
      // 0=bas 1=haut 2=gauche 3=droite
      if (p.fy > 0.3) return 0;
      if (p.fy < -0.3) return 1;
      if (p.fx < 0) return 2;
      return 3;
    }

    // ‚îÄ‚îÄ‚îÄ Sprite picking par type de monstre ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function getMonsterType(m) {
      const n = m.name;
      if (n === 'Loup') return 'wolf';
      if (n === 'Chauve-souris') return 'bat';
      if (n === 'Araign√©e') return 'spider';
      if (n === 'Entit√©') return 'leaf';
      if (n === 'Squelette') return 'skeleton';
      if (n === 'Zombie') return 'zombie';
      if (n === 'Fant√¥me') return 'ghost';
      if (n === 'Chevalier') return 'knight';
      if (n === 'G√©ant de Glace') return 'iceGiant';
      if (n === 'Griffon') return 'griffon';
      if (n === 'Golem') return 'golem';
      if (n === '√âl√©mental') return 'elemental';
      return null;
    }
    function getBossType(lvl) {
      if (lvl === 0) return 'demon';
      if (lvl === 1) return 'king';
      return 'dragon';
    }

    // ============================================================
    // TITLE ANIMATION
    // ============================================================
    let titleFrame = 0;
    function animateTitle() {
      if (document.getElementById('title').style.display === 'none') return;
      TC.fillStyle = 'rgba(0,0,0,0.03)'; TC.fillRect(0, 0, tc.width, tc.height); titleFrame++;
      for (let i = 0; i < 3; i++) {
        const x = Math.random() * tc.width, y = Math.random() * tc.height;
        TC.fillStyle = `rgba(255,215,0,${0.2 + Math.random() * 0.4})`; TC.fillRect(x, y, 1 + Math.random() * 2, 1 + Math.random() * 2);
      }
      requestAnimationFrame(animateTitle);
    }
    animateTitle();

    // ============================================================
    // FIREWORKS
    // ============================================================
    function fireworks() {
      const em = ['üéÜ', 'üéá', '‚≠ê', '‚ú®', 'üåü', 'üí´', 'üéâ', '‚ù§Ô∏è', 'üèÜ', 'üéä', 'üí•'];
      for (let i = 0; i < 36; i++)setTimeout(() => {
        const p = document.createElement('div'); p.className = 'particle';
        p.textContent = em[Math.floor(Math.random() * em.length)];
        p.style.left = Math.random() * 100 + 'vw'; p.style.top = Math.random() * 100 + 'vh';
        p.style.setProperty('--dx', (Math.random() - 0.5) * 400 + 'px');
        p.style.setProperty('--dy', (Math.random() - 0.5) * 400 + 'px');
        p.style.setProperty('--rot', (Math.random() * 720 - 360) + 'deg');
        p.style.setProperty('--dur', (1 + Math.random() * 1.2) + 's');
        document.body.appendChild(p); setTimeout(() => p.remove(), 2500);
      }, i * 70);
    }

    // ============================================================
    // MAIN LOOP
    // ============================================================
    function loop() {
      if (!gRun) { requestAnimationFrame(loop); return; }
      GS.frame++;
      let shkX = 0, shkY = 0;
      if (GS.shake > 0) { shkX = (Math.random() - 0.5) * GS.shake; shkY = (Math.random() - 0.5) * GS.shake; GS.shake *= 0.75; if (GS.shake < 0.1) GS.shake = 0; }
      C.fillStyle = LEVELS[curLvl].bgA; C.fillRect(0, 0, canvas.width, canvas.height);
      C.save(); C.translate(Math.round(shkX), Math.round(shkY));
      updPlayer(); updMons(); updProjectiles();
      renderMap(); renderAmbient(); renderDecos(); renderQItems();
      renderBossWarnings();
      renderProjectiles(); renderMons(); renderPlayer(); renderAtks();
      renderBossBeam();
      renderLighting();
      C.restore();
      renderMinimap();
      updSkillBar();
      requestAnimationFrame(loop);
    }

    // ============================================================
    // DETECT MOBILE
    // ============================================================
    function isMobile() { return ('ontouchstart' in window) || navigator.maxTouchPoints > 0 || window.innerWidth < 900; }

    // ============================================================
    // GAME START
    // ============================================================
    function startGame() {
      document.getElementById('title').style.display = 'none';
      document.getElementById('game').style.display = 'block';
      document.getElementById('hud').style.display = 'flex';
      document.getElementById('minimap-wrap').style.display = 'block';
      // Toujours afficher les contr√¥les (mobile ET PC)
      document.getElementById('mobilecontrols').style.display = 'block';
      gRun = true; isDead = false; curLvl = 0;
      const p = GS.p; p.hp = 6; p.maxHp = 6; p.xp = 0; p.lvl = 1; p.wPow = 1;
      p.weapon = '‚öîÔ∏è √âp√©e Rouill√©e'; p.atkCDs = [0, 0, 0, 0];
      p.dashCD = 0; p.invincible = false; p.invincibleTimer = 0;
      BossMusic.init();
      loadLevel(0); loop();
    }

  </script>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
     BOSS MUSIC ENGINE ‚Äî Synth√®se proc√©durale int√©gr√©e
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<script>
'use strict';
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// CONSTANTES
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const MUSIC_SR = 48000;

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// PRIMITIVES AUDIO
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function m_osc(oc, type, freq, t0, dur, peak, opts={}) {
  const { atk=0.01, dec=0.04, sus=0.75, rel=0.1, detune=0, lp=null, lpQ=1, pan=0 } = opts;
  const o=oc.createOscillator(), g=oc.createGain();
  o.type=type; o.frequency.value=freq; o.detune.value=detune;
  let node=o;
  if (lp) { const f=oc.createBiquadFilter(); f.type='lowpass'; f.frequency.value=lp; f.Q.value=lpQ; o.connect(f); node=f; }
  if (pan!==0) { const p=oc.createStereoPanner(); p.pan.value=pan; node.connect(p); node=p; }
  node.connect(g); g.connect(oc.destination);
  const t1=t0+atk, t2=t1+dec, t3=t0+dur-rel, t4=t0+dur;
  g.gain.setValueAtTime(0,0);
  g.gain.setValueAtTime(0,t0);
  g.gain.linearRampToValueAtTime(peak,t1);
  g.gain.linearRampToValueAtTime(peak*sus,t2);
  g.gain.setValueAtTime(peak*sus, Math.max(t2,t3));
  g.gain.linearRampToValueAtTime(0,t4);
  o.start(t0); o.stop(t4+0.05);
}

function m_distOsc(oc, freq, t0, dur, peak, drive=180, opts={}) {
  const { atk=0.008, rel=0.08, lp=700, pan=0, type='sawtooth' } = opts;
  const o=oc.createOscillator(); o.type=type; o.frequency.value=freq;
  const ws=oc.createWaveShaper();
  const k=drive, n=512, curve=new Float32Array(n);
  for (let i=0;i<n;i++) { const x=(2*i/n-1); curve[i]=((Math.PI+k)*x)/(Math.PI+k*Math.abs(x)); }
  ws.curve=curve; ws.oversample='4x';
  const f=oc.createBiquadFilter(); f.type='lowpass'; f.frequency.value=lp;
  const g=oc.createGain();
  let node=g;
  if (pan!==0) { const p=oc.createStereoPanner(); p.pan.value=pan; g.connect(p); node=p; }
  node.connect(oc.destination);
  o.connect(ws); ws.connect(f); f.connect(g);
  g.gain.setValueAtTime(0,0);
  g.gain.setValueAtTime(0,t0);
  g.gain.linearRampToValueAtTime(peak,t0+atk);
  g.gain.setValueAtTime(peak,t0+dur-rel);
  g.gain.linearRampToValueAtTime(0,t0+dur);
  o.start(t0); o.stop(t0+dur+0.05);
}

function m_noise(oc, t0, dur, peak, opts={}) {
  const { atk=0.002, rel=0.15, ftype='bandpass', freq=600, Q=1.5, pan=0, pink=false } = opts;
  const len=Math.ceil(MUSIC_SR*(dur+0.1));
  const buf=oc.createBuffer(1,len,MUSIC_SR);
  const d=buf.getChannelData(0);
  if (pink) {
    let b0=0,b1=0,b2=0,b3=0,b4=0,b5=0;
    for (let i=0;i<len;i++) {
      const w=Math.random()*2-1;
      b0=0.99886*b0+w*0.0555179; b1=0.99332*b1+w*0.0750759;
      b2=0.96900*b2+w*0.1538520; b3=0.86650*b3+w*0.3104856;
      b4=0.55000*b4+w*0.5329522; b5=-0.7616*b5-w*0.0168980;
      d[i]=(b0+b1+b2+b3+b4+b5+w*0.5362)*0.11;
    }
  } else { for (let i=0;i<len;i++) d[i]=Math.random()*2-1; }
  const src=oc.createBufferSource(); src.buffer=buf;
  const flt=oc.createBiquadFilter(); flt.type=ftype; flt.frequency.value=freq; flt.Q.value=Q;
  const g=oc.createGain();
  let node=g;
  if (pan!==0) { const p=oc.createStereoPanner(); p.pan.value=pan; g.connect(p); node=p; }
  node.connect(oc.destination); src.connect(flt); flt.connect(g);
  g.gain.setValueAtTime(0,0);
  g.gain.setValueAtTime(0,t0);
  g.gain.linearRampToValueAtTime(peak,t0+atk);
  g.gain.setValueAtTime(peak,t0+dur*0.25);
  g.gain.exponentialRampToValueAtTime(0.0001,t0+dur);
  src.start(t0); src.stop(t0+dur+0.1);
}

function m_kick(oc, t0, peak=0.9, p0=120, p1=40, opts={}) {
  const { dec=0.38, pan=0 } = opts;
  const o=oc.createOscillator(); o.type='sine';
  const g=oc.createGain();
  let node=g;
  if (pan!==0) { const p=oc.createStereoPanner(); p.pan.value=pan; g.connect(p); node=p; }
  node.connect(oc.destination); o.connect(g);
  o.frequency.setValueAtTime(p0,t0);
  o.frequency.exponentialRampToValueAtTime(p1,t0+dec*0.5);
  g.gain.setValueAtTime(0,0);
  g.gain.setValueAtTime(peak,t0);
  g.gain.exponentialRampToValueAtTime(0.0001,t0+dec);
  o.start(t0); o.stop(t0+dec+0.05);
  m_noise(oc,t0,0.007,peak*0.4,{atk:0.001,ftype:'highpass',freq:3000,Q:1,pan});
}

function m_taiko(oc, t0, peak=1.0, opts={}) {
  const { p0=85, p1=28, dec=0.6, pan=0 } = opts;
  const o=oc.createOscillator(); o.type='sine';
  const comp=oc.createDynamicsCompressor();
  comp.threshold.value=-20; comp.ratio.value=14;
  const g=oc.createGain();
  let node=g;
  if (pan!==0) { const p=oc.createStereoPanner(); p.pan.value=pan; g.connect(p); node=p; }
  node.connect(oc.destination);
  o.connect(comp); comp.connect(g);
  o.frequency.setValueAtTime(p0,t0);
  o.frequency.exponentialRampToValueAtTime(p1,t0+dec*0.55);
  g.gain.setValueAtTime(0,0);
  g.gain.setValueAtTime(peak,t0);
  g.gain.exponentialRampToValueAtTime(0.0001,t0+dec);
  o.start(t0); o.stop(t0+dec+0.05);
  m_noise(oc,t0,0.018,peak*0.25,{atk:0.001,ftype:'lowpass',freq:100,Q:0.5,pan});
}

function m_snare(oc, t0, peak=0.6, opts={}) {
  const { bf=200, bd=0.14, nd=0.18, ng=0.7, pan=0 } = opts;
  const o=oc.createOscillator(); o.type='triangle'; o.frequency.value=bf;
  const gb=oc.createGain(); gb.connect(oc.destination); o.connect(gb);
  gb.gain.setValueAtTime(0,0);
  gb.gain.setValueAtTime(peak*0.4,t0);
  gb.gain.exponentialRampToValueAtTime(0.0001,t0+bd);
  o.start(t0); o.stop(t0+bd+0.05);
  m_noise(oc,t0,nd,peak*ng,{atk:0.001,ftype:'bandpass',freq:2200,Q:0.8,pan});
}

function m_hihat(oc, t0, peak=0.2, open=false, pan=0) {
  const dur=open?0.3:0.065;
  m_noise(oc,t0,dur,peak,{atk:0.001,ftype:'highpass',freq:7000,Q:1.0,pan});
}

function m_bell(oc, freq, t0, peak=0.25, dec=2.0, pan=0) {
  const ptls=[[1,1],[2.756,0.42],[5.404,0.2],[8.931,0.1],[13.35,0.05]];
  for (const [r,a] of ptls) {
    const o=oc.createOscillator(); o.type='sine'; o.frequency.value=freq*r;
    const g=oc.createGain();
    let node=g;
    if (pan!==0) { const p=oc.createStereoPanner(); p.pan.value=pan; g.connect(p); node=p; }
    node.connect(oc.destination); o.connect(g);
    g.gain.setValueAtTime(0,0);
    g.gain.setValueAtTime(peak*a,t0);
    g.gain.exponentialRampToValueAtTime(0.0001,t0+Math.max(0.05, dec*(1-r*0.04)));
    o.start(t0); o.stop(t0+dec+0.1);
  }
}

function m_strings(oc, freq, t0, dur, peak=0.12, opts={}) {
  const { atk=0.25, rel=0.5, lp=900, pan=0, vRate=4, vDepth=3 } = opts;
  for (let v=0;v<3;v++) {
    const o=oc.createOscillator(); o.type='sawtooth';
    o.frequency.value=freq; o.detune.value=(v-1)*7;
    const lfo=oc.createOscillator(); lfo.frequency.value=vRate+v*0.3;
    const lg=oc.createGain(); lg.gain.value=vDepth;
    lfo.connect(lg); lg.connect(o.frequency);
    const f=oc.createBiquadFilter(); f.type='lowpass'; f.frequency.value=lp;
    const g=oc.createGain();
    let node=g;
    if (pan!==0) { const p=oc.createStereoPanner(); p.pan.value=pan; g.connect(p); node=p; }
    node.connect(oc.destination); o.connect(f); f.connect(g);
    g.gain.setValueAtTime(0,0);
    g.gain.setValueAtTime(0,t0);
    g.gain.linearRampToValueAtTime(peak/3,t0+atk);
    g.gain.setValueAtTime(peak/3,t0+dur-rel);
    g.gain.linearRampToValueAtTime(0,t0+dur);
    lfo.start(t0); lfo.stop(t0+dur+0.1);
    o.start(t0); o.stop(t0+dur+0.1);
  }
}

function m_drone(oc, freq, t0, dur, peak=0.4, opts={}) {
  const { atk=2.0, rel=2.0, lp=180, harm=2 } = opts;
  for (let h=0;h<=harm;h++) {
    const o=oc.createOscillator();
    o.type=h===0?'sine':'sawtooth'; o.frequency.value=freq*(h===0?1:h+1);
    const f=oc.createBiquadFilter(); f.type='lowpass'; f.frequency.value=lp/(h+1)*1.2;
    const g=oc.createGain(); g.connect(oc.destination); o.connect(f); f.connect(g);
    const lvl=peak/(h*1.5+1);
    g.gain.setValueAtTime(0,0);
    g.gain.setValueAtTime(0,t0);
    g.gain.linearRampToValueAtTime(lvl,t0+atk);
    g.gain.setValueAtTime(lvl,t0+dur-rel);
    g.gain.linearRampToValueAtTime(0,t0+dur);
    o.start(t0); o.stop(t0+dur+0.1);
  }
}

function m_choir(oc, freq, t0, dur, peak=0.12, opts={}) {
  const { atk=1.0, rel=1.5, dets=[-10,-5,0,5,10], lp=1200 } = opts;
  for (const dt of dets) {
    const o=oc.createOscillator(); o.type='sine'; o.frequency.value=freq; o.detune.value=dt;
    const f=oc.createBiquadFilter(); f.type='lowpass'; f.frequency.value=lp;
    const g=oc.createGain(); g.connect(oc.destination);
    o.connect(f); f.connect(g);
    g.gain.setValueAtTime(0,0);
    g.gain.setValueAtTime(0,t0);
    g.gain.linearRampToValueAtTime(peak/dets.length,t0+atk);
    g.gain.setValueAtTime(peak/dets.length,t0+dur-rel);
    g.gain.linearRampToValueAtTime(0,t0+dur);
    o.start(t0); o.stop(t0+dur+0.1);
  }
}

function m_flute(oc, freq, t0, dur, peak=0.18, opts={}) {
  const { vRate=5, vDepth=5, pan=0, breath=0.05 } = opts;
  const o=oc.createOscillator(); o.type='triangle'; o.frequency.value=freq;
  const lfo=oc.createOscillator(); lfo.frequency.value=vRate;
  const lg=oc.createGain(); lg.gain.value=vDepth;
  lfo.connect(lg); lg.connect(o.frequency);
  const nlen=Math.ceil(MUSIC_SR*(dur+0.1));
  const nbuf=oc.createBuffer(1,nlen,MUSIC_SR);
  const nd=nbuf.getChannelData(0);
  for (let i=0;i<nlen;i++) nd[i]=Math.random()*2-1;
  const ns=oc.createBufferSource(); ns.buffer=nbuf;
  const nhp=oc.createBiquadFilter(); nhp.type='highpass'; nhp.frequency.value=1800;
  const ng=oc.createGain(); ng.gain.value=breath;
  const mg=oc.createGain();
  let node=mg;
  if (pan!==0) { const p=oc.createStereoPanner(); p.pan.value=pan; mg.connect(p); node=p; }
  node.connect(oc.destination);
  o.connect(mg); ns.connect(nhp); nhp.connect(ng); ng.connect(mg);
  mg.gain.setValueAtTime(0,0);
  mg.gain.setValueAtTime(0,t0);
  mg.gain.linearRampToValueAtTime(peak,t0+0.07);
  mg.gain.setValueAtTime(peak,t0+dur-0.12);
  mg.gain.linearRampToValueAtTime(0,t0+dur);
  lfo.start(t0); lfo.stop(t0+dur+0.1);
  ns.start(t0); ns.stop(t0+dur+0.1);
  o.start(t0); o.stop(t0+dur+0.1);
}

function m_wind(oc, t0, dur, peak=0.08) {
  const len=Math.ceil(MUSIC_SR*(dur+0.1));
  const buf=oc.createBuffer(2,len,MUSIC_SR);
  for (let ch=0;ch<2;ch++) {
    const d=buf.getChannelData(ch); let b0=0,b1=0,b2=0;
    for (let i=0;i<len;i++) {
      const w=Math.random()*2-1;
      b0=0.99*b0+w*0.01; b1=0.88*b1+w*0.12; b2=0.55*b2+w*0.45;
      const t=i/MUSIC_SR;
      const mod=0.5+0.5*Math.sin(t*0.35)*Math.sin(t*0.11+ch);
      d[i]=(b0*0.5+b1*0.35+b2*0.15)*peak*mod;
    }
  }
  const src=oc.createBufferSource(); src.buffer=buf;
  const bp=oc.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=700; bp.Q.value=0.5;
  const g=oc.createGain(); g.gain.value=1; g.connect(oc.destination);
  src.connect(bp); bp.connect(g); src.start(t0); src.stop(t0+dur+0.1);
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// COMPOSITEURS DE TRACKS (1 par boss, 3 phases chacun)
// Indices: 0=pr√©-boss ambient, 1=combat phase1, 2=rage phase2
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const MUSIC_TRACKS = {

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ BOSS 0 : Vorgath (D√©mon) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Phase 0: Pr√©-boss ‚Äì Embers & Dread
  'b0-0': { dur: 38.4, compose: async (oc, D) => {
    const hb=60/50;
    m_drone(oc,36.71,0,D,0.55,{atk:2.5,rel:2.5,lp:150,harm:1});
    m_drone(oc,55.0,0,D,0.18,{atk:3.0,rel:3.0,lp:120,harm:0});
    m_choir(oc,73.42,0,D,0.05,{atk:4.0,rel:4.0,lp:380,dets:[-14,-7,0,7,14]});
    // Heartbeat
    for (let b=0; b<Math.floor(D/hb); b++) {
      const t=b*hb;
      m_kick(oc,t,0.5,80,34,{dec:0.30,pan:0});
      m_kick(oc,t+0.19,0.25,58,26,{dec:0.22,pan:0.1});
    }
    // Metallic rattle
    for (let i=0;i<4;i++) {
      const t=i*(D/4)+1.2;
      m_noise(oc,t,0.6,0.06,{atk:0.002,ftype:'bandpass',freq:1600,Q:4.0,pan:(i%2===0?-0.35:0.35)});
    }
  }},

  // Phase 1: Combat ‚Äì Infernal Charge (CORRIG√â)
  'b0-1': { dur: 38.4, compose: async (oc, D) => {
    const BEAT=60/100, BAR=BEAT*4, BARS=Math.floor(D/BAR);
    // Sub drone continu
    m_drone(oc,36.71,0,D,0.40,{atk:0.1,rel:0.3,lp:200,harm:2});
    // Bass motif ‚Äî utilise des dur√©es courtes pour √©viter le d√©passement
    const BP=[[0,0.20,73.42],[0.5,0.14,73.42],[1,0.25,87.31],[1.5,0.10,98.0],[2,0.20,65.41],[2.5,0.14,73.42],[3,0.30,55.0],[3.75,0.12,73.42]];
    for (let b=0;b<BARS;b++) {
      const tBar=b*BAR;
      for (const [beat,d,f] of BP) {
        const t0=tBar+beat*BEAT;
        if (t0+d < D) m_distOsc(oc,f,t0,d,0.38,175,{lp:420,pan:0});
      }
    }
    // Strings sombres ‚Äî 2 r√©p√©titions max sur la dur√©e
    const SP=[[0,73.42,BAR*1.6],[BAR*2,87.31,BAR*0.85],[BAR*3,82.41,BAR*1.3],[BAR*4,73.42,BAR*2],[BAR*6,65.41,BAR*1.0],[BAR*7,73.42,BAR*0.8]];
    const reps=Math.floor(BARS/8);
    for (let r=0;r<reps;r++) {
      for (const [bOff,f,d] of SP) {
        const t0=r*BAR*8+bOff;
        if (t0+d < D) {
          m_strings(oc,f,t0,d,0.11,{atk:0.08,rel:0.25,lp:600,pan:-0.25});
          m_strings(oc,f*1.5,t0,d*0.8,0.065,{atk:0.1,rel:0.2,lp:500,pan:0.25});
        }
      }
    }
    // Tambours tribaux
    for (let b=0;b<BARS;b++) {
      const t=b*BAR;
      m_kick(oc,t,0.92,125,38,{dec:0.45});
      m_kick(oc,t+0.5*BEAT,0.38,90,32,{dec:0.30});
      m_kick(oc,t+2*BEAT,0.85,118,36,{dec:0.42});
      if (b%2===1) m_kick(oc,t+3.5*BEAT,0.48,90,30,{dec:0.28});
      m_taiko(oc,t,0.60,{p0:78,p1:26,dec:0.52,pan:-0.32});
      m_taiko(oc,t+2*BEAT,0.52,{p0:72,p1:24,dec:0.46,pan:0.32});
      m_snare(oc,t+BEAT,0.50,{bf:180,bd:0.12,nd:0.16,ng:0.8,pan:0});
      m_snare(oc,t+3*BEAT,0.55,{bf:185,bd:0.13,nd:0.17,ng:0.8,pan:0});
      for (let h=0;h<8;h++) m_hihat(oc,t+h*BEAT*0.5,(h%2===0?0.16:0.07),false,(h%2===0?-0.22:0.22));
      if (b%4===3) m_hihat(oc,t+2.5*BEAT,0.12,true,0);
    }
  }},

  // Phase 2: Rage ‚Äì The Burning Wrath (CORRIG√â)
  'b0-2': { dur: 32.0, compose: async (oc, D) => {
    const BEAT=60/120, BAR=BEAT*4, BARS=Math.floor(D/BAR);
    m_drone(oc,36.71,0,D,0.48,{atk:0.05,rel:0.2,lp:240,harm:2});
    // Bass rapide
    const BP2=[[0,0.14,73.42],[0.25,0.09,73.42],[0.5,0.14,87.31],[0.75,0.09,98.0],[1,0.14,65.41],[1.25,0.09,73.42],[1.5,0.16,55.0],[1.75,0.09,65.41],[2,0.14,73.42],[2.25,0.09,87.31],[2.5,0.14,98.0],[2.75,0.09,73.42],[3,0.14,65.41],[3.25,0.11,55.0],[3.5,0.16,73.42],[3.75,0.09,98.0]];
    for (let b=0;b<BARS;b++) {
      const tBar=b*BAR;
      for (const [beat,d,f] of BP2) {
        const t0=tBar+beat*BEAT;
        if (t0+d < D) m_distOsc(oc,f,t0,d,0.36,220,{lp:380});
      }
    }
    // Layer haut distordu
    const HP=[[0,293.66,0.13],[0.5,329.63,0.10],[1.0,392.0,0.16],[1.5,349.23,0.10],[2.0,440.0,0.18],[3.0,392.0,0.26]];
    for (let b=0;b<BARS;b++) {
      const tBar=b*BAR;
      for (const [bt,f,d] of HP) {
        const t0=tBar+bt*BEAT;
        if (t0+d < D) m_distOsc(oc,f,t0,d,0.16,320,{lp:1400,pan:(b%2===0?-0.45:0.45),atk:0.005,rel:0.04,type:'sawtooth'});
      }
    }
    // Drums m√©talliques
    for (let b=0;b<BARS;b++) {
      const t=b*BAR;
      m_kick(oc,t,1.0,132,42,{dec:0.34});
      m_kick(oc,t+0.5*BEAT,0.52,100,35,{dec:0.24});
      m_kick(oc,t+BEAT,0.42,88,30,{dec:0.20});
      m_kick(oc,t+2*BEAT,1.0,128,40,{dec:0.34});
      m_kick(oc,t+2.5*BEAT,0.56,100,32,{dec:0.24});
      m_kick(oc,t+3*BEAT,0.47,88,28,{dec:0.20});
      m_snare(oc,t+BEAT,0.70,{bf:250,bd:0.1,nd:0.22,ng:1.0,pan:0});
      m_snare(oc,t+3*BEAT,0.76,{bf:260,bd:0.1,nd:0.24,ng:1.0,pan:0});
      m_bell(oc,880,t+BEAT,0.10,0.38,(b%2===0?-0.55:0.55));
      if (b%2===0) m_bell(oc,1320,t+3*BEAT,0.065,0.28,0.6);
      m_taiko(oc,t,0.65,{p0:80,p1:26,dec:0.38,pan:-0.4});
      m_taiko(oc,t+2*BEAT,0.55,{p0:74,p1:24,dec:0.36,pan:0.4});
      for (let h=0;h<16;h++) m_hihat(oc,t+h*BEAT*0.25,(h%4===0?0.19:h%2===0?0.10:0.055),false,(h%3===0?-0.35:0.28));
    }
  }},

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ BOSS 1 : Nytherion (Roi) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Phase 0: Pr√©-boss ‚Äì Empty Corridors
  'b1-0': { dur: 21.3, compose: async (oc, D) => {
    m_wind(oc,0,D,0.09);
    m_drone(oc,55.0,0,D,0.18,{atk:3.5,rel:3.5,lp:220,harm:1});
    m_choir(oc,110.0,0,D,0.065,{atk:4.0,rel:4.0,lp:320,dets:[-14,-7,0,7,14]});
    const bells=[[2.2,220,0.12,3.5,-0.45],[6.8,196,0.10,3.0,0.45],[11.5,261.63,0.08,2.8,-0.3],[15.5,220,0.10,3.2,0.3],[19.0,174.61,0.07,2.5,0]];
    for (const [t,f,p,d,pan] of bells) {
      if (t<D) { m_bell(oc,f,t,p,d,pan); if (t+1.1<D) m_bell(oc,f,t+1.1,p*0.45,d*0.8,pan*0.5); }
    }
  }},

  // Phase 1: Combat ‚Äì Haunted Reign
  'b1-1': { dur: 42.67, compose: async (oc, D) => {
    const BEAT=60/90, BAR=BEAT*4, BARS=Math.floor(D/BAR);
    m_drone(oc,55.0,0,D,0.26,{atk:2.0,rel:2.0,lp:200,harm:1});
    // Choir chords
    const CHORDS=[[55,65.41,82.41],[49,61.74,73.42],[43.65,55,65.41],[55,73.42,98]];
    const numChordCycles=Math.floor(D/(BAR*4));
    for (let i=0;i<numChordCycles;i++) {
      const ch=CHORDS[i%CHORDS.length], t0=i*BAR*4;
      const chDur=Math.min(BAR*4.5, D-t0);
      for (const f of ch) {
        if (t0+chDur > 0 && t0 < D) m_choir(oc,f*4,t0,chDur,0.055,{atk:1.3,rel:2.8,lp:1000,dets:[-8,-4,0,4,8]});
      }
    }
    // Piano motif
    const PM=[[0,440,1.3],[BEAT,392,0.9],[BEAT*2,349.23,1.6],[BEAT*3,293.66,2.1],[BAR*2,329.63,1.0],[BAR*2+BEAT,293.66,0.85],[BAR*2+BEAT*2,261.63,1.9],[BAR*3,246.94,0.7],[BAR*3+BEAT,220,2.5]];
    const reps=Math.floor(BARS/8);
    for (let r=0;r<reps;r++) {
      for (const [b,f,d] of PM) {
        const t0=r*BAR*8+b;
        if (t0+d < D) m_osc(oc,'sine',f,t0,d+1.0,0.08,{atk:0.012,dec:0.08,sus:0.4,rel:d*0.5+0.3,pan:(r%2===0?0.1:-0.1)});
      }
    }
    // Strings
    const SM=[[0,220,BAR*2.5],[BAR*2,196,BAR*1.9],[BAR*4,246.94,BAR*2.2],[BAR*6,220,BAR*2.0]];
    for (let r=0;r<Math.floor(BARS/8);r++) {
      for (const [b,f,d] of SM) {
        const t0=r*BAR*8+b;
        if (t0+d < D) m_strings(oc,f,t0,d,0.075,{atk:0.4,rel:1.0,lp:700,pan:-0.35,vRate:3.8,vDepth:2.5});
      }
    }
    // Percussion l√©g√®re
    for (let b=0;b<BARS;b++) {
      const t=b*BAR;
      m_kick(oc,t,0.40,88,40,{dec:0.58});
      if (b%2===0) m_kick(oc,t+2*BEAT,0.30,78,34,{dec:0.46});
      m_snare(oc,t+BEAT,0.18,{bf:320,bd:0.07,nd:0.09,ng:0.3,pan:0});
      m_snare(oc,t+3*BEAT,0.20,{bf:310,bd:0.07,nd:0.09,ng:0.3,pan:0});
      if (b%4===0) m_bell(oc,880,t+BEAT*2,0.06,2.4,0.5);
    }
  }},

  // Phase 2: Rage ‚Äì The Revenant's Throne
  'b1-2': { dur: 42.67, compose: async (oc, D) => {
    const BEAT=60/90, BAR=BEAT*4, BARS=Math.floor(D/BAR);
    m_drone(oc,55.0,0,D,0.32,{atk:0.5,rel:0.8,lp:220,harm:2});
    const SR2=[[0,220,BAR*1.8],[BAR*0.5,261.63,BAR*1.5],[BAR*2,246.94,BAR*1.8],[BAR*2.5,293.66,BAR*1.5],[BAR*4,329.63,BAR*2],[BAR*5,349.23,BAR*1.8],[BAR*6,392,BAR*1.5],[BAR*7,440,BAR*2]];
    for (let r=0;r<Math.floor(BARS/8);r++) {
      for (const [b,f,d] of SR2) {
        const t0=r*BAR*8+b;
        if (t0+d < D) {
          m_strings(oc,f,t0,d,0.12,{atk:0.18,rel:0.45,lp:950,pan:-0.3,vRate:4.2,vDepth:3.0});
          m_strings(oc,f*2,t0+0.18,d*0.9,0.075,{atk:0.14,rel:0.38,lp:1500,pan:0.3,vRate:4.5,vDepth:3.0});
        }
      }
    }
    // Choir
    const numCycles=Math.floor(D/(BAR*4));
    const CHORDS2=[[220,440,330],[196,392,293],[246.94,493.88,370],[261.63,523.25,392]];
    for (let i=0;i<numCycles;i++) {
      const t0=i*BAR*4;
      const chDur=Math.min(BAR*4.5, D-t0);
      for (const f of CHORDS2[i%CHORDS2.length]) {
        if (t0 < D) m_choir(oc,f,t0,chDur,0.065,{atk:1.0,rel:2.2,lp:1600,dets:[-10,-5,0,5,10]});
      }
    }
    // Percussion plus dense
    for (let b=0;b<BARS;b++) {
      const t=b*BAR;
      m_kick(oc,t,0.65,100,42,{dec:0.42});
      m_kick(oc,t+2*BEAT,0.60,95,38,{dec:0.38});
      if (b%2===1) m_kick(oc,t+1.5*BEAT,0.30,78,32,{dec:0.28});
      m_snare(oc,t+BEAT,0.45,{bf:200,bd:0.13,nd:0.2,ng:0.7,pan:0});
      m_snare(oc,t+3*BEAT,0.50,{bf:205,bd:0.14,nd:0.22,ng:0.75,pan:0});
      if (b%2===0) for (let h=0;h<4;h++) m_hihat(oc,t+h*BEAT,0.10,(h===2),h%2===0?-0.3:0.3);
      if (b%4===0) m_bell(oc,1318.51,t,0.085,1.5,0.6);
      if (b%4===2) m_bell(oc,987.77,t+BEAT*2,0.065,1.2,-0.5);
    }
  }},

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ BOSS 2 : Thyrax (Dragon) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Phase 0: Pr√©-boss ‚Äì Mountain Silence
  'b2-0': { dur: 19.2, compose: async (oc, D) => {
    m_wind(oc,0,D,0.11);
    m_drone(oc,41.2,0,D,0.58,{atk:3.0,rel:3.0,lp:140,harm:1});
    m_drone(oc,55.0,1.5,D-1.5,0.16,{atk:3.5,rel:2.5,lp:100,harm:0});
    const tTimes=[1.2, 10.5];
    for (const tt of tTimes) if (tt<D-2) {
      m_noise(oc,tt,2.8,0.30,{atk:0.012,ftype:'lowpass',freq:80,Q:0.6,pink:true});
      m_noise(oc,tt,3.8,0.12,{atk:0.06,ftype:'bandpass',freq:200,Q:0.5});
    }
  }},

  // Phase 1: Combat ‚Äì Ancient Fury (CORRIG√â)
  'b2-1': { dur: 38.4, compose: async (oc, D) => {
    const BEAT=60/100, BAR=BEAT*4, BARS=Math.floor(D/BAR);
    m_drone(oc,41.2,0,D,0.48,{atk:0.15,rel:0.4,lp:200,harm:2});
    m_drone(oc,61.74,0,D,0.16,{atk:0.5,rel:0.4,lp:180,harm:0});
    // Bass modal
    const BP3=[[0,0.22,82.41],[1,0.22,82.41],[1.5,0.17,98.0],[2,0.26,73.42],[3,0.22,82.41],[3.5,0.14,87.31]];
    for (let b=0;b<BARS;b++) {
      const tBar=b*BAR;
      for (const [beat,d,f] of BP3) {
        const t0=tBar+beat*BEAT;
        if (t0+d < D) m_distOsc(oc,f,t0,d,0.32,145,{lp:300,type:'sine'});
      }
    }
    // Fl√ªte bambou ‚Äî E mineur pentatonique
    const FP=[
      [[0,164.81,0.7,0.15],[BEAT*1.5,196.0,0.5,0.13],[BEAT*3,220.0,1.3,0.14]],
      [[0,246.94,0.65,0.14],[BEAT*1,220.0,0.85,0.12],[BEAT*2.5,196.0,1.6,0.13]],
      [[0,164.81,0.45,0.11],[BEAT*2,185.0,0.9,0.13],[BEAT*3.5,164.81,0.55,0.10]],
      [[0,220.0,0.5,0.14],[BEAT*1.5,246.94,0.42,0.12],[BEAT*2.5,220.0,0.62,0.11],[BEAT*3.5,196.0,1.9,0.13]]
    ];
    for (let r=0;r<Math.floor(BARS/8);r++) {
      for (let pi=0;pi<FP.length;pi++) {
        const t0=r*BAR*8+pi*BAR*2;
        for (const [b,f,d,g] of FP[pi]) {
          if (t0+b+d < D) m_flute(oc,f,t0+b,d,g,{vRate:4.5,vDepth:5,pan:(pi%2===0?-0.22:0.22)});
        }
      }
    }
    // Taiko puissant
    for (let b=0;b<BARS;b++) {
      const t=b*BAR;
      m_taiko(oc,t,1.0,{p0:88,p1:28,dec:0.62,pan:-0.28});
      m_taiko(oc,t+2*BEAT,0.85,{p0:82,p1:25,dec:0.56,pan:0.28});
      m_taiko(oc,t+BEAT*0.75,0.36,{p0:112,p1:50,dec:0.34,pan:0.52});
      m_taiko(oc,t+BEAT*2.5,0.34,{p0:106,p1:48,dec:0.30,pan:-0.52});
      if (b%2===1) m_taiko(oc,t+BEAT*3.5,0.46,{p0:96,p1:40,dec:0.36,pan:0});
      m_snare(oc,t+BEAT,0.24,{bf:420,bd:0.06,nd:0.1,ng:0.5,pan:-0.3});
      m_snare(oc,t+BEAT*3,0.26,{bf:400,bd:0.06,nd:0.1,ng:0.5,pan:0.3});
      if (b%4===0) m_bell(oc,784,t+BEAT,0.09,1.2,0.42);
      if (b%4===2) m_bell(oc,659.25,t+BEAT*3,0.075,1.0,-0.42);
    }
  }},

  // Phase 2: Rage ‚Äì Temporal Devastation (CORRIG√â)
  'b2-2': { dur: 29.54, compose: async (oc, D) => {
    const BEAT=60/130, BAR=BEAT*4, BARS=Math.floor(D/BAR);
    m_drone(oc,41.2,0,D,0.55,{atk:0.08,rel:0.25,lp:230,harm:3});
    // Bass agressive
    const BR=[[0,0.14,82.41],[0.25,0.09,82.41],[0.5,0.13,98.0],[0.75,0.09,82.41],[1,0.14,73.42],[1.5,0.14,82.41],[1.75,0.09,92.5],[2,0.14,82.41],[2.25,0.09,98.0],[2.5,0.13,110.0],[2.75,0.09,98.0],[3,0.14,82.41],[3.25,0.09,73.42],[3.5,0.16,82.41],[3.75,0.11,61.74]];
    for (let b=0;b<BARS;b++) {
      const tBar=b*BAR;
      for (const [bt,d,f] of BR) {
        const t0=tBar+bt*BEAT;
        if (t0+d < D) m_distOsc(oc,f,t0,d,0.38,200,{lp:360,type:'sawtooth'});
      }
    }
    // Strings aigus
    const SH=[[0,659.25,0.26],[BEAT*0.5,587.33,0.20],[BEAT,659.25,0.30],[BEAT*2,740.0,0.24],[BEAT*2.5,698.46,0.26],[BEAT*3,659.25,0.38],[BEAT*3.5,587.33,0.18]];
    for (let b=0;b<BARS;b++) {
      const tBar=b*BAR;
      for (const [bt,f,d] of SH) {
        const t0=tBar+bt*BEAT;
        if (t0+d < D) m_strings(oc,f,t0,d,0.09,{atk:0.04,rel:0.08,lp:2400,pan:(b%2===0?-0.45:0.45),vRate:6,vDepth:4});
      }
    }
    // Brass stabs
    for (let b=0;b<BARS;b++) {
      if (b%2===0) {
        const t=b*BAR;
        if (t+0.1 < D) m_distOsc(oc,164.81*4,t,0.09,0.18,95,{lp:2200,type:'square',atk:0.02,rel:0.04});
        if (t+2*BEAT+0.09 < D) m_distOsc(oc,196.0*4,t+2*BEAT,0.08,0.15,95,{lp:2000,type:'square',atk:0.02,rel:0.04});
      }
    }
    // Taiko intense
    for (let b=0;b<BARS;b++) {
      const t=b*BAR;
      m_taiko(oc,t,1.0,{p0:96,p1:30,dec:0.44,pan:-0.3});
      m_taiko(oc,t+0.5*BEAT,0.36,{p0:80,p1:35,dec:0.28,pan:0.42});
      m_taiko(oc,t+BEAT,0.50,{p0:100,p1:38,dec:0.36,pan:0.2});
      m_taiko(oc,t+1.5*BEAT,0.30,{p0:75,p1:30,dec:0.26,pan:-0.42});
      m_taiko(oc,t+2*BEAT,1.0,{p0:95,p1:30,dec:0.44,pan:0.3});
      m_taiko(oc,t+2.5*BEAT,0.36,{p0:80,p1:35,dec:0.28,pan:-0.3});
      m_taiko(oc,t+3*BEAT,0.55,{p0:90,p1:32,dec:0.36,pan:-0.2});
      if (b%2===0) m_taiko(oc,t+3.5*BEAT,0.40,{p0:85,p1:30,dec:0.30,pan:0.4});
      m_snare(oc,t+BEAT,0.60,{bf:300,bd:0.09,nd:0.18,ng:0.92,pan:0});
      m_snare(oc,t+BEAT*3,0.65,{bf:310,bd:0.1,nd:0.20,ng:0.95,pan:0});
      for (let h=0;h<16;h++) m_hihat(oc,t+h*BEAT*0.25,(h%4===0?0.18:h%2===0?0.09:0.055),false,(h%3===0?-0.42:0.32));
      if (b%2===0) m_bell(oc,1046.5,t,0.12,0.55,0.62);
      if (b%2===1) m_bell(oc,880,t+2*BEAT,0.10,0.48,-0.62);
    }
  }}
};

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// MOTEUR DE LECTURE ‚Äî BossMusic
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const BossMusic = (() => {
  let actx = null, masterGain = null;
  let currentSrc = null;
  const bufCache = {};
  const renderQueue = {};
  let _engaged = false; // premier √©change de coups d√©tect√©

  function getCtx() {
    if (!actx) {
      actx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: MUSIC_SR });
      masterGain = actx.createGain();
      masterGain.gain.value = 0.72;
      masterGain.connect(actx.destination);
    }
    if (actx.state === 'suspended') actx.resume();
    return actx;
  }

  async function renderTrack(key) {
    if (bufCache[key]) return bufCache[key];
    if (renderQueue[key]) return renderQueue[key];
    const def = MUSIC_TRACKS[key];
    if (!def) throw new Error('Unknown track: ' + key);
    const D = def.dur;
    // Ajouter 0.5s de marge pour √©viter la troncature des notes en fin de buffer
    const totalSamples = Math.ceil(MUSIC_SR * (D + 0.5));
    const p = new Promise((res, rej) => {
      try {
        const oc = new OfflineAudioContext(2, totalSamples, MUSIC_SR);
        def.compose(oc, D).then(() => {
          return oc.startRendering();
        }).then(buf => {
          bufCache[key] = buf;
          res(buf);
        }).catch(err => {
          console.error('Render error', key, err);
          rej(err);
        });
      } catch(e) { rej(e); }
    });
    renderQueue[key] = p;
    return p;
  }

  function _playBuffer(buf, vol=0.75, fadein=0.8) {
    const c = getCtx();
    if (currentSrc) {
      try { currentSrc.stop(); } catch(e){}
      currentSrc = null;
    }
    const src = c.createBufferSource();
    src.buffer = buf;
    src.loop = true;
    src.loopStart = 0;
    src.loopEnd = buf.duration;
    const g = c.createGain();
    g.gain.setValueAtTime(0, c.currentTime);
    g.gain.linearRampToValueAtTime(vol, c.currentTime + fadein);
    src.connect(g);
    g.connect(masterGain);
    src.start();
    currentSrc = src;
    currentSrc._gainNode = g;
  }

  async function _crossfade(key, vol=0.75) {
    const c = getCtx();
    const buf = await renderTrack(key);
    // Fade out l'actuel
    if (currentSrc && currentSrc._gainNode) {
      const oldGain = currentSrc._gainNode;
      oldGain.gain.setValueAtTime(oldGain.gain.value, c.currentTime);
      oldGain.gain.linearRampToValueAtTime(0, c.currentTime + 0.5);
      const oldSrc = currentSrc;
      setTimeout(() => { try { oldSrc.stop(); } catch(e){} }, 600);
      currentSrc = null;
    }
    await new Promise(r => setTimeout(r, 300));
    _playBuffer(buf, vol, 0.5);
  }

  // Pr√©-render les 3 tracks d'un boss en arri√®re-plan
  function preloadBoss(lvlIdx) {
    for (let p=0; p<3; p++) {
      const key = `b${lvlIdx}-${p}`;
      renderTrack(key).catch(e => console.warn('Preload failed', key, e));
    }
  }

  return {
    init() {
      getCtx();
      // Pr√©-charger le niveau 0 d√®s que possible
      if (typeof requestIdleCallback !== 'undefined') {
        requestIdleCallback(() => preloadBoss(0));
      } else {
        setTimeout(() => preloadBoss(0), 1000);
      }
    },

    // Appel√© dans loadLevel(idx) ‚Äî musique d'ambiance pr√©-boss
    onLoadLevel(idx) {
      _engaged = false;
      const key = `b${idx}-0`;
      renderTrack(key).then(buf => {
        _playBuffer(buf, 0.55, 2.0);
      }).catch(e => console.error('Music error', e));
      // Pr√©-charger les 3 pistes en avance
      preloadBoss(idx);
      // Et pr√©-charger le niveau suivant si il existe
      if (idx + 1 < 3) {
        setTimeout(() => preloadBoss(idx + 1), 5000);
      }
    },

    // Appel√© quand spawnBoss() ‚Äî boss apparu, on reste sur l'ambient
    onSpawnBoss(lvlIdx) {
      // On continue la musique ambiante ‚Äî pas de changement ici
      // La transition vers le combat se fait au premier √©change
    },

    // Appel√© quand le premier √©change de coups se produit (boss en combat)
    onCombatStart(lvlIdx) {
      if (_engaged) return;
      _engaged = true;
      const key = `b${lvlIdx}-1`;
      _crossfade(key, 0.78);
    },

    // Appel√© quand rageMode = true (phase finale)
    onRageMode(lvlIdx) {
      const key = `b${lvlIdx}-2`;
      _crossfade(key, 0.88);
    },

    // Fade out et stop
    stop(fadeDur=1.5) {
      if (!actx || !currentSrc) return;
      if (currentSrc._gainNode) {
        const g = currentSrc._gainNode;
        g.gain.setValueAtTime(g.gain.value, actx.currentTime);
        g.gain.linearRampToValueAtTime(0, actx.currentTime + fadeDur);
      }
      const s = currentSrc;
      currentSrc = null;
      setTimeout(() => { try { s.stop(); } catch(e){} }, fadeDur * 1000 + 200);
    },

    get engaged() { return _engaged; }
  };
})();
</script>
</body>

</html>
